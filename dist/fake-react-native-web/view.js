'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var React = require('react');

var _require = require('aphrodite'),
    StyleSheet = _require.StyleSheet,
    css = _require.css;

var View = React.createClass({
    displayName: 'View',

    propTypes: {
        ariaLabel: React.PropTypes.string,
        children: React.PropTypes.oneOfType([React.PropTypes.arrayOf(React.PropTypes.node), React.PropTypes.node]),
        // The `dynamicStyle` prop is provided for animating dynamic
        // properties, as creating Aphrodite StyleSheets in animation loops is
        // expensive. `dynamicStyle` should be a raw style object, rather than
        // a StyleSheet.
        dynamicStyle: React.PropTypes.any,
        // The `extraClassName` prop should almost never be used. It gives the
        // client a way to provide an additional CSS class name, to augment
        // the class name generated by Aphrodite. (Right now, it's only used to
        // disable some externally-applied CSS that would otherwise be far too
        // difficult to override with inline styles.)
        extraClassName: React.PropTypes.string,
        numberOfLines: React.PropTypes.number,
        onClick: React.PropTypes.func,
        onTouchCancel: React.PropTypes.func,
        onTouchEnd: React.PropTypes.func,
        onTouchMove: React.PropTypes.func,
        onTouchStart: React.PropTypes.func,
        role: React.PropTypes.string,
        style: React.PropTypes.any
    },

    statics: {
        styles: StyleSheet.create({
            // From: https://github.com/necolas/react-native-web/blob/master/src/components/View/index.js
            initial: {
                alignItems: 'stretch',
                borderWidth: 0,
                borderStyle: 'solid',
                boxSizing: 'border-box',
                display: 'flex',
                flexBasis: 'auto',
                flexDirection: 'column',
                margin: 0,
                padding: 0,
                position: 'relative',
                // button and anchor reset
                backgroundColor: 'transparent',
                color: 'inherit',
                font: 'inherit',
                textAlign: 'inherit',
                textDecorationLine: 'none',
                // list reset
                listStyle: 'none',
                // fix flexbox bugs
                maxWidth: '100%',
                minHeight: 0,
                minWidth: 0
            }
        })
    },

    render: function render() {
        var _this = this;

        var className = css.apply(undefined, [View.styles.initial].concat(_toConsumableArray(Array.isArray(this.props.style) ? this.props.style : [this.props.style]))) + (this.props.extraClassName ? ' ' + this.props.extraClassName : "");

        return React.createElement(
            'div',
            {
                className: className,
                style: this.props.dynamicStyle,
                onClick: this.props.onClick,
                onTouchCancel: this.props.onTouchCancel,
                onTouchEnd: this.props.onTouchEnd,
                onTouchMove: this.props.onTouchMove,
                onTouchStart: this.props.onTouchStart,
                onMouseDown: function onMouseDown(e) {
                    // Touch events have extra properties compared to mouse
                    // events and also have a concept of "pointer lock",
                    // where the element that receives the touchstart event
                    // receives all subsequent events for that same touch,
                    // whereas mouse events change target if the cursor
                    // moves. We take mouse events and pretend they're touch
                    // events.
                    var augmentMouseEvent = function augmentMouseEvent(e) {
                        e.touches = e.changedTouches = [{
                            identifier: 1,
                            clientX: e.clientX,
                            clientY: e.clientY
                        }];
                        e.isMouseEvent = true;
                    };

                    var doc = _this._div.ownerDocument;
                    var onMove = function onMove(e) {
                        augmentMouseEvent(e);
                        _this.props.onTouchMove && _this.props.onTouchMove(e);
                    };
                    var onUp = function onUp(e) {
                        doc.removeEventListener('mousemove', onMove);
                        doc.removeEventListener('mouseup', onUp);
                        augmentMouseEvent(e);
                        _this.props.onTouchEnd && _this.props.onTouchEnd(e);
                    };
                    doc.addEventListener('mousemove', onMove, false);
                    doc.addEventListener('mouseup', onUp, false);

                    // Need to .persist() a React event object before adding
                    // properties to it since it's reused otherwise.
                    e.persist();
                    augmentMouseEvent(e);
                    _this.props.onTouchStart && _this.props.onTouchStart(e);
                },
                ref: function ref(node) {
                    return _this._div = node;
                },
                'aria-label': this.props.ariaLabel,
                role: this.props.role
            },
            this.props.children
        );
    }
});

module.exports = View;