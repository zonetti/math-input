webpackJsonp([0],{

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar React = __webpack_require__(1);\nvar ReactDOM = __webpack_require__(32);\n\nvar App = __webpack_require__(166);\n\nReactDOM.render(React.createElement(App, null), document.getElementById('root'));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQU0sUUFBUSxvQkFBUSxDQUFSLENBQVI7QUFDTixJQUFNLFdBQVcsb0JBQVEsRUFBUixDQUFYOztBQUVOLElBQU0sTUFBTSxvQkFBUSxHQUFSLENBQU47O0FBRU4sU0FBUyxNQUFULENBQWdCLG9CQUFDLEdBQUQsT0FBaEIsRUFBeUIsU0FBUyxjQUFULENBQXdCLE1BQXhCLENBQXpCIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG5jb25zdCBBcHAgPSByZXF1aXJlKCcuL2FwcCcpO1xuXG5SZWFjdERPTS5yZW5kZXIoPEFwcCAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9pbmRleC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 166:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar React = __webpack_require__(1);\n\nvar _require = __webpack_require__(167);\n\nvar Provider = _require.Provider;\n\nvar _require2 = __webpack_require__(211);\n\nvar View = _require2.View;\n\n\nvar MathInput = __webpack_require__(189);\nvar MathKeypad = __webpack_require__(218);\nvar store = __webpack_require__(216);\n\nvar App = React.createClass({\n    displayName: 'App',\n    render: function render() {\n        return React.createElement(\n            View,\n            null,\n            React.createElement(MathInput, { currentValue: 'foo' }),\n            React.createElement(\n                Provider,\n                { store: store },\n                React.createElement(MathKeypad, null)\n            )\n        );\n    }\n});\n\nmodule.exports = App;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwLmpzPzdhYzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFNLFFBQVEsb0JBQVEsQ0FBUixDQUFSOztlQUNlLG9CQUFRLEdBQVI7O0lBQWI7O2dCQUVTLG9CQUFRLEdBQVI7O0lBQVQ7OztBQUVSLElBQU0sWUFBWSxvQkFBUSxHQUFSLENBQVo7QUFDTixJQUFNLGFBQWEsb0JBQVEsR0FBUixDQUFiO0FBQ04sSUFBTSxRQUFRLG9CQUFRLEdBQVIsQ0FBUjs7QUFFTixJQUFNLE1BQU0sTUFBTSxXQUFOLENBQWtCOztBQUMxQiw4QkFBUztBQUNMLGVBQU87QUFBQyxnQkFBRDs7WUFDSCxvQkFBQyxTQUFELElBQVcsY0FBYSxLQUFiLEVBQVgsQ0FERztZQUVIO0FBQUMsd0JBQUQ7a0JBQVUsT0FBTyxLQUFQLEVBQVY7Z0JBQ0ksb0JBQUMsVUFBRCxPQURKO2FBRkc7U0FBUCxDQURLO0tBRGlCO0NBQWxCLENBQU47O0FBV04sT0FBTyxPQUFQLEdBQWlCLEdBQWpCIiwiZmlsZSI6IjE2Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ3JlYWN0LXJlZHV4Jyk7XG5cbmNvbnN0IHsgVmlldyB9ID0gcmVxdWlyZSgnLi9yZWFjdC1uYXRpdmUnKTtcblxuY29uc3QgTWF0aElucHV0ID0gcmVxdWlyZSgnLi9tYXRoLWlucHV0Jyk7XG5jb25zdCBNYXRoS2V5cGFkID0gcmVxdWlyZSgnLi9tYXRoLWtleXBhZCcpO1xuY29uc3Qgc3RvcmUgPSByZXF1aXJlKCcuL3N0b3JlJyk7XG5cbmNvbnN0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiA8Vmlldz5cbiAgICAgICAgICAgIDxNYXRoSW5wdXQgY3VycmVudFZhbHVlPVwiZm9vXCIgLz5cbiAgICAgICAgICAgIDxQcm92aWRlciBzdG9yZT17c3RvcmV9PlxuICAgICAgICAgICAgICAgIDxNYXRoS2V5cGFkIC8+XG4gICAgICAgICAgICA8L1Byb3ZpZGVyPlxuICAgICAgICA8L1ZpZXc+O1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2FwcC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 189:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar React = __webpack_require__(1);\nvar ReactDOM = __webpack_require__(32);\n\nvar _require = __webpack_require__(190);\n\nvar StyleSheet = _require.StyleSheet;\n\nvar MathQuill = __webpack_require__(214);\n\nvar _require2 = __webpack_require__(211);\n\nvar View = _require2.View;\n\n\nvar actions = __webpack_require__(215);\nvar Keys = __webpack_require__(217);\n\nvar MathInput = React.createClass({\n    displayName: 'MathInput',\n\n    propTypes: {\n        currentValue: React.PropTypes.string.isRequired\n    },\n\n    // cursor: React.PropTypes.number,\n    // onChange: React.PropTypes.func,\n    componentDidMount: function componentDidMount() {\n        var _this = this;\n\n        var container = ReactDOM.findDOMNode(this);\n        var span = document.createElement('span');\n        container.appendChild(span);\n\n        var MQ = MathQuill.getInterface(2);\n        this.mathField = MQ.MathField(span, {\n            handlers: {\n                edit: function edit() {\n                    console.log(_this.mathField.latex());\n                }\n            }\n        });\n\n        // pass this component's handleKey method to the store so it can call\n        // it whenever the store gets an KeyPress action from the keypad\n        actions.registerKeyHandler(this.handleKey);\n    },\n    handleKey: function handleKey(key, cmd) {\n        if (Object.values(Keys).includes(key)) {\n            this.mathField.keystroke(key);\n        } else if (cmd) {\n            this.mathField.cmd(key).focus();\n        } else {\n            this.mathField.write(key).focus();\n        }\n    },\n    render: function render() {\n        return React.createElement(View, { style: styles.input });\n    }\n});\n\nvar styles = StyleSheet.create({\n    input: {\n        margin: 10,\n        width: 300,\n        fontSize: 48\n    }\n});\n\nmodule.exports = MathInput;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC1pbnB1dC5qcz8wN2ZiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBTSxRQUFRLG9CQUFRLENBQVIsQ0FBUjtBQUNOLElBQU0sV0FBVyxvQkFBUSxFQUFSLENBQVg7O2VBQ2lCLG9CQUFRLEdBQVI7O0lBQWY7O0FBQ1IsSUFBTSxZQUFZLG9CQUFRLEdBQVIsQ0FBWjs7Z0JBRVcsb0JBQVEsR0FBUjs7SUFBVDs7O0FBRVIsSUFBTSxVQUFVLG9CQUFRLEdBQVIsQ0FBVjtBQUNOLElBQU0sT0FBTyxvQkFBUSxHQUFSLENBQVA7O0FBRU4sSUFBTSxZQUFZLE1BQU0sV0FBTixDQUFrQjs7O0FBQ2hDLGVBQVc7QUFDUCxzQkFBYyxNQUFNLFNBQU4sQ0FBZ0IsTUFBaEIsQ0FBdUIsVUFBdkI7S0FEbEI7Ozs7QUFNQSxvREFBb0I7OztBQUNoQixZQUFNLFlBQVksU0FBUyxXQUFULENBQXFCLElBQXJCLENBQVosQ0FEVTtBQUVoQixZQUFNLE9BQU8sU0FBUyxhQUFULENBQXVCLE1BQXZCLENBQVAsQ0FGVTtBQUdoQixrQkFBVSxXQUFWLENBQXNCLElBQXRCLEVBSGdCOztBQUtoQixZQUFJLEtBQUssVUFBVSxZQUFWLENBQXVCLENBQXZCLENBQUwsQ0FMWTtBQU1oQixhQUFLLFNBQUwsR0FBaUIsR0FBRyxTQUFILENBQWEsSUFBYixFQUFtQjtBQUNoQyxzQkFBVTtBQUNOLHNCQUFNLGdCQUFNO0FBQ1IsNEJBQVEsR0FBUixDQUFZLE1BQUssU0FBTCxDQUFlLEtBQWYsRUFBWixFQURRO2lCQUFOO2FBRFY7U0FEYSxDQUFqQjs7OztBQU5nQixlQWdCaEIsQ0FBUSxrQkFBUixDQUEyQixLQUFLLFNBQUwsQ0FBM0IsQ0FoQmdCO0tBUFk7QUEwQmhDLGtDQUFVLEtBQUssS0FBSztBQUNoQixZQUFJLE9BQU8sTUFBUCxDQUFjLElBQWQsRUFBb0IsUUFBcEIsQ0FBNkIsR0FBN0IsQ0FBSixFQUF1QztBQUNuQyxpQkFBSyxTQUFMLENBQWUsU0FBZixDQUF5QixHQUF6QixFQURtQztTQUF2QyxNQUVPLElBQUksR0FBSixFQUFTO0FBQ1osaUJBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsR0FBbkIsRUFBd0IsS0FBeEIsR0FEWTtTQUFULE1BRUE7QUFDSCxpQkFBSyxTQUFMLENBQWUsS0FBZixDQUFxQixHQUFyQixFQUEwQixLQUExQixHQURHO1NBRkE7S0E3QnFCO0FBb0NoQyw4QkFBUztBQUNMLGVBQU8sb0JBQUMsSUFBRCxJQUFNLE9BQU8sT0FBTyxLQUFQLEVBQWIsQ0FBUCxDQURLO0tBcEN1QjtDQUFsQixDQUFaOztBQXlDTixJQUFNLFNBQVMsV0FBVyxNQUFYLENBQWtCO0FBQzdCLFdBQU87QUFDSCxnQkFBUSxFQUFSO0FBQ0EsZUFBTyxHQUFQO0FBQ0Esa0JBQVUsRUFBVjtLQUhKO0NBRFcsQ0FBVDs7QUFRTixPQUFPLE9BQVAsR0FBaUIsU0FBakIiLCJmaWxlIjoiMTg5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbmNvbnN0IHsgU3R5bGVTaGVldCB9ID0gcmVxdWlyZShcImFwaHJvZGl0ZVwiKTtcbmNvbnN0IE1hdGhRdWlsbCA9IHJlcXVpcmUoJ21hdGhxdWlsbCcpO1xuXG5jb25zdCB7IFZpZXcgfSA9IHJlcXVpcmUoJy4vcmVhY3QtbmF0aXZlJyk7XG5cbmNvbnN0IGFjdGlvbnMgPSByZXF1aXJlKCcuL2FjdGlvbnMnKTtcbmNvbnN0IEtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuY29uc3QgTWF0aElucHV0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgIHByb3BUeXBlczoge1xuICAgICAgICBjdXJyZW50VmFsdWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgICAgLy8gY3Vyc29yOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICAvLyBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHNwYW4pO1xuXG4gICAgICAgIHZhciBNUSA9IE1hdGhRdWlsbC5nZXRJbnRlcmZhY2UoMik7XG4gICAgICAgIHRoaXMubWF0aEZpZWxkID0gTVEuTWF0aEZpZWxkKHNwYW4sIHtcbiAgICAgICAgICAgIGhhbmRsZXJzOiB7XG4gICAgICAgICAgICAgICAgZWRpdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLm1hdGhGaWVsZC5sYXRleCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHBhc3MgdGhpcyBjb21wb25lbnQncyBoYW5kbGVLZXkgbWV0aG9kIHRvIHRoZSBzdG9yZSBzbyBpdCBjYW4gY2FsbFxuICAgICAgICAvLyBpdCB3aGVuZXZlciB0aGUgc3RvcmUgZ2V0cyBhbiBLZXlQcmVzcyBhY3Rpb24gZnJvbSB0aGUga2V5cGFkXG4gICAgICAgIGFjdGlvbnMucmVnaXN0ZXJLZXlIYW5kbGVyKHRoaXMuaGFuZGxlS2V5KTtcbiAgICB9LFxuXG4gICAgaGFuZGxlS2V5KGtleSwgY21kKSB7XG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKEtleXMpLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMubWF0aEZpZWxkLmtleXN0cm9rZShrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZCkge1xuICAgICAgICAgICAgdGhpcy5tYXRoRmllbGQuY21kKGtleSkuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWF0aEZpZWxkLndyaXRlKGtleSkuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiA8VmlldyBzdHlsZT17c3R5bGVzLmlucHV0fSAvPjtcbiAgICB9LFxufSk7XG5cbmNvbnN0IHN0eWxlcyA9IFN0eWxlU2hlZXQuY3JlYXRlKHtcbiAgICBpbnB1dDoge1xuICAgICAgICBtYXJnaW46IDEwLFxuICAgICAgICB3aWR0aDogMzAwLFxuICAgICAgICBmb250U2l6ZTogNDhcbiAgICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aElucHV0O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbWF0aC1pbnB1dC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 211:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n// pale imitation of https://github.com/necolas/react-native-web\n// components' style prop accept aphrodite StyleSheets\n\nmodule.exports = {\n    View: __webpack_require__(212),\n    Text: __webpack_require__(213)\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVhY3QtbmF0aXZlLmpzPzU2YWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFHQSxPQUFPLE9BQVAsR0FBaUI7QUFDYixVQUFNLG9CQUFRLEdBQVIsQ0FBTjtBQUNBLFVBQU0sb0JBQVEsR0FBUixDQUFOO0NBRkoiLCJmaWxlIjoiMjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFsZSBpbWl0YXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL25lY29sYXMvcmVhY3QtbmF0aXZlLXdlYlxuLy8gY29tcG9uZW50cycgc3R5bGUgcHJvcCBhY2NlcHQgYXBocm9kaXRlIFN0eWxlU2hlZXRzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFZpZXc6IHJlcXVpcmUoJy4vdmlldycpLFxuICAgIFRleHQ6IHJlcXVpcmUoJy4vdGV4dCcpLFxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3JlYWN0LW5hdGl2ZS5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 212:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar React = __webpack_require__(1);\n\nvar _require = __webpack_require__(190);\n\nvar StyleSheet = _require.StyleSheet;\nvar css = _require.css;\n\n\nvar View = function View(props) {\n    var className = Array.isArray(props.style) ? css.apply(undefined, [styles.initial].concat(_toConsumableArray(props.style))) : css(styles.initial, props.style);\n\n    return React.createElement(\n        'div',\n        { onClick: props.onClick, className: className },\n        props.children\n    );\n};\n\n// https://github.com/necolas/react-native-web/blob/master/src/components/View/index.js\nvar styles = StyleSheet.create({\n    initial: {\n        alignItems: 'stretch',\n        borderWidth: 0,\n        borderStyle: 'solid',\n        boxSizing: 'border-box',\n        display: 'flex',\n        flexBasis: 'auto',\n        flexDirection: 'column',\n        margin: 0,\n        padding: 0,\n        position: 'relative',\n        // button and anchor reset\n        backgroundColor: 'transparent',\n        color: 'inherit',\n        font: 'inherit',\n        textAlign: 'inherit',\n        textDecorationLine: 'none',\n        // list reset\n        listStyle: 'none',\n        // fix flexbox bugs\n        maxWidth: '100%',\n        minHeight: 0,\n        minWidth: 0\n    }\n});\n\nmodule.exports = View;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlldy5qcz8zMjBhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFNLFFBQVEsb0JBQVEsQ0FBUixDQUFSOztlQUNzQixvQkFBUSxHQUFSOztJQUFwQjtJQUFZOzs7QUFFcEIsSUFBTSxPQUFPLFNBQVAsSUFBTyxDQUFDLEtBQUQsRUFBVztBQUNwQixRQUFNLFlBQVksTUFBTSxPQUFOLENBQWMsTUFBTSxLQUFOLENBQWQsR0FDWixzQkFBSSxPQUFPLE9BQVAsNEJBQW1CLE1BQU0sS0FBTixFQUF2QixDQURZLEdBRVosSUFBSSxPQUFPLE9BQVAsRUFBZ0IsTUFBTSxLQUFOLENBRlIsQ0FERTs7QUFLcEIsV0FBTzs7VUFBSyxTQUFTLE1BQU0sT0FBTixFQUFlLFdBQVcsU0FBWCxFQUE3QjtRQUNGLE1BQU0sUUFBTjtLQURMLENBTG9CO0NBQVg7OztBQVdiLElBQU0sU0FBUyxXQUFXLE1BQVgsQ0FBa0I7QUFDN0IsYUFBUztBQUNMLG9CQUFZLFNBQVo7QUFDQSxxQkFBYSxDQUFiO0FBQ0EscUJBQWEsT0FBYjtBQUNBLG1CQUFXLFlBQVg7QUFDQSxpQkFBUyxNQUFUO0FBQ0EsbUJBQVcsTUFBWDtBQUNBLHVCQUFlLFFBQWY7QUFDQSxnQkFBUSxDQUFSO0FBQ0EsaUJBQVMsQ0FBVDtBQUNBLGtCQUFVLFVBQVY7O0FBRUEseUJBQWlCLGFBQWpCO0FBQ0EsZUFBTyxTQUFQO0FBQ0EsY0FBTSxTQUFOO0FBQ0EsbUJBQVcsU0FBWDtBQUNBLDRCQUFvQixNQUFwQjs7QUFFQSxtQkFBVyxNQUFYOztBQUVBLGtCQUFVLE1BQVY7QUFDQSxtQkFBVyxDQUFYO0FBQ0Esa0JBQVUsQ0FBVjtLQXRCSjtDQURXLENBQVQ7O0FBMkJOLE9BQU8sT0FBUCxHQUFpQixJQUFqQiIsImZpbGUiOiIyMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCB7IFN0eWxlU2hlZXQsIGNzcyB9ID0gcmVxdWlyZSgnYXBocm9kaXRlJyk7XG5cbmNvbnN0IFZpZXcgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBBcnJheS5pc0FycmF5KHByb3BzLnN0eWxlKVxuICAgICAgICA/IGNzcyhzdHlsZXMuaW5pdGlhbCwgLi4ucHJvcHMuc3R5bGUpXG4gICAgICAgIDogY3NzKHN0eWxlcy5pbml0aWFsLCBwcm9wcy5zdHlsZSk7XG5cbiAgICByZXR1cm4gPGRpdiBvbkNsaWNrPXtwcm9wcy5vbkNsaWNrfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICA8L2Rpdj47XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbmVjb2xhcy9yZWFjdC1uYXRpdmUtd2ViL2Jsb2IvbWFzdGVyL3NyYy9jb21wb25lbnRzL1ZpZXcvaW5kZXguanNcbmNvbnN0IHN0eWxlcyA9IFN0eWxlU2hlZXQuY3JlYXRlKHtcbiAgICBpbml0aWFsOiB7XG4gICAgICAgIGFsaWduSXRlbXM6ICdzdHJldGNoJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIC8vIGJ1dHRvbiBhbmQgYW5jaG9yIHJlc2V0XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgY29sb3I6ICdpbmhlcml0JyxcbiAgICAgICAgZm9udDogJ2luaGVyaXQnLFxuICAgICAgICB0ZXh0QWxpZ246ICdpbmhlcml0JyxcbiAgICAgICAgdGV4dERlY29yYXRpb25MaW5lOiAnbm9uZScsXG4gICAgICAgIC8vIGxpc3QgcmVzZXRcbiAgICAgICAgbGlzdFN0eWxlOiAnbm9uZScsXG4gICAgICAgIC8vIGZpeCBmbGV4Ym94IGJ1Z3NcbiAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWluSGVpZ2h0OiAwLFxuICAgICAgICBtaW5XaWR0aDogMFxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXc7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy92aWV3LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 213:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar React = __webpack_require__(1);\n\nvar _require = __webpack_require__(190);\n\nvar StyleSheet = _require.StyleSheet;\nvar css = _require.css;\n\n\nvar Text = React.createClass({\n    displayName: 'Text',\n    render: function render() {\n        var _props = this.props;\n        var numberOfLines = _props.numberOfLines;\n        var style = _props.style;\n\n\n        var className = css(styles.initial, style, numberOfLines === 1 && styles.singleLineStyle);\n\n        return React.createElement(\n            'span',\n            { className: className },\n            this.props.children\n        );\n    }\n});\n\n// https://github.com/necolas/react-native-web/blob/master/src/components/Text/index.js\nvar styles = StyleSheet.create({\n    initial: {\n        color: 'inherit',\n        display: 'inline',\n        font: 'inherit',\n        margin: 0,\n        padding: 0,\n        textDecorationLine: 'none',\n        wordWrap: 'break-word'\n    },\n    singleLineStyle: {\n        maxWidth: '100%',\n        overflow: 'hidden',\n        textOverflow: 'ellipsis',\n        whiteSpace: 'nowrap'\n    }\n});\n\nmodule.exports = Text;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdGV4dC5qcz83N2JjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBTSxRQUFRLG9CQUFRLENBQVIsQ0FBUjs7ZUFDc0Isb0JBQVEsR0FBUjs7SUFBcEI7SUFBWTs7O0FBRXBCLElBQU0sT0FBTyxNQUFNLFdBQU4sQ0FBa0I7O0FBQzNCLDhCQUFTO3FCQUMwQixLQUFLLEtBQUwsQ0FEMUI7WUFDRSxxQ0FERjtZQUNpQixxQkFEakI7OztBQUdMLFlBQU0sWUFBWSxJQUNkLE9BQU8sT0FBUCxFQUNBLEtBRmMsRUFHZCxrQkFBa0IsQ0FBbEIsSUFBdUIsT0FBTyxlQUFQLENBSHJCLENBSEQ7O0FBU0wsZUFBTzs7Y0FBTSxXQUFXLFNBQVgsRUFBTjtZQUNGLEtBQUssS0FBTCxDQUFXLFFBQVg7U0FETCxDQVRLO0tBRGtCO0NBQWxCLENBQVA7OztBQWlCTixJQUFNLFNBQVMsV0FBVyxNQUFYLENBQWtCO0FBQzdCLGFBQVM7QUFDTCxlQUFPLFNBQVA7QUFDQSxpQkFBUyxRQUFUO0FBQ0EsY0FBTSxTQUFOO0FBQ0EsZ0JBQVEsQ0FBUjtBQUNBLGlCQUFTLENBQVQ7QUFDQSw0QkFBb0IsTUFBcEI7QUFDQSxrQkFBVSxZQUFWO0tBUEo7QUFTQSxxQkFBaUI7QUFDYixrQkFBVSxNQUFWO0FBQ0Esa0JBQVUsUUFBVjtBQUNBLHNCQUFjLFVBQWQ7QUFDQSxvQkFBWSxRQUFaO0tBSko7Q0FWVyxDQUFUOztBQWtCTixPQUFPLE9BQVAsR0FBaUIsSUFBakIiLCJmaWxlIjoiMjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgeyBTdHlsZVNoZWV0LCBjc3MgfSA9IHJlcXVpcmUoJ2FwaHJvZGl0ZScpO1xuXG5jb25zdCBUZXh0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge251bWJlck9mTGluZXMsIHN0eWxlfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gY3NzKFxuICAgICAgICAgICAgc3R5bGVzLmluaXRpYWwsXG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgIG51bWJlck9mTGluZXMgPT09IDEgJiYgc3R5bGVzLnNpbmdsZUxpbmVTdHlsZVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiA8c3BhbiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cbiAgICAgICAgPC9zcGFuPjtcbiAgICB9XG59KTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25lY29sYXMvcmVhY3QtbmF0aXZlLXdlYi9ibG9iL21hc3Rlci9zcmMvY29tcG9uZW50cy9UZXh0L2luZGV4LmpzXG5jb25zdCBzdHlsZXMgPSBTdHlsZVNoZWV0LmNyZWF0ZSh7XG4gICAgaW5pdGlhbDoge1xuICAgICAgICBjb2xvcjogJ2luaGVyaXQnLFxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lJyxcbiAgICAgICAgZm9udDogJ2luaGVyaXQnLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIHRleHREZWNvcmF0aW9uTGluZTogJ25vbmUnLFxuICAgICAgICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnXG4gICAgfSxcbiAgICBzaW5nbGVMaW5lU3R5bGU6IHtcbiAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnXG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3RleHQuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 214:
/***/ function(module, exports) {

	eval("/**\n * MathQuill v0.10.1               http://mathquill.com\n * by Han, Jeanine, and Mary  maintainers@mathquill.com\n *\n * This Source Code Form is subject to the terms of the\n * Mozilla Public License, v. 2.0. If a copy of the MPL\n * was not distributed with this file, You can obtain\n * one at http://mozilla.org/MPL/2.0/.\n */\n\n(function() {\n\nvar jQuery = window.jQuery,\n  undefined,\n  mqCmdId = 'mathquill-command-id',\n  mqBlockId = 'mathquill-block-id',\n  min = Math.min,\n  max = Math.max;\n\nfunction noop() {}\n\n/**\n * A utility higher-order function that makes defining variadic\n * functions more convenient by letting you essentially define functions\n * with the last argument as a splat, i.e. the last argument \"gathers up\"\n * remaining arguments to the function:\n *   var doStuff = variadic(function(first, rest) { return rest; });\n *   doStuff(1, 2, 3); // => [2, 3]\n */\nvar __slice = [].slice;\nfunction variadic(fn) {\n  var numFixedArgs = fn.length - 1;\n  return function() {\n    var args = __slice.call(arguments, 0, numFixedArgs);\n    var varArg = __slice.call(arguments, numFixedArgs);\n    return fn.apply(this, args.concat([ varArg ]));\n  };\n}\n\n/**\n * A utility higher-order function that makes combining object-oriented\n * programming and functional programming techniques more convenient:\n * given a method name and any number of arguments to be bound, returns\n * a function that calls it's first argument's method of that name (if\n * it exists) with the bound arguments and any additional arguments that\n * are passed:\n *   var sendMethod = send('method', 1, 2);\n *   var obj = { method: function() { return Array.apply(this, arguments); } };\n *   sendMethod(obj, 3, 4); // => [1, 2, 3, 4]\n *   // or more specifically,\n *   var obj2 = { method: function(one, two, three) { return one*two + three; } };\n *   sendMethod(obj2, 3); // => 5\n *   sendMethod(obj2, 4); // => 6\n */\nvar send = variadic(function(method, args) {\n  return variadic(function(obj, moreArgs) {\n    if (method in obj) return obj[method].apply(obj, args.concat(moreArgs));\n  });\n});\n\n/**\n * A utility higher-order function that creates \"implicit iterators\"\n * from \"generators\": given a function that takes in a sole argument,\n * a \"yield_\" function, that calls \"yield_\" repeatedly with an object as\n * a sole argument (presumably objects being iterated over), returns\n * a function that calls it's first argument on each of those objects\n * (if the first argument is a function, it is called repeatedly with\n * each object as the first argument, otherwise it is stringified and\n * the method of that name is called on each object (if such a method\n * exists)), passing along all additional arguments:\n *   var a = [\n *     { method: function(list) { list.push(1); } },\n *     { method: function(list) { list.push(2); } },\n *     { method: function(list) { list.push(3); } }\n *   ];\n *   a.each = iterator(function(yield_) {\n *     for (var i in this) yield_(this[i]);\n *   });\n *   var list = [];\n *   a.each('method', list);\n *   list; // => [1, 2, 3]\n *   // Note that the for-in loop will yield 'each', but 'each' maps to\n *   // the function object created by iterator() which does not have a\n *   // .method() method, so that just fails silently.\n */\nfunction iterator(generator) {\n  return variadic(function(fn, args) {\n    if (typeof fn !== 'function') fn = send(fn);\n    var yield_ = function(obj) { return fn.apply(obj, [ obj ].concat(args)); };\n    return generator.call(this, yield_);\n  });\n}\n\n/**\n * sugar to make defining lots of commands easier.\n * TODO: rethink this.\n */\nfunction bind(cons /*, args... */) {\n  var args = __slice.call(arguments, 1);\n  return function() {\n    return cons.apply(this, args);\n  };\n}\n\n/**\n * a development-only debug method.  This definition and all\n * calls to `pray` will be stripped from the minified\n * build of mathquill.\n *\n * This function must be called by name to be removed\n * at compile time.  Do not define another function\n * with the same name, and only call this function by\n * name.\n */\nfunction pray(message, cond) {\n  if (!cond) throw new Error('prayer failed: '+message);\n}\nvar P = (function(prototype, ownProperty, undefined) {\n  // helper functions that also help minification\n  function isObject(o) { return typeof o === 'object'; }\n  function isFunction(f) { return typeof f === 'function'; }\n\n  // used to extend the prototypes of superclasses (which might not\n  // have `.Bare`s)\n  function SuperclassBare() {}\n\n  return function P(_superclass /* = Object */, definition) {\n    // handle the case where no superclass is given\n    if (definition === undefined) {\n      definition = _superclass;\n      _superclass = Object;\n    }\n\n    // C is the class to be returned.\n    //\n    // It delegates to instantiating an instance of `Bare`, so that it\n    // will always return a new instance regardless of the calling\n    // context.\n    //\n    //  TODO: the Chrome inspector shows all created objects as `C`\n    //        rather than `Object`.  Setting the .name property seems to\n    //        have no effect.  Is there a way to override this behavior?\n    function C() {\n      var self = new Bare;\n      if (isFunction(self.init)) self.init.apply(self, arguments);\n      return self;\n    }\n\n    // C.Bare is a class with a noop constructor.  Its prototype is the\n    // same as C, so that instances of C.Bare are also instances of C.\n    // New objects can be allocated without initialization by calling\n    // `new MyClass.Bare`.\n    function Bare() {}\n    C.Bare = Bare;\n\n    // Set up the prototype of the new class.\n    var _super = SuperclassBare[prototype] = _superclass[prototype];\n    var proto = Bare[prototype] = C[prototype] = C.p = new SuperclassBare;\n\n    // other variables, as a minifier optimization\n    var extensions;\n\n\n    // set the constructor property on the prototype, for convenience\n    proto.constructor = C;\n\n    C.mixin = function(def) {\n      Bare[prototype] = C[prototype] = P(C, def)[prototype];\n      return C;\n    }\n\n    return (C.open = function(def) {\n      extensions = {};\n\n      if (isFunction(def)) {\n        // call the defining function with all the arguments you need\n        // extensions captures the return value.\n        extensions = def.call(C, proto, _super, C, _superclass);\n      }\n      else if (isObject(def)) {\n        // if you passed an object instead, we'll take it\n        extensions = def;\n      }\n\n      // ...and extend it\n      if (isObject(extensions)) {\n        for (var ext in extensions) {\n          if (ownProperty.call(extensions, ext)) {\n            proto[ext] = extensions[ext];\n          }\n        }\n      }\n\n      // if there's no init, we assume we're inheriting a non-pjs class, so\n      // we default to applying the superclass's constructor.\n      if (!isFunction(proto.init)) {\n        proto.init = _superclass;\n      }\n\n      return C;\n    })(definition);\n  }\n\n  // as a minifier optimization, we've closured in a few helper functions\n  // and the string 'prototype' (C[p] is much shorter than C.prototype)\n})('prototype', ({}).hasOwnProperty);\n/*************************************************\n * Base classes of edit tree-related objects\n *\n * Only doing tree node manipulation via these\n * adopt/ disown methods guarantees well-formedness\n * of the tree.\n ************************************************/\n\n// L = 'left'\n// R = 'right'\n//\n// the contract is that they can be used as object properties\n// and (-L) === R, and (-R) === L.\nvar L = -1;\nvar R = 1;\n\nfunction prayDirection(dir) {\n  pray('a direction was passed', dir === L || dir === R);\n}\n\n/**\n * Tiny extension of jQuery adding directionalized DOM manipulation methods.\n *\n * Funny how Pjs v3 almost just works with `jQuery.fn.init`.\n *\n * jQuery features that don't work on $:\n *   - jQuery.*, like jQuery.ajax, obviously (Pjs doesn't and shouldn't\n *                                            copy constructor properties)\n *\n *   - jQuery(function), the shortcut for `jQuery(document).ready(function)`,\n *     because `jQuery.fn.init` is idiosyncratic and Pjs doing, essentially,\n *     `jQuery.fn.init.apply(this, arguments)` isn't quite right, you need:\n *\n *       _.init = function(s, c) { jQuery.fn.init.call(this, s, c, $(document)); };\n *\n *     if you actually give a shit (really, don't bother),\n *     see https://github.com/jquery/jquery/blob/1.7.2/src/core.js#L889\n *\n *   - jQuery(selector), because jQuery translates that to\n *     `jQuery(document).find(selector)`, but Pjs doesn't (should it?) let\n *     you override the result of a constructor call\n *       + note that because of the jQuery(document) shortcut-ness, there's also\n *         the 3rd-argument-needs-to-be-`$(document)` thing above, but the fix\n *         for that (as can be seen above) is really easy. This problem requires\n *         a way more intrusive fix\n *\n * And that's it! Everything else just magically works because jQuery internally\n * uses `this.constructor()` everywhere (hence calling `$`), but never ever does\n * `this.constructor.find` or anything like that, always doing `jQuery.find`.\n */\nvar $ = P(jQuery, function(_) {\n  _.insDirOf = function(dir, el) {\n    return dir === L ?\n      this.insertBefore(el.first()) : this.insertAfter(el.last());\n  };\n  _.insAtDirEnd = function(dir, el) {\n    return dir === L ? this.prependTo(el) : this.appendTo(el);\n  };\n});\n\nvar Point = P(function(_) {\n  _.parent = 0;\n  _[L] = 0;\n  _[R] = 0;\n\n  _.init = function(parent, leftward, rightward) {\n    this.parent = parent;\n    this[L] = leftward;\n    this[R] = rightward;\n  };\n\n  this.copy = function(pt) {\n    return Point(pt.parent, pt[L], pt[R]);\n  };\n});\n\n/**\n * MathQuill virtual-DOM tree-node abstract base class\n */\nvar Node = P(function(_) {\n  _[L] = 0;\n  _[R] = 0\n  _.parent = 0;\n\n  var id = 0;\n  function uniqueNodeId() { return id += 1; }\n  this.byId = {};\n\n  _.init = function() {\n    this.id = uniqueNodeId();\n    Node.byId[this.id] = this;\n\n    this.ends = {};\n    this.ends[L] = 0;\n    this.ends[R] = 0;\n  };\n\n  _.dispose = function() { delete Node.byId[this.id]; };\n\n  _.toString = function() { return '{{ MathQuill Node #'+this.id+' }}'; };\n\n  _.jQ = $();\n  _.jQadd = function(jQ) { return this.jQ = this.jQ.add(jQ); };\n  _.jQize = function(jQ) {\n    // jQuery-ifies this.html() and links up the .jQ of all corresponding Nodes\n    var jQ = $(jQ || this.html());\n\n    function jQadd(el) {\n      if (el.getAttribute) {\n        var cmdId = el.getAttribute('mathquill-command-id');\n        var blockId = el.getAttribute('mathquill-block-id');\n        if (cmdId) Node.byId[cmdId].jQadd(el);\n        if (blockId) Node.byId[blockId].jQadd(el);\n      }\n      for (el = el.firstChild; el; el = el.nextSibling) {\n        jQadd(el);\n      }\n    }\n\n    for (var i = 0; i < jQ.length; i += 1) jQadd(jQ[i]);\n    return jQ;\n  };\n\n  _.createDir = function(dir, cursor) {\n    prayDirection(dir);\n    var node = this;\n    node.jQize();\n    node.jQ.insDirOf(dir, cursor.jQ);\n    cursor[dir] = node.adopt(cursor.parent, cursor[L], cursor[R]);\n    return node;\n  };\n  _.createLeftOf = function(el) { return this.createDir(L, el); };\n\n  _.selectChildren = function(leftEnd, rightEnd) {\n    return Selection(leftEnd, rightEnd);\n  };\n\n  _.bubble = iterator(function(yield_) {\n    for (var ancestor = this; ancestor; ancestor = ancestor.parent) {\n      var result = yield_(ancestor);\n      if (result === false) break;\n    }\n\n    return this;\n  });\n\n  _.postOrder = iterator(function(yield_) {\n    (function recurse(descendant) {\n      descendant.eachChild(recurse);\n      yield_(descendant);\n    })(this);\n\n    return this;\n  });\n\n  _.isEmpty = function() {\n    return this.ends[L] === 0 && this.ends[R] === 0;\n  };\n\n  _.children = function() {\n    return Fragment(this.ends[L], this.ends[R]);\n  };\n\n  _.eachChild = function() {\n    var children = this.children();\n    children.each.apply(children, arguments);\n    return this;\n  };\n\n  _.foldChildren = function(fold, fn) {\n    return this.children().fold(fold, fn);\n  };\n\n  _.withDirAdopt = function(dir, parent, withDir, oppDir) {\n    Fragment(this, this).withDirAdopt(dir, parent, withDir, oppDir);\n    return this;\n  };\n\n  _.adopt = function(parent, leftward, rightward) {\n    Fragment(this, this).adopt(parent, leftward, rightward);\n    return this;\n  };\n\n  _.disown = function() {\n    Fragment(this, this).disown();\n    return this;\n  };\n\n  _.remove = function() {\n    this.jQ.remove();\n    this.postOrder('dispose');\n    return this.disown();\n  };\n});\n\nfunction prayWellFormed(parent, leftward, rightward) {\n  pray('a parent is always present', parent);\n  pray('leftward is properly set up', (function() {\n    // either it's empty and `rightward` is the left end child (possibly empty)\n    if (!leftward) return parent.ends[L] === rightward;\n\n    // or it's there and its [R] and .parent are properly set up\n    return leftward[R] === rightward && leftward.parent === parent;\n  })());\n\n  pray('rightward is properly set up', (function() {\n    // either it's empty and `leftward` is the right end child (possibly empty)\n    if (!rightward) return parent.ends[R] === leftward;\n\n    // or it's there and its [L] and .parent are properly set up\n    return rightward[L] === leftward && rightward.parent === parent;\n  })());\n}\n\n\n/**\n * An entity outside the virtual tree with one-way pointers (so it's only a\n * \"view\" of part of the tree, not an actual node/entity in the tree) that\n * delimits a doubly-linked list of sibling nodes.\n * It's like a fanfic love-child between HTML DOM DocumentFragment and the Range\n * classes: like DocumentFragment, its contents must be sibling nodes\n * (unlike Range, whose contents are arbitrary contiguous pieces of subtrees),\n * but like Range, it has only one-way pointers to its contents, its contents\n * have no reference to it and in fact may still be in the visible tree (unlike\n * DocumentFragment, whose contents must be detached from the visible tree\n * and have their 'parent' pointers set to the DocumentFragment).\n */\nvar Fragment = P(function(_) {\n  _.init = function(withDir, oppDir, dir) {\n    if (dir === undefined) dir = L;\n    prayDirection(dir);\n\n    pray('no half-empty fragments', !withDir === !oppDir);\n\n    this.ends = {};\n\n    if (!withDir) return;\n\n    pray('withDir is passed to Fragment', withDir instanceof Node);\n    pray('oppDir is passed to Fragment', oppDir instanceof Node);\n    pray('withDir and oppDir have the same parent',\n         withDir.parent === oppDir.parent);\n\n    this.ends[dir] = withDir;\n    this.ends[-dir] = oppDir;\n\n    // To build the jquery collection for a fragment, accumulate elements\n    // into an array and then call jQ.add once on the result. jQ.add sorts the\n    // collection according to document order each time it is called, so\n    // building a collection by folding jQ.add directly takes more than\n    // quadratic time in the number of elements.\n    //\n    // https://github.com/jquery/jquery/blob/2.1.4/src/traversing.js#L112\n    var accum = this.fold([], function (accum, el) {\n      accum.push.apply(accum, el.jQ.get());\n      return accum;\n    });\n\n    this.jQ = this.jQ.add(accum);\n  };\n  _.jQ = $();\n\n  // like Cursor::withDirInsertAt(dir, parent, withDir, oppDir)\n  _.withDirAdopt = function(dir, parent, withDir, oppDir) {\n    return (dir === L ? this.adopt(parent, withDir, oppDir)\n                      : this.adopt(parent, oppDir, withDir));\n  };\n  _.adopt = function(parent, leftward, rightward) {\n    prayWellFormed(parent, leftward, rightward);\n\n    var self = this;\n    self.disowned = false;\n\n    var leftEnd = self.ends[L];\n    if (!leftEnd) return this;\n\n    var rightEnd = self.ends[R];\n\n    if (leftward) {\n      // NB: this is handled in the ::each() block\n      // leftward[R] = leftEnd\n    } else {\n      parent.ends[L] = leftEnd;\n    }\n\n    if (rightward) {\n      rightward[L] = rightEnd;\n    } else {\n      parent.ends[R] = rightEnd;\n    }\n\n    self.ends[R][R] = rightward;\n\n    self.each(function(el) {\n      el[L] = leftward;\n      el.parent = parent;\n      if (leftward) leftward[R] = el;\n\n      leftward = el;\n    });\n\n    return self;\n  };\n\n  _.disown = function() {\n    var self = this;\n    var leftEnd = self.ends[L];\n\n    // guard for empty and already-disowned fragments\n    if (!leftEnd || self.disowned) return self;\n\n    self.disowned = true;\n\n    var rightEnd = self.ends[R]\n    var parent = leftEnd.parent;\n\n    prayWellFormed(parent, leftEnd[L], leftEnd);\n    prayWellFormed(parent, rightEnd, rightEnd[R]);\n\n    if (leftEnd[L]) {\n      leftEnd[L][R] = rightEnd[R];\n    } else {\n      parent.ends[L] = rightEnd[R];\n    }\n\n    if (rightEnd[R]) {\n      rightEnd[R][L] = leftEnd[L];\n    } else {\n      parent.ends[R] = leftEnd[L];\n    }\n\n    return self;\n  };\n\n  _.remove = function() {\n    this.jQ.remove();\n    this.each('postOrder', 'dispose');\n    return this.disown();\n  };\n\n  _.each = iterator(function(yield_) {\n    var self = this;\n    var el = self.ends[L];\n    if (!el) return self;\n\n    for (; el !== self.ends[R][R]; el = el[R]) {\n      var result = yield_(el);\n      if (result === false) break;\n    }\n\n    return self;\n  });\n\n  _.fold = function(fold, fn) {\n    this.each(function(el) {\n      fold = fn.call(this, fold, el);\n    });\n\n    return fold;\n  };\n});\n\n\n/**\n * Registry of LaTeX commands and commands created when typing\n * a single character.\n *\n * (Commands are all subclasses of Node.)\n */\nvar LatexCmds = {}, CharCmds = {};\n/********************************************\n * Cursor and Selection \"singleton\" classes\n *******************************************/\n\n/* The main thing that manipulates the Math DOM. Makes sure to manipulate the\nHTML DOM to match. */\n\n/* Sort of singletons, since there should only be one per editable math\ntextbox, but any one HTML document can contain many such textboxes, so any one\nJS environment could actually contain many instances. */\n\n//A fake cursor in the fake textbox that the math is rendered in.\nvar Cursor = P(Point, function(_) {\n  _.init = function(initParent, options) {\n    this.parent = initParent;\n    this.options = options;\n\n    var jQ = this.jQ = this._jQ = $('<span class=\"mq-cursor\">&#8203;</span>');\n    //closured for setInterval\n    this.blink = function(){ jQ.toggleClass('mq-blink'); };\n\n    this.upDownCache = {};\n  };\n\n  _.show = function() {\n    this.jQ = this._jQ.removeClass('mq-blink');\n    if ('intervalId' in this) //already was shown, just restart interval\n      clearInterval(this.intervalId);\n    else { //was hidden and detached, insert this.jQ back into HTML DOM\n      if (this[R]) {\n        if (this.selection && this.selection.ends[L][L] === this[L])\n          this.jQ.insertBefore(this.selection.jQ);\n        else\n          this.jQ.insertBefore(this[R].jQ.first());\n      }\n      else\n        this.jQ.appendTo(this.parent.jQ);\n      this.parent.focus();\n    }\n    this.intervalId = setInterval(this.blink, 500);\n    return this;\n  };\n  _.hide = function() {\n    if ('intervalId' in this)\n      clearInterval(this.intervalId);\n    delete this.intervalId;\n    this.jQ.detach();\n    this.jQ = $();\n    return this;\n  };\n\n  _.withDirInsertAt = function(dir, parent, withDir, oppDir) {\n    var oldParent = this.parent;\n    this.parent = parent;\n    this[dir] = withDir;\n    this[-dir] = oppDir;\n    // by contract, .blur() is called after all has been said and done\n    // and the cursor has actually been moved\n    if (oldParent !== parent && oldParent.blur) oldParent.blur();\n  };\n  _.insDirOf = function(dir, el) {\n    prayDirection(dir);\n    this.jQ.insDirOf(dir, el.jQ);\n    this.withDirInsertAt(dir, el.parent, el[dir], el);\n    this.parent.jQ.addClass('mq-hasCursor');\n    return this;\n  };\n  _.insLeftOf = function(el) { return this.insDirOf(L, el); };\n  _.insRightOf = function(el) { return this.insDirOf(R, el); };\n\n  _.insAtDirEnd = function(dir, el) {\n    prayDirection(dir);\n    this.jQ.insAtDirEnd(dir, el.jQ);\n    this.withDirInsertAt(dir, el, 0, el.ends[dir]);\n    el.focus();\n    return this;\n  };\n  _.insAtLeftEnd = function(el) { return this.insAtDirEnd(L, el); };\n  _.insAtRightEnd = function(el) { return this.insAtDirEnd(R, el); };\n\n  /**\n   * jump up or down from one block Node to another:\n   * - cache the current Point in the node we're jumping from\n   * - check if there's a Point in it cached for the node we're jumping to\n   *   + if so put the cursor there,\n   *   + if not seek a position in the node that is horizontally closest to\n   *     the cursor's current position\n   */\n  _.jumpUpDown = function(from, to) {\n    var self = this;\n    self.upDownCache[from.id] = Point.copy(self);\n    var cached = self.upDownCache[to.id];\n    if (cached) {\n      cached[R] ? self.insLeftOf(cached[R]) : self.insAtRightEnd(cached.parent);\n    }\n    else {\n      var pageX = self.offset().left;\n      to.seek(pageX, self);\n    }\n  };\n  _.offset = function() {\n    //in Opera 11.62, .getBoundingClientRect() and hence jQuery::offset()\n    //returns all 0's on inline elements with negative margin-right (like\n    //the cursor) at the end of their parent, so temporarily remove the\n    //negative margin-right when calling jQuery::offset()\n    //Opera bug DSK-360043\n    //http://bugs.jquery.com/ticket/11523\n    //https://github.com/jquery/jquery/pull/717\n    var self = this, offset = self.jQ.removeClass('mq-cursor').offset();\n    self.jQ.addClass('mq-cursor');\n    return offset;\n  }\n  _.unwrapGramp = function() {\n    var gramp = this.parent.parent;\n    var greatgramp = gramp.parent;\n    var rightward = gramp[R];\n    var cursor = this;\n\n    var leftward = gramp[L];\n    gramp.disown().eachChild(function(uncle) {\n      if (uncle.isEmpty()) return;\n\n      uncle.children()\n        .adopt(greatgramp, leftward, rightward)\n        .each(function(cousin) {\n          cousin.jQ.insertBefore(gramp.jQ.first());\n        })\n      ;\n\n      leftward = uncle.ends[R];\n    });\n\n    if (!this[R]) { //then find something to be rightward to insLeftOf\n      if (this[L])\n        this[R] = this[L][R];\n      else {\n        while (!this[R]) {\n          this.parent = this.parent[R];\n          if (this.parent)\n            this[R] = this.parent.ends[L];\n          else {\n            this[R] = gramp[R];\n            this.parent = greatgramp;\n            break;\n          }\n        }\n      }\n    }\n    if (this[R])\n      this.insLeftOf(this[R]);\n    else\n      this.insAtRightEnd(greatgramp);\n\n    gramp.jQ.remove();\n\n    if (gramp[L].siblingDeleted) gramp[L].siblingDeleted(cursor.options, R);\n    if (gramp[R].siblingDeleted) gramp[R].siblingDeleted(cursor.options, L);\n  };\n  _.startSelection = function() {\n    var anticursor = this.anticursor = Point.copy(this);\n    var ancestors = anticursor.ancestors = {}; // a map from each ancestor of\n      // the anticursor, to its child that is also an ancestor; in other words,\n      // the anticursor's ancestor chain in reverse order\n    for (var ancestor = anticursor; ancestor.parent; ancestor = ancestor.parent) {\n      ancestors[ancestor.parent.id] = ancestor;\n    }\n  };\n  _.endSelection = function() {\n    delete this.anticursor;\n  };\n  _.select = function() {\n    var anticursor = this.anticursor;\n    if (this[L] === anticursor[L] && this.parent === anticursor.parent) return false;\n\n    // Find the lowest common ancestor (`lca`), and the ancestor of the cursor\n    // whose parent is the LCA (which'll be an end of the selection fragment).\n    for (var ancestor = this; ancestor.parent; ancestor = ancestor.parent) {\n      if (ancestor.parent.id in anticursor.ancestors) {\n        var lca = ancestor.parent;\n        break;\n      }\n    }\n    pray('cursor and anticursor in the same tree', lca);\n    // The cursor and the anticursor should be in the same tree, because the\n    // mousemove handler attached to the document, unlike the one attached to\n    // the root HTML DOM element, doesn't try to get the math tree node of the\n    // mousemove target, and Cursor::seek() based solely on coordinates stays\n    // within the tree of `this` cursor's root.\n\n    // The other end of the selection fragment, the ancestor of the anticursor\n    // whose parent is the LCA.\n    var antiAncestor = anticursor.ancestors[lca.id];\n\n    // Now we have two either Nodes or Points, guaranteed to have a common\n    // parent and guaranteed that if both are Points, they are not the same,\n    // and we have to figure out which is the left end and which the right end\n    // of the selection.\n    var leftEnd, rightEnd, dir = R;\n\n    // This is an extremely subtle algorithm.\n    // As a special case, `ancestor` could be a Point and `antiAncestor` a Node\n    // immediately to `ancestor`'s left.\n    // In all other cases,\n    // - both Nodes\n    // - `ancestor` a Point and `antiAncestor` a Node\n    // - `ancestor` a Node and `antiAncestor` a Point\n    // `antiAncestor[R] === rightward[R]` for some `rightward` that is\n    // `ancestor` or to its right, if and only if `antiAncestor` is to\n    // the right of `ancestor`.\n    if (ancestor[L] !== antiAncestor) {\n      for (var rightward = ancestor; rightward; rightward = rightward[R]) {\n        if (rightward[R] === antiAncestor[R]) {\n          dir = L;\n          leftEnd = ancestor;\n          rightEnd = antiAncestor;\n          break;\n        }\n      }\n    }\n    if (dir === R) {\n      leftEnd = antiAncestor;\n      rightEnd = ancestor;\n    }\n\n    // only want to select Nodes up to Points, can't select Points themselves\n    if (leftEnd instanceof Point) leftEnd = leftEnd[R];\n    if (rightEnd instanceof Point) rightEnd = rightEnd[L];\n\n    this.hide().selection = lca.selectChildren(leftEnd, rightEnd);\n    this.insDirOf(dir, this.selection.ends[dir]);\n    this.selectionChanged();\n    console.log(this);\n    return true;\n  };\n\n  _.clearSelection = function() {\n    if (this.selection) {\n      this.selection.clear();\n      delete this.selection;\n      this.selectionChanged();\n    }\n    return this;\n  };\n  _.deleteSelection = function() {\n    if (!this.selection) return;\n\n    this[L] = this.selection.ends[L][L];\n    this[R] = this.selection.ends[R][R];\n    this.selection.remove();\n    this.selectionChanged();\n    delete this.selection;\n  };\n  _.replaceSelection = function() {\n    var seln = this.selection;\n    if (seln) {\n      this[L] = seln.ends[L][L];\n      this[R] = seln.ends[R][R];\n      delete this.selection;\n    }\n    return seln;\n  };\n});\n\nvar Selection = P(Fragment, function(_, super_) {\n  _.init = function() {\n    super_.init.apply(this, arguments);\n    this.jQ = this.jQ.wrapAll('<span class=\"mq-selection\"></span>').parent();\n      //can't do wrapAll(this.jQ = $(...)) because wrapAll will clone it\n  };\n  _.adopt = function() {\n    this.jQ.replaceWith(this.jQ = this.jQ.children());\n    return super_.adopt.apply(this, arguments);\n  };\n  _.clear = function() {\n    // using the browser's native .childNodes property so that we\n    // don't discard text nodes.\n    this.jQ.replaceWith(this.jQ[0].childNodes);\n    return this;\n  };\n  _.join = function(methodName) {\n    return this.fold('', function(fold, child) {\n      return fold + child[methodName]();\n    });\n  };\n});\n/*********************************************\n * Controller for a MathQuill instance,\n * on which services are registered with\n *\n *   Controller.open(function(_) { ... });\n *\n ********************************************/\n\nvar Controller = P(function(_) {\n  _.init = function(root, container, options) {\n    this.id = root.id;\n    this.data = {};\n\n    this.root = root;\n    this.container = container;\n    this.options = options;\n\n    root.controller = this;\n\n    this.cursor = root.cursor = Cursor(root, options);\n    // TODO: stop depending on root.cursor, and rm it\n  };\n\n  _.handle = function(name, dir) {\n    var handlers = this.options.handlers;\n    if (handlers && handlers.fns[name]) {\n      var mq = handlers.APIClasses[this.KIND_OF_MQ](this);\n      if (dir === L || dir === R) handlers.fns[name](dir, mq);\n      else handlers.fns[name](mq);\n    }\n  };\n\n  var notifyees = [];\n  this.onNotify = function(f) { notifyees.push(f); };\n  _.notify = function() {\n    for (var i = 0; i < notifyees.length; i += 1) {\n      notifyees[i].apply(this.cursor, arguments);\n    }\n    return this;\n  };\n});\n/*********************************************************\n * The publicly exposed MathQuill API.\n ********************************************************/\n\nvar API = {}, Options = P(), optionProcessors = {}, Progenote = P(), EMBEDS = {};\n\n/**\n * Interface Versioning (#459, #495) to allow us to virtually guarantee\n * backcompat. v0.10.x introduces it, so for now, don't completely break the\n * API for people who don't know about it, just complain with console.warn().\n *\n * The methods are shimmed in outro.js so that MQ.MathField.prototype etc can\n * be accessed.\n */\nfunction insistOnInterVer() {\n  if (window.console) console.warn(\n    'You are using the MathQuill API without specifying an interface version, ' +\n    'which will fail in v1.0.0. You can fix this easily by doing this before ' +\n    'doing anything else:\\n' +\n    '\\n' +\n    '    MathQuill = MathQuill.getInterface(1);\\n' +\n    '    // now MathQuill.MathField() works like it used to\\n' +\n    '\\n' +\n    'See also the \"`dev` branch (2014\\u20132015) \\u2192 v0.10.0 Migration Guide\" at\\n' +\n    '  https://github.com/mathquill/mathquill/wiki/%60dev%60-branch-(2014%E2%80%932015)-%E2%86%92-v0.10.0-Migration-Guide'\n  );\n}\n// globally exported API object\nfunction MathQuill(el) {\n  insistOnInterVer();\n  return MQ1(el);\n};\nMathQuill.prototype = Progenote.p;\nMathQuill.interfaceVersion = function(v) {\n  // shim for #459-era interface versioning (ended with #495)\n  if (v !== 1) throw 'Only interface version 1 supported. You specified: ' + v;\n  insistOnInterVer = function() {\n    if (window.console) console.warn(\n      'You called MathQuill.interfaceVersion(1); to specify the interface ' +\n      'version, which will fail in v1.0.0. You can fix this easily by doing ' +\n      'this before doing anything else:\\n' +\n      '\\n' +\n      '    MathQuill = MathQuill.getInterface(1);\\n' +\n      '    // now MathQuill.MathField() works like it used to\\n' +\n      '\\n' +\n      'See also the \"`dev` branch (2014\\u20132015) \\u2192 v0.10.0 Migration Guide\" at\\n' +\n      '  https://github.com/mathquill/mathquill/wiki/%60dev%60-branch-(2014%E2%80%932015)-%E2%86%92-v0.10.0-Migration-Guide'\n    );\n  };\n  insistOnInterVer();\n  return MathQuill;\n};\nMathQuill.getInterface = getInterface;\n\nvar MIN = getInterface.MIN = 1, MAX = getInterface.MAX = 2;\nfunction getInterface(v) {\n  if (!(MIN <= v && v <= MAX)) throw 'Only interface versions between ' +\n    MIN + ' and ' + MAX + ' supported. You specified: ' + v;\n\n  /**\n   * Function that takes an HTML element and, if it's the root HTML element of a\n   * static math or math or text field, returns an API object for it (else, null).\n   *\n   *   var mathfield = MQ.MathField(mathFieldSpan);\n   *   assert(MQ(mathFieldSpan).id === mathfield.id);\n   *   assert(MQ(mathFieldSpan).id === MQ(mathFieldSpan).id);\n   *\n   */\n  function MQ(el) {\n    if (!el || !el.nodeType) return null; // check that `el` is a HTML element, using the\n      // same technique as jQuery: https://github.com/jquery/jquery/blob/679536ee4b7a92ae64a5f58d90e9cc38c001e807/src/core/init.js#L92\n    var blockId = $(el).children('.mq-root-block').attr(mqBlockId);\n    var ctrlr = blockId && Node.byId[blockId].controller;\n    return ctrlr ? APIClasses[ctrlr.KIND_OF_MQ](ctrlr) : null;\n  };\n  var APIClasses = {};\n\n  MQ.L = L;\n  MQ.R = R;\n\n  function config(currentOptions, newOptions) {\n    if (newOptions && newOptions.handlers) {\n      newOptions.handlers = { fns: newOptions.handlers, APIClasses: APIClasses };\n    }\n    for (var name in newOptions) if (newOptions.hasOwnProperty(name)) {\n      var value = newOptions[name], processor = optionProcessors[name];\n      currentOptions[name] = (processor ? processor(value) : value);\n    }\n  }\n  MQ.config = function(opts) { config(Options.p, opts); return this; };\n  MQ.registerEmbed = function(name, options) {\n    if (!/^[a-z][a-z0-9]*$/i.test(name)) {\n      throw 'Embed name must start with letter and be only letters and digits';\n    }\n    EMBEDS[name] = options;\n  };\n\n  var AbstractMathQuill = APIClasses.AbstractMathQuill = P(Progenote, function(_) {\n    _.init = function(ctrlr) {\n      this.__controller = ctrlr;\n      this.__options = ctrlr.options;\n      this.id = ctrlr.id;\n      this.data = ctrlr.data;\n    };\n    _.__mathquillify = function(classNames) {\n      var ctrlr = this.__controller, root = ctrlr.root, el = ctrlr.container;\n      ctrlr.createTextarea();\n\n      var contents = el.addClass(classNames).contents().detach();\n      root.jQ =\n        $('<span class=\"mq-root-block\"/>').attr(mqBlockId, root.id).appendTo(el);\n      this.latex(contents.text());\n\n      this.revert = function() {\n        return el.empty().unbind('.mathquill')\n        .removeClass('mq-editable-field mq-math-mode mq-text-mode')\n        .append(contents);\n      };\n    };\n    _.config = function(opts) { config(this.__options, opts); return this; };\n    _.el = function() { return this.__controller.container[0]; };\n    _.text = function() { return this.__controller.exportText(); };\n    _.latex = function(latex) {\n      if (arguments.length > 0) {\n        this.__controller.renderLatexMath(latex);\n        if (this.__controller.blurred) this.__controller.cursor.hide().parent.blur();\n        return this;\n      }\n      return this.__controller.exportLatex();\n    };\n    _.html = function() {\n      return this.__controller.root.jQ.html()\n        .replace(/ mathquill-(?:command|block)-id=\"?\\d+\"?/g, '')\n        .replace(/<span class=\"?mq-cursor( mq-blink)?\"?>.?<\\/span>/i, '')\n        .replace(/ mq-hasCursor|mq-hasCursor ?/, '')\n        .replace(/ class=(\"\"|(?= |>))/g, '');\n    };\n    _.reflow = function() {\n      this.__controller.root.postOrder('reflow');\n      return this;\n    };\n  });\n  MQ.prototype = AbstractMathQuill.prototype;\n\n  APIClasses.EditableField = P(AbstractMathQuill, function(_, super_) {\n    _.__mathquillify = function() {\n      super_.__mathquillify.apply(this, arguments);\n      this.__controller.editable = true;\n      this.__controller.delegateMouseEvents();\n      this.__controller.editablesTextareaEvents();\n      return this;\n    };\n    _.focus = function() { this.__controller.textarea.focus(); return this; };\n    _.blur = function() { this.__controller.textarea.blur(); return this; };\n    _.write = function(latex) {\n      this.__controller.writeLatex(latex);\n      this.__controller.scrollHoriz();\n      if (this.__controller.blurred) this.__controller.cursor.hide().parent.blur();\n      return this;\n    };\n    _.cmd = function(cmd) {\n      var ctrlr = this.__controller.notify(), cursor = ctrlr.cursor;\n      if (/^\\\\[a-z]+$/i.test(cmd)) {\n        cmd = cmd.slice(1);\n        var klass = LatexCmds[cmd];\n        if (klass) {\n          cmd = klass(cmd);\n          if (cursor.selection) cmd.replaces(cursor.replaceSelection());\n          cmd.createLeftOf(cursor.show());\n          this.__controller.scrollHoriz();\n        }\n        else /* TODO: API needs better error reporting */;\n      }\n      else cursor.parent.write(cursor, cmd);\n      if (ctrlr.blurred) cursor.hide().parent.blur();\n      return this;\n    };\n    _.select = function() {\n      var ctrlr = this.__controller;\n      ctrlr.notify('move').cursor.insAtRightEnd(ctrlr.root);\n      while (ctrlr.cursor[L]) ctrlr.selectLeft();\n      return this;\n    };\n    _.clearSelection = function() {\n      this.__controller.cursor.clearSelection();\n      return this;\n    };\n\n    _.moveToDirEnd = function(dir) {\n      this.__controller.notify('move').cursor.insAtDirEnd(dir, this.__controller.root);\n      return this;\n    };\n    _.moveToLeftEnd = function() { return this.moveToDirEnd(L); };\n    _.moveToRightEnd = function() { return this.moveToDirEnd(R); };\n\n    _.keystroke = function(keys) {\n      var keys = keys.replace(/^\\s+|\\s+$/g, '').split(/\\s+/);\n      for (var i = 0; i < keys.length; i += 1) {\n        this.__controller.keystroke(keys[i], { preventDefault: noop });\n      }\n      return this;\n    };\n    _.typedText = function(text) {\n      for (var i = 0; i < text.length; i += 1) this.__controller.typedText(text.charAt(i));\n      return this;\n    };\n    _.dropEmbedded = function(pageX, pageY, options) {\n      var clientX = pageX - $(window).scrollLeft();\n      var clientY = pageY - $(window).scrollTop();\n\n      var el = document.elementFromPoint(clientX, clientY);\n      this.__controller.seek($(el), pageX, pageY);\n      var cmd = Embed().setOptions(options);\n      cmd.createLeftOf(this.__controller.cursor);\n    };\n  });\n  MQ.EditableField = function() { throw \"wtf don't call me, I'm 'abstract'\"; };\n  MQ.EditableField.prototype = APIClasses.EditableField.prototype;\n\n  /**\n   * Export the API functions that MathQuill-ify an HTML element into API objects\n   * of each class. If the element had already been MathQuill-ified but into a\n   * different kind (or it's not an HTML element), return null.\n   */\n  for (var kind in API) (function(kind, defAPIClass) {\n    var APIClass = APIClasses[kind] = defAPIClass(APIClasses);\n    MQ[kind] = function(el, opts) {\n      var mq = MQ(el);\n      if (mq instanceof APIClass || !el || !el.nodeType) return mq;\n      var ctrlr = Controller(APIClass.RootBlock(), $(el), Options());\n      ctrlr.KIND_OF_MQ = kind;\n      return APIClass(ctrlr).__mathquillify(opts, v);\n    };\n    MQ[kind].prototype = APIClass.prototype;\n  }(kind, API[kind]));\n\n  return MQ;\n}\n\nMathQuill.noConflict = function() {\n  window.MathQuill = origMathQuill;\n  return MathQuill;\n};\nvar origMathQuill = window.MathQuill;\nwindow.MathQuill = MathQuill;\n\nfunction RootBlockMixin(_) {\n  var names = 'moveOutOf deleteOutOf selectOutOf upOutOf downOutOf'.split(' ');\n  for (var i = 0; i < names.length; i += 1) (function(name) {\n    _[name] = function(dir) { this.controller.handle(name, dir); };\n  }(names[i]));\n  _.reflow = function() {\n    this.controller.handle('reflow');\n    this.controller.handle('edited');\n    this.controller.handle('edit');\n  };\n}\nvar Parser = P(function(_, super_, Parser) {\n  // The Parser object is a wrapper for a parser function.\n  // Externally, you use one to parse a string by calling\n  //   var result = SomeParser.parse('Me Me Me! Parse Me!');\n  // You should never call the constructor, rather you should\n  // construct your Parser from the base parsers and the\n  // parser combinator methods.\n\n  function parseError(stream, message) {\n    if (stream) {\n      stream = \"'\"+stream+\"'\";\n    }\n    else {\n      stream = 'EOF';\n    }\n\n    throw 'Parse Error: '+message+' at '+stream;\n  }\n\n  _.init = function(body) { this._ = body; };\n\n  _.parse = function(stream) {\n    return this.skip(eof)._(''+stream, success, parseError);\n\n    function success(stream, result) { return result; }\n  };\n\n  // -*- primitive combinators -*- //\n  _.or = function(alternative) {\n    pray('or is passed a parser', alternative instanceof Parser);\n\n    var self = this;\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      return self._(stream, onSuccess, failure);\n\n      function failure(newStream) {\n        return alternative._(stream, onSuccess, onFailure);\n      }\n    });\n  };\n\n  _.then = function(next) {\n    var self = this;\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      return self._(stream, success, onFailure);\n\n      function success(newStream, result) {\n        var nextParser = (next instanceof Parser ? next : next(result));\n        pray('a parser is returned', nextParser instanceof Parser);\n        return nextParser._(newStream, onSuccess, onFailure);\n      }\n    });\n  };\n\n  // -*- optimized iterative combinators -*- //\n  _.many = function() {\n    var self = this;\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      var xs = [];\n      while (self._(stream, success, failure));\n      return onSuccess(stream, xs);\n\n      function success(newStream, x) {\n        stream = newStream;\n        xs.push(x);\n        return true;\n      }\n\n      function failure() {\n        return false;\n      }\n    });\n  };\n\n  _.times = function(min, max) {\n    if (arguments.length < 2) max = min;\n    var self = this;\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      var xs = [];\n      var result = true;\n      var failure;\n\n      for (var i = 0; i < min; i += 1) {\n        result = self._(stream, success, firstFailure);\n        if (!result) return onFailure(stream, failure);\n      }\n\n      for (; i < max && result; i += 1) {\n        result = self._(stream, success, secondFailure);\n      }\n\n      return onSuccess(stream, xs);\n\n      function success(newStream, x) {\n        xs.push(x);\n        stream = newStream;\n        return true;\n      }\n\n      function firstFailure(newStream, msg) {\n        failure = msg;\n        stream = newStream;\n        return false;\n      }\n\n      function secondFailure(newStream, msg) {\n        return false;\n      }\n    });\n  };\n\n  // -*- higher-level combinators -*- //\n  _.result = function(res) { return this.then(succeed(res)); };\n  _.atMost = function(n) { return this.times(0, n); };\n  _.atLeast = function(n) {\n    var self = this;\n    return self.times(n).then(function(start) {\n      return self.many().map(function(end) {\n        return start.concat(end);\n      });\n    });\n  };\n\n  _.map = function(fn) {\n    return this.then(function(result) { return succeed(fn(result)); });\n  };\n\n  _.skip = function(two) {\n    return this.then(function(result) { return two.result(result); });\n  };\n\n  // -*- primitive parsers -*- //\n  var string = this.string = function(str) {\n    var len = str.length;\n    var expected = \"expected '\"+str+\"'\";\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      var head = stream.slice(0, len);\n\n      if (head === str) {\n        return onSuccess(stream.slice(len), head);\n      }\n      else {\n        return onFailure(stream, expected);\n      }\n    });\n  };\n\n  var regex = this.regex = function(re) {\n    pray('regexp parser is anchored', re.toString().charAt(1) === '^');\n\n    var expected = 'expected '+re;\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      var match = re.exec(stream);\n\n      if (match) {\n        var result = match[0];\n        return onSuccess(stream.slice(result.length), result);\n      }\n      else {\n        return onFailure(stream, expected);\n      }\n    });\n  };\n\n  var succeed = Parser.succeed = function(result) {\n    return Parser(function(stream, onSuccess) {\n      return onSuccess(stream, result);\n    });\n  };\n\n  var fail = Parser.fail = function(msg) {\n    return Parser(function(stream, _, onFailure) {\n      return onFailure(stream, msg);\n    });\n  };\n\n  var letter = Parser.letter = regex(/^[a-z]/i);\n  var letters = Parser.letters = regex(/^[a-z]*/i);\n  var digit = Parser.digit = regex(/^[0-9]/);\n  var digits = Parser.digits = regex(/^[0-9]*/);\n  var whitespace = Parser.whitespace = regex(/^\\s+/);\n  var optWhitespace = Parser.optWhitespace = regex(/^\\s*/);\n\n  var any = Parser.any = Parser(function(stream, onSuccess, onFailure) {\n    if (!stream) return onFailure(stream, 'expected any character');\n\n    return onSuccess(stream.slice(1), stream.charAt(0));\n  });\n\n  var all = Parser.all = Parser(function(stream, onSuccess, onFailure) {\n    return onSuccess('', stream);\n  });\n\n  var eof = Parser.eof = Parser(function(stream, onSuccess, onFailure) {\n    if (stream) return onFailure(stream, 'expected EOF');\n\n    return onSuccess(stream, stream);\n  });\n});\n/*************************************************\n * Sane Keyboard Events Shim\n *\n * An abstraction layer wrapping the textarea in\n * an object with methods to manipulate and listen\n * to events on, that hides all the nasty cross-\n * browser incompatibilities behind a uniform API.\n *\n * Design goal: This is a *HARD* internal\n * abstraction barrier. Cross-browser\n * inconsistencies are not allowed to leak through\n * and be dealt with by event handlers. All future\n * cross-browser issues that arise must be dealt\n * with here, and if necessary, the API updated.\n *\n * Organization:\n * - key values map and stringify()\n * - saneKeyboardEvents()\n *    + defer() and flush()\n *    + event handler logic\n *    + attach event handlers and export methods\n ************************************************/\n\nvar saneKeyboardEvents = (function() {\n  // The following [key values][1] map was compiled from the\n  // [DOM3 Events appendix section on key codes][2] and\n  // [a widely cited report on cross-browser tests of key codes][3],\n  // except for 10: 'Enter', which I've empirically observed in Safari on iOS\n  // and doesn't appear to conflict with any other known key codes.\n  //\n  // [1]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#keys-keyvalues\n  // [2]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes\n  // [3]: http://unixpapa.com/js/key.html\n  var KEY_VALUES = {\n    8: 'Backspace',\n    9: 'Tab',\n\n    10: 'Enter', // for Safari on iOS\n\n    13: 'Enter',\n\n    16: 'Shift',\n    17: 'Control',\n    18: 'Alt',\n    20: 'CapsLock',\n\n    27: 'Esc',\n\n    32: 'Spacebar',\n\n    33: 'PageUp',\n    34: 'PageDown',\n    35: 'End',\n    36: 'Home',\n\n    37: 'Left',\n    38: 'Up',\n    39: 'Right',\n    40: 'Down',\n\n    45: 'Insert',\n\n    46: 'Del',\n\n    144: 'NumLock'\n  };\n\n  // To the extent possible, create a normalized string representation\n  // of the key combo (i.e., key code and modifier keys).\n  function stringify(evt) {\n    var which = evt.which || evt.keyCode;\n    var keyVal = KEY_VALUES[which];\n    var key;\n    var modifiers = [];\n\n    if (evt.ctrlKey) modifiers.push('Ctrl');\n    if (evt.originalEvent && evt.originalEvent.metaKey) modifiers.push('Meta');\n    if (evt.altKey) modifiers.push('Alt');\n    if (evt.shiftKey) modifiers.push('Shift');\n\n    key = keyVal || String.fromCharCode(which);\n\n    if (!modifiers.length && !keyVal) return key;\n\n    modifiers.push(key);\n    return modifiers.join('-');\n  }\n\n  // create a keyboard events shim that calls callbacks at useful times\n  // and exports useful public methods\n  return function saneKeyboardEvents(el, handlers) {\n    var keydown = null;\n    var keypress = null;\n\n    var textarea = jQuery(el);\n    var target = jQuery(handlers.container || textarea);\n\n    // checkTextareaFor() is called after keypress or paste events to\n    // say \"Hey, I think something was just typed\" or \"pasted\" (resp.),\n    // so that at all subsequent opportune times (next event or timeout),\n    // will check for expected typed or pasted text.\n    // Need to check repeatedly because #135: in Safari 5.1 (at least),\n    // after selecting something and then typing, the textarea is\n    // incorrectly reported as selected during the input event (but not\n    // subsequently).\n    var checkTextarea = noop, timeoutId;\n    function checkTextareaFor(checker) {\n      checkTextarea = checker;\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(checker);\n    }\n    target.bind('keydown keypress input keyup focusout paste', function(e) { checkTextarea(e); });\n\n\n    // -*- public methods -*- //\n    function select(text) {\n      // check textarea at least once/one last time before munging (so\n      // no race condition if selection happens after keypress/paste but\n      // before checkTextarea), then never again ('cos it's been munged)\n      checkTextarea();\n      checkTextarea = noop;\n      clearTimeout(timeoutId);\n\n      textarea.val(text);\n      if (text && textarea[0].select) textarea[0].select();\n      shouldBeSelected = !!text;\n    }\n    var shouldBeSelected = false;\n\n    // -*- helper subroutines -*- //\n\n    // Determine whether there's a selection in the textarea.\n    // This will always return false in IE < 9, which don't support\n    // HTMLTextareaElement::selection{Start,End}.\n    function hasSelection() {\n      var dom = textarea[0];\n\n      if (!('selectionStart' in dom)) return false;\n      return dom.selectionStart !== dom.selectionEnd;\n    }\n\n    function handleKey() {\n      handlers.keystroke(stringify(keydown), keydown);\n    }\n\n    // -*- event handlers -*- //\n    function onKeydown(e) {\n      keydown = e;\n      keypress = null;\n\n      if (shouldBeSelected) checkTextareaFor(function(e) {\n        if (!(e && e.type === 'focusout') && textarea[0].select) {\n          textarea[0].select(); // re-select textarea in case it's an unrecognized\n        }\n        checkTextarea = noop; // key that clears the selection, then never\n        clearTimeout(timeoutId); // again, 'cos next thing might be blur\n      });\n\n      handleKey();\n    }\n\n    function onKeypress(e) {\n      // call the key handler for repeated keypresses.\n      // This excludes keypresses that happen directly\n      // after keydown.  In that case, there will be\n      // no previous keypress, so we skip it here\n      if (keydown && keypress) handleKey();\n\n      keypress = e;\n\n      checkTextareaFor(typedText);\n    }\n    function typedText() {\n      // If there is a selection, the contents of the textarea couldn't\n      // possibly have just been typed in.\n      // This happens in browsers like Firefox and Opera that fire\n      // keypress for keystrokes that are not text entry and leave the\n      // selection in the textarea alone, such as Ctrl-C.\n      // Note: we assume that browsers that don't support hasSelection()\n      // also never fire keypress on keystrokes that are not text entry.\n      // This seems reasonably safe because:\n      // - all modern browsers including IE 9+ support hasSelection(),\n      //   making it extremely unlikely any browser besides IE < 9 won't\n      // - as far as we know IE < 9 never fires keypress on keystrokes\n      //   that aren't text entry, which is only as reliable as our\n      //   tests are comprehensive, but the IE < 9 way to do\n      //   hasSelection() is poorly documented and is also only as\n      //   reliable as our tests are comprehensive\n      // If anything like #40 or #71 is reported in IE < 9, see\n      // b1318e5349160b665003e36d4eedd64101ceacd8\n      if (hasSelection()) return;\n\n      var text = textarea.val();\n      if (text.length === 1) {\n        textarea.val('');\n        handlers.typedText(text);\n      } // in Firefox, keys that don't type text, just clear seln, fire keypress\n      // https://github.com/mathquill/mathquill/issues/293#issuecomment-40997668\n      else if (text && textarea[0].select) textarea[0].select(); // re-select if that's why we're here\n    }\n\n    function onBlur() { keydown = keypress = null; }\n\n    function onPaste(e) {\n      // browsers are dumb.\n      //\n      // In Linux, middle-click pasting causes onPaste to be called,\n      // when the textarea is not necessarily focused.  We focus it\n      // here to ensure that the pasted text actually ends up in the\n      // textarea.\n      //\n      // It's pretty nifty that by changing focus in this handler,\n      // we can change the target of the default action.  (This works\n      // on keydown too, FWIW).\n      //\n      // And by nifty, we mean dumb (but useful sometimes).\n      textarea.focus();\n\n      checkTextareaFor(pastedText);\n    }\n    function pastedText() {\n      var text = textarea.val();\n      textarea.val('');\n      if (text) handlers.paste(text);\n    }\n\n    // -*- attach event handlers -*- //\n    target.bind({\n      keydown: onKeydown,\n      keypress: onKeypress,\n      focusout: onBlur,\n      paste: onPaste\n    });\n\n    // -*- export public methods -*- //\n    return {\n      select: select\n    };\n  };\n}());\n/***********************************************\n * Export math in a human-readable text format\n * As you can see, only half-baked so far.\n **********************************************/\n\nController.open(function(_, super_) {\n  _.exportText = function() {\n    return this.root.foldChildren('', function(text, child) {\n      return text + child.text();\n    });\n  };\n});\nController.open(function(_) {\n  _.focusBlurEvents = function() {\n    var ctrlr = this, root = ctrlr.root, cursor = ctrlr.cursor;\n    var blurTimeout;\n    ctrlr.textarea.focus(function() {\n      ctrlr.blurred = false;\n      clearTimeout(blurTimeout);\n      ctrlr.container.addClass('mq-focused');\n      if (!cursor.parent)\n        cursor.insAtRightEnd(root);\n      if (cursor.selection) {\n        cursor.selection.jQ.removeClass('mq-blur');\n        ctrlr.selectionChanged(); //re-select textarea contents after tabbing away and back\n      }\n      else\n        cursor.show();\n    }).blur(function() {\n      ctrlr.blurred = true;\n      blurTimeout = setTimeout(function() { // wait for blur on window; if\n        root.postOrder('intentionalBlur'); // none, intentional blur: #264\n        cursor.clearSelection().endSelection();\n        blur();\n      });\n      $(window).on('blur', windowBlur);\n    });\n    function windowBlur() { // blur event also fired on window, just switching\n      clearTimeout(blurTimeout); // tabs/windows, not intentional blur\n      if (cursor.selection) cursor.selection.jQ.addClass('mq-blur');\n      blur();\n    }\n    function blur() { // not directly in the textarea blur handler so as to be\n      cursor.hide().parent.blur(); // synchronous with/in the same frame as\n      ctrlr.container.removeClass('mq-focused'); // clearing/blurring selection\n      $(window).off('blur', windowBlur);\n    }\n    ctrlr.blurred = true;\n    cursor.hide().parent.blur();\n  };\n});\n\n/**\n * TODO: I wanted to move MathBlock::focus and blur here, it would clean\n * up lots of stuff like, TextBlock::focus is set to MathBlock::focus\n * and TextBlock::blur calls MathBlock::blur, when instead they could\n * use inheritance and super_.\n *\n * Problem is, there's lots of calls to .focus()/.blur() on nodes\n * outside Controller::focusBlurEvents(), such as .postOrder('blur') on\n * insertion, which if MathBlock::blur becomes Node::blur, would add the\n * 'blur' CSS class to all Symbol's (because .isEmpty() is true for all\n * of them).\n *\n * I'm not even sure there aren't other troublesome calls to .focus() or\n * .blur(), so this is TODO for now.\n */\n/*****************************************\n * Deals with the browser DOM events from\n * interaction with the typist.\n ****************************************/\n\nController.open(function(_) {\n  _.keystroke = function(key, evt) {\n    this.cursor.parent.keystroke(key, evt, this);\n  };\n});\n\nNode.open(function(_) {\n  _.keystroke = function(key, e, ctrlr) {\n    var cursor = ctrlr.cursor;\n\n    switch (key) {\n    case 'Ctrl-Shift-Backspace':\n    case 'Ctrl-Backspace':\n      ctrlr.ctrlDeleteDir(L);\n      break;\n\n    case 'Shift-Backspace':\n    case 'Backspace':\n      ctrlr.backspace();\n      break;\n\n    // Tab or Esc -> go one block right if it exists, else escape right.\n    case 'Esc':\n    case 'Tab':\n      ctrlr.escapeDir(R, key, e);\n      return;\n\n    // Shift-Tab -> go one block left if it exists, else escape left.\n    case 'Shift-Tab':\n    case 'Shift-Esc':\n      ctrlr.escapeDir(L, key, e);\n      return;\n\n    // End -> move to the end of the current block.\n    case 'End':\n      ctrlr.notify('move').cursor.insAtRightEnd(cursor.parent);\n      break;\n\n    // Ctrl-End -> move all the way to the end of the root block.\n    case 'Ctrl-End':\n      ctrlr.notify('move').cursor.insAtRightEnd(ctrlr.root);\n      break;\n\n    // Shift-End -> select to the end of the current block.\n    case 'Shift-End':\n      while (cursor[R]) {\n        ctrlr.selectRight();\n      }\n      break;\n\n    // Ctrl-Shift-End -> select to the end of the root block.\n    case 'Ctrl-Shift-End':\n      while (cursor[R] || cursor.parent !== ctrlr.root) {\n        ctrlr.selectRight();\n      }\n      break;\n\n    // Home -> move to the start of the root block or the current block.\n    case 'Home':\n      ctrlr.notify('move').cursor.insAtLeftEnd(cursor.parent);\n      break;\n\n    // Ctrl-Home -> move to the start of the current block.\n    case 'Ctrl-Home':\n      ctrlr.notify('move').cursor.insAtLeftEnd(ctrlr.root);\n      break;\n\n    // Shift-Home -> select to the start of the current block.\n    case 'Shift-Home':\n      while (cursor[L]) {\n        ctrlr.selectLeft();\n      }\n      break;\n\n    // Ctrl-Shift-Home -> move to the start of the root block.\n    case 'Ctrl-Shift-Home':\n      while (cursor[L] || cursor.parent !== ctrlr.root) {\n        ctrlr.selectLeft();\n      }\n      break;\n\n    case 'Left': ctrlr.moveLeft(); break;\n    case 'Shift-Left': ctrlr.selectLeft(); break;\n    case 'Ctrl-Left': break;\n\n    case 'Right': ctrlr.moveRight(); break;\n    case 'Shift-Right': ctrlr.selectRight(); break;\n    case 'Ctrl-Right': break;\n\n    case 'Up': ctrlr.moveUp(); break;\n    case 'Down': ctrlr.moveDown(); break;\n\n    case 'Shift-Up':\n      if (cursor[L]) {\n        while (cursor[L]) ctrlr.selectLeft();\n      } else {\n        ctrlr.selectLeft();\n      }\n\n    case 'Shift-Down':\n      if (cursor[R]) {\n        while (cursor[R]) ctrlr.selectRight();\n      }\n      else {\n        ctrlr.selectRight();\n      }\n\n    case 'Ctrl-Up': break;\n    case 'Ctrl-Down': break;\n\n    case 'Ctrl-Shift-Del':\n    case 'Ctrl-Del':\n      ctrlr.ctrlDeleteDir(R);\n      break;\n\n    case 'Shift-Del':\n    case 'Del':\n      ctrlr.deleteForward();\n      break;\n\n    case 'Meta-A':\n    case 'Ctrl-A':\n      ctrlr.notify('move').cursor.insAtRightEnd(ctrlr.root);\n      while (cursor[L]) ctrlr.selectLeft();\n      break;\n\n    default:\n      return;\n    }\n    e.preventDefault();\n    ctrlr.scrollHoriz();\n  };\n\n  _.moveOutOf = // called by Controller::escapeDir, moveDir\n  _.moveTowards = // called by Controller::moveDir\n  _.deleteOutOf = // called by Controller::deleteDir\n  _.deleteTowards = // called by Controller::deleteDir\n  _.unselectInto = // called by Controller::selectDir\n  _.selectOutOf = // called by Controller::selectDir\n  _.selectTowards = // called by Controller::selectDir\n    function() { pray('overridden or never called on this node'); };\n});\n\nController.open(function(_) {\n  this.onNotify(function(e) {\n    if (e === 'move' || e === 'upDown') this.show().clearSelection();\n  });\n  _.escapeDir = function(dir, key, e) {\n    prayDirection(dir);\n    var cursor = this.cursor;\n\n    // only prevent default of Tab if not in the root editable\n    if (cursor.parent !== this.root) e.preventDefault();\n\n    // want to be a noop if in the root editable (in fact, Tab has an unrelated\n    // default browser action if so)\n    if (cursor.parent === this.root) return;\n\n    cursor.parent.moveOutOf(dir, cursor);\n    return this.notify('move');\n  };\n\n  optionProcessors.leftRightIntoCmdGoes = function(updown) {\n    if (updown && updown !== 'up' && updown !== 'down') {\n      throw '\"up\" or \"down\" required for leftRightIntoCmdGoes option, '\n            + 'got \"'+updown+'\"';\n    }\n    return updown;\n  };\n  _.moveDir = function(dir) {\n    prayDirection(dir);\n    var cursor = this.cursor, updown = cursor.options.leftRightIntoCmdGoes;\n\n    if (cursor.selection) {\n      cursor.insDirOf(dir, cursor.selection.ends[dir]);\n    }\n    else if (cursor[dir]) cursor[dir].moveTowards(dir, cursor, updown);\n    else cursor.parent.moveOutOf(dir, cursor, updown);\n\n    return this.notify('move');\n  };\n  _.moveLeft = function() { return this.moveDir(L); };\n  _.moveRight = function() { return this.moveDir(R); };\n\n  /**\n   * moveUp and moveDown have almost identical algorithms:\n   * - first check left and right, if so insAtLeft/RightEnd of them\n   * - else check the parent's 'upOutOf'/'downOutOf' property:\n   *   + if it's a function, call it with the cursor as the sole argument and\n   *     use the return value as if it were the value of the property\n   *   + if it's a Node, jump up or down into it:\n   *     - if there is a cached Point in the block, insert there\n   *     - else, seekHoriz within the block to the current x-coordinate (to be\n   *       as close to directly above/below the current position as possible)\n   *   + unless it's exactly `true`, stop bubbling\n   */\n  _.moveUp = function() { return moveUpDown(this, 'up'); };\n  _.moveDown = function() { return moveUpDown(this, 'down'); };\n  function moveUpDown(self, dir) {\n    var cursor = self.notify('upDown').cursor;\n    var dirInto = dir+'Into', dirOutOf = dir+'OutOf';\n    if (cursor[R][dirInto]) cursor.insAtLeftEnd(cursor[R][dirInto]);\n    else if (cursor[L][dirInto]) cursor.insAtRightEnd(cursor[L][dirInto]);\n    else {\n      cursor.parent.bubble(function(ancestor) {\n        var prop = ancestor[dirOutOf];\n        if (prop) {\n          if (typeof prop === 'function') prop = ancestor[dirOutOf](cursor);\n          if (prop instanceof Node) cursor.jumpUpDown(ancestor, prop);\n          if (prop !== true) return false;\n        }\n      });\n    }\n    return self;\n  }\n  this.onNotify(function(e) { if (e !== 'upDown') this.upDownCache = {}; });\n\n  this.onNotify(function(e) { if (e === 'edit') this.show().deleteSelection(); });\n  _.deleteDir = function(dir) {\n    prayDirection(dir);\n    var cursor = this.cursor;\n\n    var hadSelection = cursor.selection;\n    this.notify('edit'); // deletes selection if present\n    if (!hadSelection) {\n      if (cursor[dir]) cursor[dir].deleteTowards(dir, cursor);\n      else cursor.parent.deleteOutOf(dir, cursor);\n    }\n\n    if (cursor[L].siblingDeleted) cursor[L].siblingDeleted(cursor.options, R);\n    if (cursor[R].siblingDeleted) cursor[R].siblingDeleted(cursor.options, L);\n    cursor.parent.bubble('reflow');\n\n    return this;\n  };\n  _.ctrlDeleteDir = function(dir) {\n    prayDirection(dir);\n    var cursor = this.cursor;\n    if (!cursor[L] || cursor.selection) return ctrlr.deleteDir();\n\n    this.notify('edit');\n    Fragment(cursor.parent.ends[L], cursor[L]).remove();\n    cursor.insAtDirEnd(L, cursor.parent);\n\n    if (cursor[L].siblingDeleted) cursor[L].siblingDeleted(cursor.options, R);\n    if (cursor[R].siblingDeleted) cursor[R].siblingDeleted(cursor.options, L);\n    cursor.parent.bubble('reflow');\n\n    return this;\n  };\n  _.backspace = function() { return this.deleteDir(L); };\n  _.deleteForward = function() { return this.deleteDir(R); };\n\n  this.onNotify(function(e) { if (e !== 'select') this.endSelection(); });\n  _.selectDir = function(dir) {\n    var cursor = this.notify('select').cursor, seln = cursor.selection;\n    prayDirection(dir);\n\n    if (!cursor.anticursor) cursor.startSelection();\n\n    var node = cursor[dir];\n    if (node) {\n      // \"if node we're selecting towards is inside selection (hence retracting)\n      // and is on the *far side* of the selection (hence is only node selected)\n      // and the anticursor is *inside* that node, not just on the other side\"\n      if (seln && seln.ends[dir] === node && cursor.anticursor[-dir] !== node) {\n        node.unselectInto(dir, cursor);\n      }\n      else node.selectTowards(dir, cursor);\n    }\n    else cursor.parent.selectOutOf(dir, cursor);\n\n    cursor.clearSelection();\n    cursor.select() || cursor.show();\n  };\n  _.selectLeft = function() { return this.selectDir(L); };\n  _.selectRight = function() { return this.selectDir(R); };\n});\n// Parser MathCommand\nvar latexMathParser = (function() {\n  function commandToBlock(cmd) {\n    var block = MathBlock();\n    cmd.adopt(block, 0, 0);\n    return block;\n  }\n  function joinBlocks(blocks) {\n    var firstBlock = blocks[0] || MathBlock();\n\n    for (var i = 1; i < blocks.length; i += 1) {\n      blocks[i].children().adopt(firstBlock, firstBlock.ends[R], 0);\n    }\n\n    return firstBlock;\n  }\n\n  var string = Parser.string;\n  var regex = Parser.regex;\n  var letter = Parser.letter;\n  var any = Parser.any;\n  var optWhitespace = Parser.optWhitespace;\n  var succeed = Parser.succeed;\n  var fail = Parser.fail;\n\n  // Parsers yielding either MathCommands, or Fragments of MathCommands\n  //   (either way, something that can be adopted by a MathBlock)\n  var variable = letter.map(function(c) { return Letter(c); });\n  var symbol = regex(/^[^${}\\\\_^]/).map(function(c) { return VanillaSymbol(c); });\n\n  var controlSequence =\n    regex(/^[^\\\\a-eg-zA-Z]/) // hotfix #164; match MathBlock::write\n    .or(string('\\\\').then(\n      regex(/^[a-z]+/i)\n      .or(regex(/^\\s+/).result(' '))\n      .or(any)\n    )).then(function(ctrlSeq) {\n      var cmdKlass = LatexCmds[ctrlSeq];\n\n      if (cmdKlass) {\n        return cmdKlass(ctrlSeq).parser();\n      }\n      else {\n        return fail('unknown command: \\\\'+ctrlSeq);\n      }\n    })\n  ;\n\n  var command =\n    controlSequence\n    .or(variable)\n    .or(symbol)\n  ;\n\n  // Parsers yielding MathBlocks\n  var mathGroup = string('{').then(function() { return mathSequence; }).skip(string('}'));\n  var mathBlock = optWhitespace.then(mathGroup.or(command.map(commandToBlock)));\n  var mathSequence = mathBlock.many().map(joinBlocks).skip(optWhitespace);\n\n  var optMathBlock =\n    string('[').then(\n      mathBlock.then(function(block) {\n        return block.join('latex') !== ']' ? succeed(block) : fail();\n      })\n      .many().map(joinBlocks).skip(optWhitespace)\n    ).skip(string(']'))\n  ;\n\n  var latexMath = mathSequence;\n\n  latexMath.block = mathBlock;\n  latexMath.optBlock = optMathBlock;\n  return latexMath;\n})();\n\nController.open(function(_, super_) {\n  _.exportLatex = function() {\n    return this.root.latex().replace(/(\\\\[a-z]+) (?![a-z])/ig,'$1');\n  };\n  _.writeLatex = function(latex) {\n    var cursor = this.notify('edit').cursor;\n\n    var all = Parser.all;\n    var eof = Parser.eof;\n\n    var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);\n\n    if (block && !block.isEmpty()) {\n      block.children().adopt(cursor.parent, cursor[L], cursor[R]);\n      var jQ = block.jQize();\n      jQ.insertBefore(cursor.jQ);\n      cursor[L] = block.ends[R];\n      block.finalizeInsert(cursor.options, cursor);\n      if (block.ends[R][R].siblingCreated) block.ends[R][R].siblingCreated(cursor.options, L);\n      if (block.ends[L][L].siblingCreated) block.ends[L][L].siblingCreated(cursor.options, R);\n      cursor.parent.bubble('reflow');\n    }\n\n    return this;\n  };\n  _.renderLatexMath = function(latex) {\n    var root = this.root, cursor = this.cursor;\n\n    var all = Parser.all;\n    var eof = Parser.eof;\n\n    var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);\n\n    root.eachChild('postOrder', 'dispose');\n    root.ends[L] = root.ends[R] = 0;\n\n    if (block) {\n      block.children().adopt(root, 0, 0);\n    }\n\n    var jQ = root.jQ;\n\n    if (block) {\n      var html = block.join('html');\n      jQ.html(html);\n      root.jQize(jQ.children());\n      root.finalizeInsert(cursor.options);\n    }\n    else {\n      jQ.empty();\n    }\n\n    delete cursor.selection;\n    cursor.insAtRightEnd(root);\n  };\n  _.renderLatexText = function(latex) {\n    var root = this.root, cursor = this.cursor;\n\n    root.jQ.children().slice(1).remove();\n    root.eachChild('postOrder', 'dispose');\n    root.ends[L] = root.ends[R] = 0;\n    delete cursor.selection;\n    cursor.show().insAtRightEnd(root);\n\n    var regex = Parser.regex;\n    var string = Parser.string;\n    var eof = Parser.eof;\n    var all = Parser.all;\n\n    // Parser RootMathCommand\n    var mathMode = string('$').then(latexMathParser)\n      // because TeX is insane, math mode doesn't necessarily\n      // have to end.  So we allow for the case that math mode\n      // continues to the end of the stream.\n      .skip(string('$').or(eof))\n      .map(function(block) {\n        // HACK FIXME: this shouldn't have to have access to cursor\n        var rootMathCommand = RootMathCommand(cursor);\n\n        rootMathCommand.createBlocks();\n        var rootMathBlock = rootMathCommand.ends[L];\n        block.children().adopt(rootMathBlock, 0, 0);\n\n        return rootMathCommand;\n      })\n    ;\n\n    var escapedDollar = string('\\\\$').result('$');\n    var textChar = escapedDollar.or(regex(/^[^$]/)).map(VanillaSymbol);\n    var latexText = mathMode.or(textChar).many();\n    var commands = latexText.skip(eof).or(all.result(false)).parse(latex);\n\n    if (commands) {\n      for (var i = 0; i < commands.length; i += 1) {\n        commands[i].adopt(root, root.ends[R], 0);\n      }\n\n      root.jQize().appendTo(root.jQ);\n\n      root.finalizeInsert(cursor.options);\n    }\n  };\n});\n/********************************************************\n * Deals with mouse events for clicking, drag-to-select\n *******************************************************/\n\nController.open(function(_) {\n  _.delegateMouseEvents = function() {\n    var ultimateRootjQ = this.root.jQ;\n    //drag-to-select event handling\n    this.container.bind('mousedown.mathquill', function(e) {\n      var rootjQ = $(e.target).closest('.mq-root-block');\n      var root = Node.byId[rootjQ.attr(mqBlockId) || ultimateRootjQ.attr(mqBlockId)];\n      var ctrlr = root.controller, cursor = ctrlr.cursor, blink = cursor.blink;\n      var textareaSpan = ctrlr.textareaSpan, textarea = ctrlr.textarea;\n\n      var target;\n      function mousemove(e) { target = $(e.target); }\n      function docmousemove(e) {\n        if (!cursor.anticursor) cursor.startSelection();\n        ctrlr.seek(target, e.pageX, e.pageY).cursor.select();\n        target = undefined;\n      }\n      // outside rootjQ, the MathQuill node corresponding to the target (if any)\n      // won't be inside this root, so don't mislead Controller::seek with it\n\n      function mouseup(e) {\n        cursor.blink = blink;\n        if (!cursor.selection) {\n          if (ctrlr.editable) {\n            cursor.show();\n          }\n          else {\n            textareaSpan.detach();\n          }\n        }\n\n        // delete the mouse handlers now that we're not dragging anymore\n        rootjQ.unbind('mousemove', mousemove);\n        $(e.target.ownerDocument).unbind('mousemove', docmousemove).unbind('mouseup', mouseup);\n      }\n\n      if (ctrlr.blurred) {\n        if (!ctrlr.editable) rootjQ.prepend(textareaSpan);\n        textarea.focus();\n      }\n      e.preventDefault(); // doesn't work in IE\\u22648, but it's a one-line fix:\n      e.target.unselectable = true; // http://jsbin.com/yagekiji/1\n\n      cursor.blink = noop;\n      ctrlr.seek($(e.target), e.pageX, e.pageY).cursor.startSelection();\n\n      rootjQ.mousemove(mousemove);\n      $(e.target.ownerDocument).mousemove(docmousemove).mouseup(mouseup);\n      // listen on document not just body to not only hear about mousemove and\n      // mouseup on page outside field, but even outside page, except iframes: https://github.com/mathquill/mathquill/commit/8c50028afcffcace655d8ae2049f6e02482346c5#commitcomment-6175800\n    });\n  }\n});\n\nController.open(function(_) {\n  _.seek = function(target, pageX, pageY) {\n    var cursor = this.notify('select').cursor;\n\n    if (target) {\n      var nodeId = target.attr(mqBlockId) || target.attr(mqCmdId);\n      if (!nodeId) {\n        var targetParent = target.parent();\n        nodeId = targetParent.attr(mqBlockId) || targetParent.attr(mqCmdId);\n      }\n    }\n    var node = nodeId ? Node.byId[nodeId] : this.root;\n    pray('nodeId is the id of some Node that exists', node);\n\n    // don't clear selection until after getting node from target, in case\n    // target was selection span, otherwise target will have no parent and will\n    // seek from root, which is less accurate (e.g. fraction)\n    cursor.clearSelection().show();\n\n    node.seek(pageX, cursor);\n    this.scrollHoriz(); // before .selectFrom when mouse-selecting, so\n                        // always hits no-selection case in scrollHoriz and scrolls slower\n    return this;\n  };\n});\n/***********************************************\n * Horizontal panning for editable fields that\n * overflow their width\n **********************************************/\n\nController.open(function(_) {\n  _.scrollHoriz = function() {\n    var cursor = this.cursor, seln = cursor.selection;\n    var rootRect = this.root.jQ[0].getBoundingClientRect();\n    if (!seln) {\n      var x = cursor.jQ[0].getBoundingClientRect().left;\n      if (x > rootRect.right - 20) var scrollBy = x - (rootRect.right - 20);\n      else if (x < rootRect.left + 20) var scrollBy = x - (rootRect.left + 20);\n      else return;\n    }\n    else {\n      var rect = seln.jQ[0].getBoundingClientRect();\n      var overLeft = rect.left - (rootRect.left + 20);\n      var overRight = rect.right - (rootRect.right - 20);\n      if (seln.ends[L] === cursor[R]) {\n        if (overLeft < 0) var scrollBy = overLeft;\n        else if (overRight > 0) {\n          if (rect.left - overRight < rootRect.left + 20) var scrollBy = overLeft;\n          else var scrollBy = overRight;\n        }\n        else return;\n      }\n      else {\n        if (overRight > 0) var scrollBy = overRight;\n        else if (overLeft < 0) {\n          if (rect.right - overLeft > rootRect.right - 20) var scrollBy = overRight;\n          else var scrollBy = overLeft;\n        }\n        else return;\n      }\n    }\n    this.root.jQ.stop().animate({ scrollLeft: '+=' + scrollBy}, 100);\n  };\n});\n/*********************************************\n * Manage the MathQuill instance's textarea\n * (as owned by the Controller)\n ********************************************/\n\nController.open(function(_) {\n  Options.p.substituteTextarea = function() {\n    return $('<textarea autocapitalize=off autocomplete=off autocorrect=off ' +\n               'spellcheck=false x-palm-disable-ste-all=true />')[0];\n  };\n  _.createTextarea = function() {\n    var textareaSpan = this.textareaSpan = $('<span class=\"mq-textarea\"></span>'),\n      textarea = this.options.substituteTextarea();\n    if (!textarea.nodeType) {\n      throw 'substituteTextarea() must return a DOM element, got ' + textarea;\n    }\n    textarea = this.textarea = $(textarea).appendTo(textareaSpan);\n\n    var ctrlr = this;\n    ctrlr.cursor.selectionChanged = function() { ctrlr.selectionChanged(); };\n    ctrlr.container.bind('copy', function() { ctrlr.setTextareaSelection(); });\n  };\n  _.selectionChanged = function() {\n    var ctrlr = this;\n    forceIERedraw(ctrlr.container[0]);\n\n    // throttle calls to setTextareaSelection(), because setting textarea.value\n    // and/or calling textarea.select() can have anomalously bad performance:\n    // https://github.com/mathquill/mathquill/issues/43#issuecomment-1399080\n    if (ctrlr.textareaSelectionTimeout === undefined) {\n      ctrlr.textareaSelectionTimeout = setTimeout(function() {\n        ctrlr.setTextareaSelection();\n      });\n    }\n  };\n  _.setTextareaSelection = function() {\n    this.textareaSelectionTimeout = undefined;\n    var latex = '';\n    if (this.cursor.selection) {\n      latex = this.cursor.selection.join('latex');\n      if (this.options.statelessClipboard) {\n        // FIXME: like paste, only this works for math fields; should ask parent\n        latex = '$' + latex + '$';\n      }\n    }\n    this.selectFn(latex);\n  };\n  _.staticMathTextareaEvents = function() {\n    var ctrlr = this, root = ctrlr.root, cursor = ctrlr.cursor,\n      textarea = ctrlr.textarea, textareaSpan = ctrlr.textareaSpan;\n\n    this.container.prepend('<span class=\"mq-selectable\">$'+ctrlr.exportLatex()+'$</span>');\n    ctrlr.blurred = true;\n    textarea.bind('cut paste', false)\n    .focus(function() { ctrlr.blurred = false; }).blur(function() {\n      if (cursor.selection) cursor.selection.clear();\n      setTimeout(detach); //detaching during blur explodes in WebKit\n    });\n    function detach() {\n      textareaSpan.detach();\n      ctrlr.blurred = true;\n    }\n\n    ctrlr.selectFn = function(text) {\n      textarea.val(text);\n      if (text) textarea.select();\n    };\n  };\n  _.editablesTextareaEvents = function() {\n    var ctrlr = this, root = ctrlr.root, cursor = ctrlr.cursor,\n      textarea = ctrlr.textarea, textareaSpan = ctrlr.textareaSpan;\n\n    var keyboardEventsShim = saneKeyboardEvents(textarea, this);\n    this.selectFn = function(text) { keyboardEventsShim.select(text); };\n\n    this.container.prepend(textareaSpan)\n    .on('cut', function(e) {\n      if (cursor.selection) {\n        setTimeout(function() {\n          ctrlr.notify('edit'); // deletes selection if present\n          cursor.parent.bubble('reflow');\n        });\n      }\n    });\n\n    this.focusBlurEvents();\n  };\n  _.typedText = function(ch) {\n    if (ch === '\\n') return this.handle('enter');\n    var cursor = this.notify().cursor;\n    cursor.parent.write(cursor, ch);\n    this.scrollHoriz();\n  };\n  _.paste = function(text) {\n    // TODO: document `statelessClipboard` config option in README, after\n    // making it work like it should, that is, in both text and math mode\n    // (currently only works in math fields, so worse than pointless, it\n    //  only gets in the way by \\text{}-ifying pasted stuff and $-ifying\n    //  cut/copied LaTeX)\n    if (this.options.statelessClipboard) {\n      if (text.slice(0,1) === '$' && text.slice(-1) === '$') {\n        text = text.slice(1, -1);\n      }\n      else {\n        text = '\\\\text{'+text+'}';\n      }\n    }\n    // FIXME: this always inserts math or a TextBlock, even in a RootTextBlock\n    this.writeLatex(text).cursor.show();\n  };\n});\n/*************************************************\n * Abstract classes of math blocks and commands.\n ************************************************/\n\n/**\n * Math tree node base class.\n * Some math-tree-specific extensions to Node.\n * Both MathBlock's and MathCommand's descend from it.\n */\nvar MathElement = P(Node, function(_, super_) {\n  _.finalizeInsert = function(options, cursor) { // `cursor` param is only for\n      // SupSub::contactWeld, and is deliberately only passed in by writeLatex,\n      // see ea7307eb4fac77c149a11ffdf9a831df85247693\n    var self = this;\n    self.postOrder('finalizeTree', options);\n    self.postOrder('contactWeld', cursor);\n\n    // note: this order is important.\n    // empty elements need the empty box provided by blur to\n    // be present in order for their dimensions to be measured\n    // correctly by 'reflow' handlers.\n    self.postOrder('blur');\n\n    self.postOrder('reflow');\n    if (self[R].siblingCreated) self[R].siblingCreated(options, L);\n    if (self[L].siblingCreated) self[L].siblingCreated(options, R);\n    self.bubble('reflow');\n  };\n});\n\n/**\n * Commands and operators, like subscripts, exponents, or fractions.\n * Descendant commands are organized into blocks.\n */\nvar MathCommand = P(MathElement, function(_, super_) {\n  _.init = function(ctrlSeq, htmlTemplate, textTemplate) {\n    var cmd = this;\n    super_.init.call(cmd);\n\n    if (!cmd.ctrlSeq) cmd.ctrlSeq = ctrlSeq;\n    if (htmlTemplate) cmd.htmlTemplate = htmlTemplate;\n    if (textTemplate) cmd.textTemplate = textTemplate;\n  };\n\n  // obvious methods\n  _.replaces = function(replacedFragment) {\n    replacedFragment.disown();\n    this.replacedFragment = replacedFragment;\n  };\n  _.isEmpty = function() {\n    return this.foldChildren(true, function(isEmpty, child) {\n      return isEmpty && child.isEmpty();\n    });\n  };\n\n  _.parser = function() {\n    var block = latexMathParser.block;\n    var self = this;\n\n    return block.times(self.numBlocks()).map(function(blocks) {\n      self.blocks = blocks;\n\n      for (var i = 0; i < blocks.length; i += 1) {\n        blocks[i].adopt(self, self.ends[R], 0);\n      }\n\n      return self;\n    });\n  };\n\n  // createLeftOf(cursor) and the methods it calls\n  _.createLeftOf = function(cursor) {\n    var cmd = this;\n    var replacedFragment = cmd.replacedFragment;\n\n    cmd.createBlocks();\n    super_.createLeftOf.call(cmd, cursor);\n    if (replacedFragment) {\n      replacedFragment.adopt(cmd.ends[L], 0, 0);\n      replacedFragment.jQ.appendTo(cmd.ends[L].jQ);\n    }\n    cmd.finalizeInsert(cursor.options);\n    cmd.placeCursor(cursor);\n  };\n  _.createBlocks = function() {\n    var cmd = this,\n      numBlocks = cmd.numBlocks(),\n      blocks = cmd.blocks = Array(numBlocks);\n\n    for (var i = 0; i < numBlocks; i += 1) {\n      var newBlock = blocks[i] = MathBlock();\n      newBlock.adopt(cmd, cmd.ends[R], 0);\n    }\n  };\n  _.placeCursor = function(cursor) {\n    //insert the cursor at the right end of the first empty child, searching\n    //left-to-right, or if none empty, the right end child\n    cursor.insAtRightEnd(this.foldChildren(this.ends[L], function(leftward, child) {\n      return leftward.isEmpty() ? leftward : child;\n    }));\n  };\n\n  // editability methods: called by the cursor for editing, cursor movements,\n  // and selection of the MathQuill tree, these all take in a direction and\n  // the cursor\n  _.moveTowards = function(dir, cursor, updown) {\n    var updownInto = updown && this[updown+'Into'];\n    cursor.insAtDirEnd(-dir, updownInto || this.ends[-dir]);\n  };\n  _.deleteTowards = function(dir, cursor) {\n    if (this.isEmpty()) cursor[dir] = this.remove()[dir];\n    else this.moveTowards(dir, cursor, null);\n  };\n  _.selectTowards = function(dir, cursor) {\n    cursor[-dir] = this;\n    cursor[dir] = this[dir];\n  };\n  _.selectChildren = function() {\n    return Selection(this, this);\n  };\n  _.unselectInto = function(dir, cursor) {\n    cursor.insAtDirEnd(-dir, cursor.anticursor.ancestors[this.id]);\n  };\n  _.seek = function(pageX, cursor) {\n    function getBounds(node) {\n      var bounds = {}\n      bounds[L] = node.jQ.offset().left;\n      bounds[R] = bounds[L] + node.jQ.outerWidth();\n      return bounds;\n    }\n\n    var cmd = this;\n    var cmdBounds = getBounds(cmd);\n\n    if (pageX < cmdBounds[L]) return cursor.insLeftOf(cmd);\n    if (pageX > cmdBounds[R]) return cursor.insRightOf(cmd);\n\n    var leftLeftBound = cmdBounds[L];\n    cmd.eachChild(function(block) {\n      var blockBounds = getBounds(block);\n      if (pageX < blockBounds[L]) {\n        // closer to this block's left bound, or the bound left of that?\n        if (pageX - leftLeftBound < blockBounds[L] - pageX) {\n          if (block[L]) cursor.insAtRightEnd(block[L]);\n          else cursor.insLeftOf(cmd);\n        }\n        else cursor.insAtLeftEnd(block);\n        return false;\n      }\n      else if (pageX > blockBounds[R]) {\n        if (block[R]) leftLeftBound = blockBounds[R]; // continue to next block\n        else { // last (rightmost) block\n          // closer to this block's right bound, or the cmd's right bound?\n          if (cmdBounds[R] - pageX < pageX - blockBounds[R]) {\n            cursor.insRightOf(cmd);\n          }\n          else cursor.insAtRightEnd(block);\n        }\n      }\n      else {\n        block.seek(pageX, cursor);\n        return false;\n      }\n    });\n  }\n\n  // methods involved in creating and cross-linking with HTML DOM nodes\n  /*\n    They all expect an .htmlTemplate like\n      '<span>&0</span>'\n    or\n      '<span><span>&0</span><span>&1</span></span>'\n\n    See html.test.js for more examples.\n\n    Requirements:\n    - For each block of the command, there must be exactly one \"block content\n      marker\" of the form '&<number>' where <number> is the 0-based index of the\n      block. (Like the LaTeX \\newcommand syntax, but with a 0-based rather than\n      1-based index, because JavaScript because C because Dijkstra.)\n    - The block content marker must be the sole contents of the containing\n      element, there can't even be surrounding whitespace, or else we can't\n      guarantee sticking to within the bounds of the block content marker when\n      mucking with the HTML DOM.\n    - The HTML not only must be well-formed HTML (of course), but also must\n      conform to the XHTML requirements on tags, specifically all tags must\n      either be self-closing (like '<br/>') or come in matching pairs.\n      Close tags are never optional.\n\n    Note that &<number> isn't well-formed HTML; if you wanted a literal '&123',\n    your HTML template would have to have '&amp;123'.\n  */\n  _.numBlocks = function() {\n    var matches = this.htmlTemplate.match(/&\\d+/g);\n    return matches ? matches.length : 0;\n  };\n  _.html = function() {\n    // Render the entire math subtree rooted at this command, as HTML.\n    // Expects .createBlocks() to have been called already, since it uses the\n    // .blocks array of child blocks.\n    //\n    // See html.test.js for example templates and intended outputs.\n    //\n    // Given an .htmlTemplate as described above,\n    // - insert the mathquill-command-id attribute into all top-level tags,\n    //   which will be used to set this.jQ in .jQize().\n    //   This is straightforward:\n    //     * tokenize into tags and non-tags\n    //     * loop through top-level tokens:\n    //         * add #cmdId attribute macro to top-level self-closing tags\n    //         * else add #cmdId attribute macro to top-level open tags\n    //             * skip the matching top-level close tag and all tag pairs\n    //               in between\n    // - for each block content marker,\n    //     + replace it with the contents of the corresponding block,\n    //       rendered as HTML\n    //     + insert the mathquill-block-id attribute into the containing tag\n    //   This is even easier, a quick regex replace, since block tags cannot\n    //   contain anything besides the block content marker.\n    //\n    // Two notes:\n    // - The outermost loop through top-level tokens should never encounter any\n    //   top-level close tags, because we should have first encountered a\n    //   matching top-level open tag, all inner tags should have appeared in\n    //   matching pairs and been skipped, and then we should have skipped the\n    //   close tag in question.\n    // - All open tags should have matching close tags, which means our inner\n    //   loop should always encounter a close tag and drop nesting to 0. If\n    //   a close tag is missing, the loop will continue until i >= tokens.length\n    //   and token becomes undefined. This will not infinite loop, even in\n    //   production without pray(), because it will then TypeError on .slice().\n\n    var cmd = this;\n    var blocks = cmd.blocks;\n    var cmdId = ' mathquill-command-id=' + cmd.id;\n    var tokens = cmd.htmlTemplate.match(/<[^<>]+>|[^<>]+/g);\n\n    pray('no unmatched angle brackets', tokens.join('') === this.htmlTemplate);\n\n    // add cmdId to all top-level tags\n    for (var i = 0, token = tokens[0]; token; i += 1, token = tokens[i]) {\n      // top-level self-closing tags\n      if (token.slice(-2) === '/>') {\n        tokens[i] = token.slice(0,-2) + cmdId + '/>';\n      }\n      // top-level open tags\n      else if (token.charAt(0) === '<') {\n        pray('not an unmatched top-level close tag', token.charAt(1) !== '/');\n\n        tokens[i] = token.slice(0,-1) + cmdId + '>';\n\n        // skip matching top-level close tag and all tag pairs in between\n        var nesting = 1;\n        do {\n          i += 1, token = tokens[i];\n          pray('no missing close tags', token);\n          // close tags\n          if (token.slice(0,2) === '</') {\n            nesting -= 1;\n          }\n          // non-self-closing open tags\n          else if (token.charAt(0) === '<' && token.slice(-2) !== '/>') {\n            nesting += 1;\n          }\n        } while (nesting > 0);\n      }\n    }\n    return tokens.join('').replace(/>&(\\d+)/g, function($0, $1) {\n      return ' mathquill-block-id=' + blocks[$1].id + '>' + blocks[$1].join('html');\n    });\n  };\n\n  // methods to export a string representation of the math tree\n  _.latex = function() {\n    return this.foldChildren(this.ctrlSeq, function(latex, child) {\n      return latex + '{' + (child.latex() || ' ') + '}';\n    });\n  };\n  _.textTemplate = [''];\n  _.text = function() {\n    var cmd = this, i = 0;\n    return cmd.foldChildren(cmd.textTemplate[i], function(text, child) {\n      i += 1;\n      var child_text = child.text();\n      if (text && cmd.textTemplate[i] === '('\n          && child_text[0] === '(' && child_text.slice(-1) === ')')\n        return text + child_text.slice(1, -1) + cmd.textTemplate[i];\n      return text + child.text() + (cmd.textTemplate[i] || '');\n    });\n  };\n});\n\n/**\n * Lightweight command without blocks or children.\n */\nvar Symbol = P(MathCommand, function(_, super_) {\n  _.init = function(ctrlSeq, html, text) {\n    if (!text) text = ctrlSeq && ctrlSeq.length > 1 ? ctrlSeq.slice(1) : ctrlSeq;\n\n    super_.init.call(this, ctrlSeq, html, [ text ]);\n  };\n\n  _.parser = function() { return Parser.succeed(this); };\n  _.numBlocks = function() { return 0; };\n\n  _.replaces = function(replacedFragment) {\n    replacedFragment.remove();\n  };\n  _.createBlocks = noop;\n\n  _.moveTowards = function(dir, cursor) {\n    cursor.jQ.insDirOf(dir, this.jQ);\n    cursor[-dir] = this;\n    cursor[dir] = this[dir];\n  };\n  _.deleteTowards = function(dir, cursor) {\n    cursor[dir] = this.remove()[dir];\n  };\n  _.seek = function(pageX, cursor) {\n    // insert at whichever side the click was closer to\n    if (pageX - this.jQ.offset().left < this.jQ.outerWidth()/2)\n      cursor.insLeftOf(this);\n    else\n      cursor.insRightOf(this);\n  };\n\n  _.latex = function(){ return this.ctrlSeq; };\n  _.text = function(){ return this.textTemplate; };\n  _.placeCursor = noop;\n  _.isEmpty = function(){ return true; };\n});\nvar VanillaSymbol = P(Symbol, function(_, super_) {\n  _.init = function(ch, html) {\n    super_.init.call(this, ch, '<span>'+(html || ch)+'</span>');\n  };\n});\nvar BinaryOperator = P(Symbol, function(_, super_) {\n  _.init = function(ctrlSeq, html, text) {\n    super_.init.call(this,\n      ctrlSeq, '<span class=\"mq-binary-operator\">'+html+'</span>', text\n    );\n  };\n});\n\n/**\n * Children and parent of MathCommand's. Basically partitions all the\n * symbols and operators that descend (in the Math DOM tree) from\n * ancestor operators.\n */\nvar MathBlock = P(MathElement, function(_, super_) {\n  _.join = function(methodName) {\n    return this.foldChildren('', function(fold, child) {\n      return fold + child[methodName]();\n    });\n  };\n  _.html = function() { return this.join('html'); };\n  _.latex = function() { return this.join('latex'); };\n  _.text = function() {\n    return (this.ends[L] === this.ends[R] && this.ends[L] !== 0) ?\n      this.ends[L].text() :\n      this.join('text')\n    ;\n  };\n\n  _.keystroke = function(key, e, ctrlr) {\n    if (ctrlr.options.spaceBehavesLikeTab\n        && (key === 'Spacebar' || key === 'Shift-Spacebar')) {\n      e.preventDefault();\n      ctrlr.escapeDir(key === 'Shift-Spacebar' ? L : R, key, e);\n      return;\n    }\n    return super_.keystroke.apply(this, arguments);\n  };\n\n  // editability methods: called by the cursor for editing, cursor movements,\n  // and selection of the MathQuill tree, these all take in a direction and\n  // the cursor\n  _.moveOutOf = function(dir, cursor, updown) {\n    var updownInto = updown && this.parent[updown+'Into'];\n    if (!updownInto && this[dir]) cursor.insAtDirEnd(-dir, this[dir]);\n    else cursor.insDirOf(dir, this.parent);\n  };\n  _.selectOutOf = function(dir, cursor) {\n    cursor.insDirOf(dir, this.parent);\n  };\n  _.deleteOutOf = function(dir, cursor) {\n    cursor.unwrapGramp();\n  };\n  _.seek = function(pageX, cursor) {\n    var node = this.ends[R];\n    if (!node || node.jQ.offset().left + node.jQ.outerWidth() < pageX) {\n      return cursor.insAtRightEnd(this);\n    }\n    if (pageX < this.ends[L].jQ.offset().left) return cursor.insAtLeftEnd(this);\n    while (pageX < node.jQ.offset().left) node = node[L];\n    return node.seek(pageX, cursor);\n  };\n  _.chToCmd = function(ch) {\n    var cons;\n    // exclude f because it gets a dedicated command with more spacing\n    if (ch.match(/^[a-eg-zA-Z]$/))\n      return Letter(ch);\n    else if (/^\\d$/.test(ch))\n      return Digit(ch);\n    else if (cons = CharCmds[ch] || LatexCmds[ch])\n      return cons(ch);\n    else\n      return VanillaSymbol(ch);\n  };\n  _.write = function(cursor, ch) {\n    var cmd = this.chToCmd(ch);\n    if (cursor.selection) cmd.replaces(cursor.replaceSelection());\n    cmd.createLeftOf(cursor.show());\n  };\n\n  _.focus = function() {\n    this.jQ.addClass('mq-hasCursor');\n    this.jQ.removeClass('mq-empty');\n\n    return this;\n  };\n  _.blur = function() {\n    this.jQ.removeClass('mq-hasCursor');\n    if (this.isEmpty())\n      this.jQ.addClass('mq-empty');\n\n    return this;\n  };\n});\n\nAPI.StaticMath = function(APIClasses) {\n  return P(APIClasses.AbstractMathQuill, function(_, super_) {\n    this.RootBlock = MathBlock;\n    _.__mathquillify = function() {\n      super_.__mathquillify.call(this, 'mq-math-mode');\n      this.__controller.delegateMouseEvents();\n      this.__controller.staticMathTextareaEvents();\n      return this;\n    };\n    _.init = function() {\n      super_.init.apply(this, arguments);\n      this.__controller.root.postOrder(\n        'registerInnerField', this.innerFields = [], APIClasses.MathField);\n    };\n    _.latex = function() {\n      var returned = super_.latex.apply(this, arguments);\n      if (arguments.length > 0) {\n        this.__controller.root.postOrder(\n          'registerInnerField', this.innerFields = [], APIClasses.MathField);\n      }\n      return returned;\n    };\n  });\n};\n\nvar RootMathBlock = P(MathBlock, RootBlockMixin);\nAPI.MathField = function(APIClasses) {\n  return P(APIClasses.EditableField, function(_, super_) {\n    this.RootBlock = RootMathBlock;\n    _.__mathquillify = function(opts, interfaceVersion) {\n      this.config(opts);\n      if (interfaceVersion > 1) this.__controller.root.reflow = noop;\n      super_.__mathquillify.call(this, 'mq-editable-field mq-math-mode');\n      delete this.__controller.root.reflow;\n      return this;\n    };\n  });\n};\n/*************************************************\n * Abstract classes of text blocks\n ************************************************/\n\n/**\n * Blocks of plain text, with one or two TextPiece's as children.\n * Represents flat strings of typically serif-font Roman characters, as\n * opposed to hierchical, nested, tree-structured math.\n * Wraps a single HTMLSpanElement.\n */\nvar TextBlock = P(Node, function(_, super_) {\n  _.ctrlSeq = '\\\\text';\n\n  _.replaces = function(replacedText) {\n    if (replacedText instanceof Fragment)\n      this.replacedText = replacedText.remove().jQ.text();\n    else if (typeof replacedText === 'string')\n      this.replacedText = replacedText;\n  };\n\n  _.jQadd = function(jQ) {\n    super_.jQadd.call(this, jQ);\n    if (this.ends[L]) this.ends[L].jQadd(this.jQ[0].firstChild);\n  };\n\n  _.createLeftOf = function(cursor) {\n    var textBlock = this;\n    super_.createLeftOf.call(this, cursor);\n\n    if (textBlock[R].siblingCreated) textBlock[R].siblingCreated(cursor.options, L);\n    if (textBlock[L].siblingCreated) textBlock[L].siblingCreated(cursor.options, R);\n    textBlock.bubble('reflow');\n\n    cursor.insAtRightEnd(textBlock);\n\n    if (textBlock.replacedText)\n      for (var i = 0; i < textBlock.replacedText.length; i += 1)\n        textBlock.write(cursor, textBlock.replacedText.charAt(i));\n  };\n\n  _.parser = function() {\n    var textBlock = this;\n\n    // TODO: correctly parse text mode\n    var string = Parser.string;\n    var regex = Parser.regex;\n    var optWhitespace = Parser.optWhitespace;\n    return optWhitespace\n      .then(string('{')).then(regex(/^[^}]*/)).skip(string('}'))\n      .map(function(text) {\n        // TODO: is this the correct behavior when parsing\n        // the latex \\text{} ?  This violates the requirement that\n        // the text contents are always nonempty.  Should we just\n        // disown the parent node instead?\n        TextPiece(text).adopt(textBlock, 0, 0);\n        return textBlock;\n      })\n    ;\n  };\n\n  _.textContents = function() {\n    return this.foldChildren('', function(text, child) {\n      return text + child.text;\n    });\n  };\n  _.text = function() { return '\"' + this.textContents() + '\"'; };\n  _.latex = function() { return '\\\\text{' + this.textContents() + '}'; };\n  _.html = function() {\n    return (\n        '<span class=\"mq-text-mode\" mathquill-command-id='+this.id+'>'\n      +   this.textContents()\n      + '</span>'\n    );\n  };\n\n  // editability methods: called by the cursor for editing, cursor movements,\n  // and selection of the MathQuill tree, these all take in a direction and\n  // the cursor\n  _.moveTowards = function(dir, cursor) { cursor.insAtDirEnd(-dir, this); };\n  _.moveOutOf = function(dir, cursor) { cursor.insDirOf(dir, this); };\n  _.unselectInto = _.moveTowards;\n\n  // TODO: make these methods part of a shared mixin or something.\n  _.selectTowards = MathCommand.prototype.selectTowards;\n  _.deleteTowards = MathCommand.prototype.deleteTowards;\n\n  _.selectOutOf = function(dir, cursor) {\n    cursor.insDirOf(dir, this);\n  };\n  _.deleteOutOf = function(dir, cursor) {\n    // backspace and delete at ends of block don't unwrap\n    if (this.isEmpty()) cursor.insRightOf(this);\n  };\n  _.write = function(cursor, ch) {\n    cursor.show().deleteSelection();\n\n    if (ch !== '$') {\n      if (!cursor[L]) TextPiece(ch).createLeftOf(cursor);\n      else cursor[L].appendText(ch);\n    }\n    else if (this.isEmpty()) {\n      cursor.insRightOf(this);\n      VanillaSymbol('\\\\$','$').createLeftOf(cursor);\n    }\n    else if (!cursor[R]) cursor.insRightOf(this);\n    else if (!cursor[L]) cursor.insLeftOf(this);\n    else { // split apart\n      var leftBlock = TextBlock();\n      var leftPc = this.ends[L];\n      leftPc.disown();\n      leftPc.adopt(leftBlock, 0, 0);\n\n      cursor.insLeftOf(this);\n      super_.createLeftOf.call(leftBlock, cursor);\n    }\n  };\n\n  _.seek = function(pageX, cursor) {\n    cursor.hide();\n    var textPc = fuseChildren(this);\n\n    // insert cursor at approx position in DOMTextNode\n    var avgChWidth = this.jQ.width()/this.text.length;\n    var approxPosition = Math.round((pageX - this.jQ.offset().left)/avgChWidth);\n    if (approxPosition <= 0) cursor.insAtLeftEnd(this);\n    else if (approxPosition >= textPc.text.length) cursor.insAtRightEnd(this);\n    else cursor.insLeftOf(textPc.splitRight(approxPosition));\n\n    // move towards mousedown (pageX)\n    var displ = pageX - cursor.show().offset().left; // displacement\n    var dir = displ && displ < 0 ? L : R;\n    var prevDispl = dir;\n    // displ * prevDispl > 0 iff displacement direction === previous direction\n    while (cursor[dir] && displ * prevDispl > 0) {\n      cursor[dir].moveTowards(dir, cursor);\n      prevDispl = displ;\n      displ = pageX - cursor.offset().left;\n    }\n    if (dir*displ < -dir*prevDispl) cursor[-dir].moveTowards(-dir, cursor);\n\n    if (!cursor.anticursor) {\n      // about to start mouse-selecting, the anticursor is gonna get put here\n      this.anticursorPosition = cursor[L] && cursor[L].text.length;\n      // ^ get it? 'cos if there's no cursor[L], it's 0... I'm a terrible person.\n    }\n    else if (cursor.anticursor.parent === this) {\n      // mouse-selecting within this TextBlock, re-insert the anticursor\n      var cursorPosition = cursor[L] && cursor[L].text.length;;\n      if (this.anticursorPosition === cursorPosition) {\n        cursor.anticursor = Point.copy(cursor);\n      }\n      else {\n        if (this.anticursorPosition < cursorPosition) {\n          var newTextPc = cursor[L].splitRight(this.anticursorPosition);\n          cursor[L] = newTextPc;\n        }\n        else {\n          var newTextPc = cursor[R].splitRight(this.anticursorPosition - cursorPosition);\n        }\n        cursor.anticursor = Point(this, newTextPc[L], newTextPc);\n      }\n    }\n  };\n\n  _.blur = function() {\n    MathBlock.prototype.blur.call(this);\n    fuseChildren(this);\n  };\n\n  function fuseChildren(self) {\n    self.jQ[0].normalize();\n\n    var textPcDom = self.jQ[0].firstChild;\n    pray('only node in TextBlock span is Text node', textPcDom.nodeType === 3);\n    // nodeType === 3 has meant a Text node since ancient times:\n    //   http://reference.sitepoint.com/javascript/Node/nodeType\n\n    var textPc = TextPiece(textPcDom.data);\n    textPc.jQadd(textPcDom);\n\n    self.children().disown();\n    return textPc.adopt(self, 0, 0);\n  }\n\n  _.focus = MathBlock.prototype.focus;\n});\n\n/**\n * Piece of plain text, with a TextBlock as a parent and no children.\n * Wraps a single DOMTextNode.\n * For convenience, has a .text property that's just a JavaScript string\n * mirroring the text contents of the DOMTextNode.\n * Text contents must always be nonempty.\n */\nvar TextPiece = P(Node, function(_, super_) {\n  _.init = function(text) {\n    super_.init.call(this);\n    this.text = text;\n  };\n  _.jQadd = function(dom) { this.dom = dom; this.jQ = $(dom); };\n  _.jQize = function() {\n    return this.jQadd(document.createTextNode(this.text));\n  };\n  _.appendText = function(text) {\n    this.text += text;\n    this.dom.appendData(text);\n  };\n  _.prependText = function(text) {\n    this.text = text + this.text;\n    this.dom.insertData(0, text);\n  };\n  _.insTextAtDirEnd = function(text, dir) {\n    prayDirection(dir);\n    if (dir === R) this.appendText(text);\n    else this.prependText(text);\n  };\n  _.splitRight = function(i) {\n    var newPc = TextPiece(this.text.slice(i)).adopt(this.parent, this, this[R]);\n    newPc.jQadd(this.dom.splitText(i));\n    this.text = this.text.slice(0, i);\n    return newPc;\n  };\n\n  function endChar(dir, text) {\n    return text.charAt(dir === L ? 0 : -1 + text.length);\n  }\n\n  _.moveTowards = function(dir, cursor) {\n    prayDirection(dir);\n\n    var ch = endChar(-dir, this.text)\n\n    var from = this[-dir];\n    if (from) from.insTextAtDirEnd(ch, dir);\n    else TextPiece(ch).createDir(-dir, cursor);\n\n    return this.deleteTowards(dir, cursor);\n  };\n\n  _.latex = function() { return this.text; };\n\n  _.deleteTowards = function(dir, cursor) {\n    if (this.text.length > 1) {\n      if (dir === R) {\n        this.dom.deleteData(0, 1);\n        this.text = this.text.slice(1);\n      }\n      else {\n        // note that the order of these 2 lines is annoyingly important\n        // (the second line mutates this.text.length)\n        this.dom.deleteData(-1 + this.text.length, 1);\n        this.text = this.text.slice(0, -1);\n      }\n    }\n    else {\n      this.remove();\n      this.jQ.remove();\n      cursor[dir] = this[dir];\n    }\n  };\n\n  _.selectTowards = function(dir, cursor) {\n    prayDirection(dir);\n    var anticursor = cursor.anticursor;\n\n    var ch = endChar(-dir, this.text)\n\n    if (anticursor[dir] === this) {\n      var newPc = TextPiece(ch).createDir(dir, cursor);\n      anticursor[dir] = newPc;\n      cursor.insDirOf(dir, newPc);\n    }\n    else {\n      var from = this[-dir];\n      if (from) from.insTextAtDirEnd(ch, dir);\n      else {\n        var newPc = TextPiece(ch).createDir(-dir, cursor);\n        newPc.jQ.insDirOf(-dir, cursor.selection.jQ);\n      }\n\n      if (this.text.length === 1 && anticursor[-dir] === this) {\n        anticursor[-dir] = this[-dir]; // `this` will be removed in deleteTowards\n      }\n    }\n\n    return this.deleteTowards(dir, cursor);\n  };\n});\n\nCharCmds.$ =\nLatexCmds.text =\nLatexCmds.textnormal =\nLatexCmds.textrm =\nLatexCmds.textup =\nLatexCmds.textmd = TextBlock;\n\nfunction makeTextBlock(latex, tagName, attrs) {\n  return P(TextBlock, {\n    ctrlSeq: latex,\n    htmlTemplate: '<'+tagName+' '+attrs+'>&0</'+tagName+'>'\n  });\n}\n\nLatexCmds.em = LatexCmds.italic = LatexCmds.italics =\nLatexCmds.emph = LatexCmds.textit = LatexCmds.textsl =\n  makeTextBlock('\\\\textit', 'i', 'class=\"mq-text-mode\"');\nLatexCmds.strong = LatexCmds.bold = LatexCmds.textbf =\n  makeTextBlock('\\\\textbf', 'b', 'class=\"mq-text-mode\"');\nLatexCmds.sf = LatexCmds.textsf =\n  makeTextBlock('\\\\textsf', 'span', 'class=\"mq-sans-serif mq-text-mode\"');\nLatexCmds.tt = LatexCmds.texttt =\n  makeTextBlock('\\\\texttt', 'span', 'class=\"mq-monospace mq-text-mode\"');\nLatexCmds.textsc =\n  makeTextBlock('\\\\textsc', 'span', 'style=\"font-variant:small-caps\" class=\"mq-text-mode\"');\nLatexCmds.uppercase =\n  makeTextBlock('\\\\uppercase', 'span', 'style=\"text-transform:uppercase\" class=\"mq-text-mode\"');\nLatexCmds.lowercase =\n  makeTextBlock('\\\\lowercase', 'span', 'style=\"text-transform:lowercase\" class=\"mq-text-mode\"');\n\n\nvar RootMathCommand = P(MathCommand, function(_, super_) {\n  _.init = function(cursor) {\n    super_.init.call(this, '$');\n    this.cursor = cursor;\n  };\n  _.htmlTemplate = '<span class=\"mq-math-mode\">&0</span>';\n  _.createBlocks = function() {\n    super_.createBlocks.call(this);\n\n    this.ends[L].cursor = this.cursor;\n    this.ends[L].write = function(cursor, ch) {\n      if (ch !== '$')\n        MathBlock.prototype.write.call(this, cursor, ch);\n      else if (this.isEmpty()) {\n        cursor.insRightOf(this.parent);\n        this.parent.deleteTowards(dir, cursor);\n        VanillaSymbol('\\\\$','$').createLeftOf(cursor.show());\n      }\n      else if (!cursor[R])\n        cursor.insRightOf(this.parent);\n      else if (!cursor[L])\n        cursor.insLeftOf(this.parent);\n      else\n        MathBlock.prototype.write.call(this, cursor, ch);\n    };\n  };\n  _.latex = function() {\n    return '$' + this.ends[L].latex() + '$';\n  };\n});\n\nvar RootTextBlock = P(RootMathBlock, function(_, super_) {\n  _.keystroke = function(key) {\n    if (key === 'Spacebar' || key === 'Shift-Spacebar') return;\n    return super_.keystroke.apply(this, arguments);\n  };\n  _.write = function(cursor, ch) {\n    cursor.show().deleteSelection();\n    if (ch === '$')\n      RootMathCommand(cursor).createLeftOf(cursor);\n    else {\n      var html;\n      if (ch === '<') html = '&lt;';\n      else if (ch === '>') html = '&gt;';\n      VanillaSymbol(ch, html).createLeftOf(cursor);\n    }\n  };\n});\nAPI.TextField = function(APIClasses) {\n  return P(APIClasses.EditableField, function(_, super_) {\n    this.RootBlock = RootTextBlock;\n    _.__mathquillify = function() {\n      return super_.__mathquillify.call(this, 'mq-editable-field mq-text-mode');\n    };\n    _.latex = function(latex) {\n      if (arguments.length > 0) {\n        this.__controller.renderLatexText(latex);\n        if (this.__controller.blurred) this.__controller.cursor.hide().parent.blur();\n        return this;\n      }\n      return this.__controller.exportLatex();\n    };\n  });\n};\n/****************************************\n * Input box to type backslash commands\n ***************************************/\n\nvar LatexCommandInput =\nCharCmds['\\\\'] = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '\\\\';\n  _.replaces = function(replacedFragment) {\n    this._replacedFragment = replacedFragment.disown();\n    this.isEmpty = function() { return false; };\n  };\n  _.htmlTemplate = '<span class=\"mq-latex-command-input mq-non-leaf\">\\\\<span>&0</span></span>';\n  _.textTemplate = ['\\\\'];\n  _.createBlocks = function() {\n    super_.createBlocks.call(this);\n    this.ends[L].focus = function() {\n      this.parent.jQ.addClass('mq-hasCursor');\n      if (this.isEmpty())\n        this.parent.jQ.removeClass('mq-empty');\n\n      return this;\n    };\n    this.ends[L].blur = function() {\n      this.parent.jQ.removeClass('mq-hasCursor');\n      if (this.isEmpty())\n        this.parent.jQ.addClass('mq-empty');\n\n      return this;\n    };\n    this.ends[L].write = function(cursor, ch) {\n      cursor.show().deleteSelection();\n\n      if (ch.match(/[a-z]/i)) VanillaSymbol(ch).createLeftOf(cursor);\n      else {\n        this.parent.renderCommand(cursor);\n        if (ch !== '\\\\' || !this.isEmpty()) this.parent.parent.write(cursor, ch);\n      }\n    };\n    this.ends[L].keystroke = function(key, e, ctrlr) {\n      if (key === 'Tab' || key === 'Enter' || key === 'Spacebar') {\n        this.parent.renderCommand(ctrlr.cursor);\n        e.preventDefault();\n        return;\n      }\n      return super_.keystroke.apply(this, arguments);\n    };\n  };\n  _.createLeftOf = function(cursor) {\n    super_.createLeftOf.call(this, cursor);\n\n    if (this._replacedFragment) {\n      var el = this.jQ[0];\n      this.jQ =\n        this._replacedFragment.jQ.addClass('mq-blur').bind(\n          'mousedown mousemove', //FIXME: is monkey-patching the mousedown and mousemove handlers the right way to do this?\n          function(e) {\n            $(e.target = el).trigger(e);\n            return false;\n          }\n        ).insertBefore(this.jQ).add(this.jQ);\n    }\n  };\n  _.latex = function() {\n    return '\\\\' + this.ends[L].latex() + ' ';\n  };\n  _.renderCommand = function(cursor) {\n    this.jQ = this.jQ.last();\n    this.remove();\n    if (this[R]) {\n      cursor.insLeftOf(this[R]);\n    } else {\n      cursor.insAtRightEnd(this.parent);\n    }\n\n    var latex = this.ends[L].latex();\n    if (!latex) latex = ' ';\n    var cmd = LatexCmds[latex];\n    if (cmd) {\n      cmd = cmd(latex);\n      if (this._replacedFragment) cmd.replaces(this._replacedFragment);\n      cmd.createLeftOf(cursor);\n    }\n    else {\n      cmd = TextBlock();\n      cmd.replaces(latex);\n      cmd.createLeftOf(cursor);\n      cursor.insRightOf(cmd);\n      if (this._replacedFragment)\n        this._replacedFragment.remove();\n    }\n  };\n});\n\n/************************************\n * Symbols for Advanced Mathematics\n ***********************************/\n\nLatexCmds.notin =\nLatexCmds.cong =\nLatexCmds.equiv =\nLatexCmds.oplus =\nLatexCmds.otimes = P(BinaryOperator, function(_, super_) {\n  _.init = function(latex) {\n    super_.init.call(this, '\\\\'+latex+' ', '&'+latex+';');\n  };\n});\n\nLatexCmds['\\u2260'] = LatexCmds.ne = LatexCmds.neq = bind(BinaryOperator,'\\\\ne ','&ne;');\n\nLatexCmds.ast = LatexCmds.star = LatexCmds.loast = LatexCmds.lowast =\n  bind(BinaryOperator,'\\\\ast ','&lowast;');\n  //case 'there4 = // a special exception for this one, perhaps?\nLatexCmds.therefor = LatexCmds.therefore =\n  bind(BinaryOperator,'\\\\therefore ','&there4;');\n\nLatexCmds.cuz = // l33t\nLatexCmds.because = bind(BinaryOperator,'\\\\because ','&#8757;');\n\nLatexCmds.prop = LatexCmds.propto = bind(BinaryOperator,'\\\\propto ','&prop;');\n\nLatexCmds['\\u2248'] = LatexCmds.asymp = LatexCmds.approx = bind(BinaryOperator,'\\\\approx ','&asymp;');\n\nLatexCmds.isin = LatexCmds['in'] = bind(BinaryOperator,'\\\\in ','&isin;');\n\nLatexCmds.ni = LatexCmds.contains = bind(BinaryOperator,'\\\\ni ','&ni;');\n\nLatexCmds.notni = LatexCmds.niton = LatexCmds.notcontains = LatexCmds.doesnotcontain =\n  bind(BinaryOperator,'\\\\not\\\\ni ','&#8716;');\n\nLatexCmds.sub = LatexCmds.subset = bind(BinaryOperator,'\\\\subset ','&sub;');\n\nLatexCmds.sup = LatexCmds.supset = LatexCmds.superset =\n  bind(BinaryOperator,'\\\\supset ','&sup;');\n\nLatexCmds.nsub = LatexCmds.notsub =\nLatexCmds.nsubset = LatexCmds.notsubset =\n  bind(BinaryOperator,'\\\\not\\\\subset ','&#8836;');\n\nLatexCmds.nsup = LatexCmds.notsup =\nLatexCmds.nsupset = LatexCmds.notsupset =\nLatexCmds.nsuperset = LatexCmds.notsuperset =\n  bind(BinaryOperator,'\\\\not\\\\supset ','&#8837;');\n\nLatexCmds.sube = LatexCmds.subeq = LatexCmds.subsete = LatexCmds.subseteq =\n  bind(BinaryOperator,'\\\\subseteq ','&sube;');\n\nLatexCmds.supe = LatexCmds.supeq =\nLatexCmds.supsete = LatexCmds.supseteq =\nLatexCmds.supersete = LatexCmds.superseteq =\n  bind(BinaryOperator,'\\\\supseteq ','&supe;');\n\nLatexCmds.nsube = LatexCmds.nsubeq =\nLatexCmds.notsube = LatexCmds.notsubeq =\nLatexCmds.nsubsete = LatexCmds.nsubseteq =\nLatexCmds.notsubsete = LatexCmds.notsubseteq =\n  bind(BinaryOperator,'\\\\not\\\\subseteq ','&#8840;');\n\nLatexCmds.nsupe = LatexCmds.nsupeq =\nLatexCmds.notsupe = LatexCmds.notsupeq =\nLatexCmds.nsupsete = LatexCmds.nsupseteq =\nLatexCmds.notsupsete = LatexCmds.notsupseteq =\nLatexCmds.nsupersete = LatexCmds.nsuperseteq =\nLatexCmds.notsupersete = LatexCmds.notsuperseteq =\n  bind(BinaryOperator,'\\\\not\\\\supseteq ','&#8841;');\n\n\n//the canonical sets of numbers\nLatexCmds.N = LatexCmds.naturals = LatexCmds.Naturals =\n  bind(VanillaSymbol,'\\\\mathbb{N}','&#8469;');\n\nLatexCmds.P =\nLatexCmds.primes = LatexCmds.Primes =\nLatexCmds.projective = LatexCmds.Projective =\nLatexCmds.probability = LatexCmds.Probability =\n  bind(VanillaSymbol,'\\\\mathbb{P}','&#8473;');\n\nLatexCmds.Z = LatexCmds.integers = LatexCmds.Integers =\n  bind(VanillaSymbol,'\\\\mathbb{Z}','&#8484;');\n\nLatexCmds.Q = LatexCmds.rationals = LatexCmds.Rationals =\n  bind(VanillaSymbol,'\\\\mathbb{Q}','&#8474;');\n\nLatexCmds.R = LatexCmds.reals = LatexCmds.Reals =\n  bind(VanillaSymbol,'\\\\mathbb{R}','&#8477;');\n\nLatexCmds.C =\nLatexCmds.complex = LatexCmds.Complex =\nLatexCmds.complexes = LatexCmds.Complexes =\nLatexCmds.complexplane = LatexCmds.Complexplane = LatexCmds.ComplexPlane =\n  bind(VanillaSymbol,'\\\\mathbb{C}','&#8450;');\n\nLatexCmds.H = LatexCmds.Hamiltonian = LatexCmds.quaternions = LatexCmds.Quaternions =\n  bind(VanillaSymbol,'\\\\mathbb{H}','&#8461;');\n\n//spacing\nLatexCmds.quad = LatexCmds.emsp = bind(VanillaSymbol,'\\\\quad ','    ');\nLatexCmds.qquad = bind(VanillaSymbol,'\\\\qquad ','        ');\n/* spacing special characters, gonna have to implement this in LatexCommandInput::onText somehow\ncase ',':\n  return VanillaSymbol('\\\\, ',' ');\ncase ':':\n  return VanillaSymbol('\\\\: ','  ');\ncase ';':\n  return VanillaSymbol('\\\\; ','   ');\ncase '!':\n  return Symbol('\\\\! ','<span style=\"margin-right:-.2em\"></span>');\n*/\n\n//binary operators\nLatexCmds.diamond = bind(VanillaSymbol, '\\\\diamond ', '&#9671;');\nLatexCmds.bigtriangleup = bind(VanillaSymbol, '\\\\bigtriangleup ', '&#9651;');\nLatexCmds.ominus = bind(VanillaSymbol, '\\\\ominus ', '&#8854;');\nLatexCmds.uplus = bind(VanillaSymbol, '\\\\uplus ', '&#8846;');\nLatexCmds.bigtriangledown = bind(VanillaSymbol, '\\\\bigtriangledown ', '&#9661;');\nLatexCmds.sqcap = bind(VanillaSymbol, '\\\\sqcap ', '&#8851;');\nLatexCmds.triangleleft = bind(VanillaSymbol, '\\\\triangleleft ', '&#8882;');\nLatexCmds.sqcup = bind(VanillaSymbol, '\\\\sqcup ', '&#8852;');\nLatexCmds.triangleright = bind(VanillaSymbol, '\\\\triangleright ', '&#8883;');\n//circledot is not a not real LaTex command see https://github.com/mathquill/mathquill/pull/552 for more details\nLatexCmds.odot = LatexCmds.circledot = bind(VanillaSymbol, '\\\\odot ', '&#8857;');\nLatexCmds.bigcirc = bind(VanillaSymbol, '\\\\bigcirc ', '&#9711;');\nLatexCmds.dagger = bind(VanillaSymbol, '\\\\dagger ', '&#0134;');\nLatexCmds.ddagger = bind(VanillaSymbol, '\\\\ddagger ', '&#135;');\nLatexCmds.wr = bind(VanillaSymbol, '\\\\wr ', '&#8768;');\nLatexCmds.amalg = bind(VanillaSymbol, '\\\\amalg ', '&#8720;');\n\n//relationship symbols\nLatexCmds.models = bind(VanillaSymbol, '\\\\models ', '&#8872;');\nLatexCmds.prec = bind(VanillaSymbol, '\\\\prec ', '&#8826;');\nLatexCmds.succ = bind(VanillaSymbol, '\\\\succ ', '&#8827;');\nLatexCmds.preceq = bind(VanillaSymbol, '\\\\preceq ', '&#8828;');\nLatexCmds.succeq = bind(VanillaSymbol, '\\\\succeq ', '&#8829;');\nLatexCmds.simeq = bind(VanillaSymbol, '\\\\simeq ', '&#8771;');\nLatexCmds.mid = bind(VanillaSymbol, '\\\\mid ', '&#8739;');\nLatexCmds.ll = bind(VanillaSymbol, '\\\\ll ', '&#8810;');\nLatexCmds.gg = bind(VanillaSymbol, '\\\\gg ', '&#8811;');\nLatexCmds.parallel = bind(VanillaSymbol, '\\\\parallel ', '&#8741;');\nLatexCmds.nparallel = bind(VanillaSymbol, '\\\\nparallel ', '&#8742;');\nLatexCmds.bowtie = bind(VanillaSymbol, '\\\\bowtie ', '&#8904;');\nLatexCmds.sqsubset = bind(VanillaSymbol, '\\\\sqsubset ', '&#8847;');\nLatexCmds.sqsupset = bind(VanillaSymbol, '\\\\sqsupset ', '&#8848;');\nLatexCmds.smile = bind(VanillaSymbol, '\\\\smile ', '&#8995;');\nLatexCmds.sqsubseteq = bind(VanillaSymbol, '\\\\sqsubseteq ', '&#8849;');\nLatexCmds.sqsupseteq = bind(VanillaSymbol, '\\\\sqsupseteq ', '&#8850;');\nLatexCmds.doteq = bind(VanillaSymbol, '\\\\doteq ', '&#8784;');\nLatexCmds.frown = bind(VanillaSymbol, '\\\\frown ', '&#8994;');\nLatexCmds.vdash = bind(VanillaSymbol, '\\\\vdash ', '&#8870;');\nLatexCmds.dashv = bind(VanillaSymbol, '\\\\dashv ', '&#8867;');\nLatexCmds.nless = bind(VanillaSymbol, '\\\\nless ', '&#8814;');\nLatexCmds.ngtr = bind(VanillaSymbol, '\\\\ngtr ', '&#8815;');\n\n//arrows\nLatexCmds.longleftarrow = bind(VanillaSymbol, '\\\\longleftarrow ', '&#8592;');\nLatexCmds.longrightarrow = bind(VanillaSymbol, '\\\\longrightarrow ', '&#8594;');\nLatexCmds.Longleftarrow = bind(VanillaSymbol, '\\\\Longleftarrow ', '&#8656;');\nLatexCmds.Longrightarrow = bind(VanillaSymbol, '\\\\Longrightarrow ', '&#8658;');\nLatexCmds.longleftrightarrow = bind(VanillaSymbol, '\\\\longleftrightarrow ', '&#8596;');\nLatexCmds.updownarrow = bind(VanillaSymbol, '\\\\updownarrow ', '&#8597;');\nLatexCmds.Longleftrightarrow = bind(VanillaSymbol, '\\\\Longleftrightarrow ', '&#8660;');\nLatexCmds.Updownarrow = bind(VanillaSymbol, '\\\\Updownarrow ', '&#8661;');\nLatexCmds.mapsto = bind(VanillaSymbol, '\\\\mapsto ', '&#8614;');\nLatexCmds.nearrow = bind(VanillaSymbol, '\\\\nearrow ', '&#8599;');\nLatexCmds.hookleftarrow = bind(VanillaSymbol, '\\\\hookleftarrow ', '&#8617;');\nLatexCmds.hookrightarrow = bind(VanillaSymbol, '\\\\hookrightarrow ', '&#8618;');\nLatexCmds.searrow = bind(VanillaSymbol, '\\\\searrow ', '&#8600;');\nLatexCmds.leftharpoonup = bind(VanillaSymbol, '\\\\leftharpoonup ', '&#8636;');\nLatexCmds.rightharpoonup = bind(VanillaSymbol, '\\\\rightharpoonup ', '&#8640;');\nLatexCmds.swarrow = bind(VanillaSymbol, '\\\\swarrow ', '&#8601;');\nLatexCmds.leftharpoondown = bind(VanillaSymbol, '\\\\leftharpoondown ', '&#8637;');\nLatexCmds.rightharpoondown = bind(VanillaSymbol, '\\\\rightharpoondown ', '&#8641;');\nLatexCmds.nwarrow = bind(VanillaSymbol, '\\\\nwarrow ', '&#8598;');\n\n//Misc\nLatexCmds.ldots = bind(VanillaSymbol, '\\\\ldots ', '&#8230;');\nLatexCmds.cdots = bind(VanillaSymbol, '\\\\cdots ', '&#8943;');\nLatexCmds.vdots = bind(VanillaSymbol, '\\\\vdots ', '&#8942;');\nLatexCmds.ddots = bind(VanillaSymbol, '\\\\ddots ', '&#8945;');\nLatexCmds.surd = bind(VanillaSymbol, '\\\\surd ', '&#8730;');\nLatexCmds.triangle = bind(VanillaSymbol, '\\\\triangle ', '&#9651;');\nLatexCmds.ell = bind(VanillaSymbol, '\\\\ell ', '&#8467;');\nLatexCmds.top = bind(VanillaSymbol, '\\\\top ', '&#8868;');\nLatexCmds.flat = bind(VanillaSymbol, '\\\\flat ', '&#9837;');\nLatexCmds.natural = bind(VanillaSymbol, '\\\\natural ', '&#9838;');\nLatexCmds.sharp = bind(VanillaSymbol, '\\\\sharp ', '&#9839;');\nLatexCmds.wp = bind(VanillaSymbol, '\\\\wp ', '&#8472;');\nLatexCmds.bot = bind(VanillaSymbol, '\\\\bot ', '&#8869;');\nLatexCmds.clubsuit = bind(VanillaSymbol, '\\\\clubsuit ', '&#9827;');\nLatexCmds.diamondsuit = bind(VanillaSymbol, '\\\\diamondsuit ', '&#9826;');\nLatexCmds.heartsuit = bind(VanillaSymbol, '\\\\heartsuit ', '&#9825;');\nLatexCmds.spadesuit = bind(VanillaSymbol, '\\\\spadesuit ', '&#9824;');\n//not real LaTex command see https://github.com/mathquill/mathquill/pull/552 for more details\nLatexCmds.parallelogram = bind(VanillaSymbol, '\\\\parallelogram ', '&#9649;');\nLatexCmds.square = bind(VanillaSymbol, '\\\\square ', '&#11036;');\n\n//variable-sized\nLatexCmds.oint = bind(VanillaSymbol, '\\\\oint ', '&#8750;');\nLatexCmds.bigcap = bind(VanillaSymbol, '\\\\bigcap ', '&#8745;');\nLatexCmds.bigcup = bind(VanillaSymbol, '\\\\bigcup ', '&#8746;');\nLatexCmds.bigsqcup = bind(VanillaSymbol, '\\\\bigsqcup ', '&#8852;');\nLatexCmds.bigvee = bind(VanillaSymbol, '\\\\bigvee ', '&#8744;');\nLatexCmds.bigwedge = bind(VanillaSymbol, '\\\\bigwedge ', '&#8743;');\nLatexCmds.bigodot = bind(VanillaSymbol, '\\\\bigodot ', '&#8857;');\nLatexCmds.bigotimes = bind(VanillaSymbol, '\\\\bigotimes ', '&#8855;');\nLatexCmds.bigoplus = bind(VanillaSymbol, '\\\\bigoplus ', '&#8853;');\nLatexCmds.biguplus = bind(VanillaSymbol, '\\\\biguplus ', '&#8846;');\n\n//delimiters\nLatexCmds.lfloor = bind(VanillaSymbol, '\\\\lfloor ', '&#8970;');\nLatexCmds.rfloor = bind(VanillaSymbol, '\\\\rfloor ', '&#8971;');\nLatexCmds.lceil = bind(VanillaSymbol, '\\\\lceil ', '&#8968;');\nLatexCmds.rceil = bind(VanillaSymbol, '\\\\rceil ', '&#8969;');\nLatexCmds.opencurlybrace = LatexCmds.lbrace = bind(VanillaSymbol, '\\\\lbrace ', '{');\nLatexCmds.closecurlybrace = LatexCmds.rbrace = bind(VanillaSymbol, '\\\\rbrace ', '}');\nLatexCmds.lbrack = bind(VanillaSymbol, '[');\nLatexCmds.rbrack = bind(VanillaSymbol, ']');\n\n//various symbols\nLatexCmds['\\u222b'] =\nLatexCmds['int'] =\nLatexCmds.integral = bind(Symbol,'\\\\int ','<big>&int;</big>');\n\nLatexCmds.slash = bind(VanillaSymbol, '/');\nLatexCmds.vert = bind(VanillaSymbol,'|');\nLatexCmds.perp = LatexCmds.perpendicular = bind(VanillaSymbol,'\\\\perp ','&perp;');\nLatexCmds.nabla = LatexCmds.del = bind(VanillaSymbol,'\\\\nabla ','&nabla;');\nLatexCmds.hbar = bind(VanillaSymbol,'\\\\hbar ','&#8463;');\n\nLatexCmds.AA = LatexCmds.Angstrom = LatexCmds.angstrom =\n  bind(VanillaSymbol,'\\\\text\\\\AA ','&#8491;');\n\nLatexCmds.ring = LatexCmds.circ = LatexCmds.circle =\n  bind(VanillaSymbol,'\\\\circ ','&#8728;');\n\nLatexCmds.bull = LatexCmds.bullet = bind(VanillaSymbol,'\\\\bullet ','&bull;');\n\nLatexCmds.setminus = LatexCmds.smallsetminus =\n  bind(VanillaSymbol,'\\\\setminus ','&#8726;');\n\nLatexCmds.not = //bind(Symbol,'\\\\not ','<span class=\"not\">/</span>');\nLatexCmds['\\u00ac'] = LatexCmds.neg = bind(VanillaSymbol,'\\\\neg ','&not;');\n\nLatexCmds['\\u2026'] = LatexCmds.dots = LatexCmds.ellip = LatexCmds.hellip =\nLatexCmds.ellipsis = LatexCmds.hellipsis =\n  bind(VanillaSymbol,'\\\\dots ','&hellip;');\n\nLatexCmds.converges =\nLatexCmds.darr = LatexCmds.dnarr = LatexCmds.dnarrow = LatexCmds.downarrow =\n  bind(VanillaSymbol,'\\\\downarrow ','&darr;');\n\nLatexCmds.dArr = LatexCmds.dnArr = LatexCmds.dnArrow = LatexCmds.Downarrow =\n  bind(VanillaSymbol,'\\\\Downarrow ','&dArr;');\n\nLatexCmds.diverges = LatexCmds.uarr = LatexCmds.uparrow =\n  bind(VanillaSymbol,'\\\\uparrow ','&uarr;');\n\nLatexCmds.uArr = LatexCmds.Uparrow = bind(VanillaSymbol,'\\\\Uparrow ','&uArr;');\n\nLatexCmds.to = bind(BinaryOperator,'\\\\to ','&rarr;');\n\nLatexCmds.rarr = LatexCmds.rightarrow = bind(VanillaSymbol,'\\\\rightarrow ','&rarr;');\n\nLatexCmds.implies = bind(BinaryOperator,'\\\\Rightarrow ','&rArr;');\n\nLatexCmds.rArr = LatexCmds.Rightarrow = bind(VanillaSymbol,'\\\\Rightarrow ','&rArr;');\n\nLatexCmds.gets = bind(BinaryOperator,'\\\\gets ','&larr;');\n\nLatexCmds.larr = LatexCmds.leftarrow = bind(VanillaSymbol,'\\\\leftarrow ','&larr;');\n\nLatexCmds.impliedby = bind(BinaryOperator,'\\\\Leftarrow ','&lArr;');\n\nLatexCmds.lArr = LatexCmds.Leftarrow = bind(VanillaSymbol,'\\\\Leftarrow ','&lArr;');\n\nLatexCmds.harr = LatexCmds.lrarr = LatexCmds.leftrightarrow =\n  bind(VanillaSymbol,'\\\\leftrightarrow ','&harr;');\n\nLatexCmds.iff = bind(BinaryOperator,'\\\\Leftrightarrow ','&hArr;');\n\nLatexCmds.hArr = LatexCmds.lrArr = LatexCmds.Leftrightarrow =\n  bind(VanillaSymbol,'\\\\Leftrightarrow ','&hArr;');\n\nLatexCmds.Re = LatexCmds.Real = LatexCmds.real = bind(VanillaSymbol,'\\\\Re ','&real;');\n\nLatexCmds.Im = LatexCmds.imag =\nLatexCmds.image = LatexCmds.imagin = LatexCmds.imaginary = LatexCmds.Imaginary =\n  bind(VanillaSymbol,'\\\\Im ','&image;');\n\nLatexCmds.part = LatexCmds.partial = bind(VanillaSymbol,'\\\\partial ','&part;');\n\nLatexCmds.infty = LatexCmds.infin = LatexCmds.infinity =\n  bind(VanillaSymbol,'\\\\infty ','&infin;');\n\nLatexCmds.alef = LatexCmds.alefsym = LatexCmds.aleph = LatexCmds.alephsym =\n  bind(VanillaSymbol,'\\\\aleph ','&alefsym;');\n\nLatexCmds.xist = //LOL\nLatexCmds.xists = LatexCmds.exist = LatexCmds.exists =\n  bind(VanillaSymbol,'\\\\exists ','&exist;');\n\nLatexCmds.and = LatexCmds.land = LatexCmds.wedge =\n  bind(VanillaSymbol,'\\\\wedge ','&and;');\n\nLatexCmds.or = LatexCmds.lor = LatexCmds.vee = bind(VanillaSymbol,'\\\\vee ','&or;');\n\nLatexCmds.o = LatexCmds.O =\nLatexCmds.empty = LatexCmds.emptyset =\nLatexCmds.oslash = LatexCmds.Oslash =\nLatexCmds.nothing = LatexCmds.varnothing =\n  bind(BinaryOperator,'\\\\varnothing ','&empty;');\n\nLatexCmds.cup = LatexCmds.union = bind(BinaryOperator,'\\\\cup ','&cup;');\n\nLatexCmds.cap = LatexCmds.intersect = LatexCmds.intersection =\n  bind(BinaryOperator,'\\\\cap ','&cap;');\n\n// FIXME: the correct LaTeX would be ^\\circ but we can't parse that\nLatexCmds.deg = LatexCmds.degree = bind(VanillaSymbol,'\\\\degree ','&deg;');\n\nLatexCmds.ang = LatexCmds.angle = bind(VanillaSymbol,'\\\\angle ','&ang;');\nLatexCmds.measuredangle = bind(VanillaSymbol,'\\\\measuredangle ','&#8737;');\n/*********************************\n * Symbols for Basic Mathematics\n ********************************/\n\nvar Digit = P(VanillaSymbol, function(_, super_) {\n  _.createLeftOf = function(cursor) {\n    if (cursor.options.autoSubscriptNumerals\n        && cursor.parent !== cursor.parent.parent.sub\n        && ((cursor[L] instanceof Variable && cursor[L].isItalic !== false)\n            || (cursor[L] instanceof SupSub\n                && cursor[L][L] instanceof Variable\n                && cursor[L][L].isItalic !== false))) {\n      LatexCmds._().createLeftOf(cursor);\n      super_.createLeftOf.call(this, cursor);\n      cursor.insRightOf(cursor.parent.parent);\n    }\n    else super_.createLeftOf.call(this, cursor);\n  };\n});\n\nvar Variable = P(Symbol, function(_, super_) {\n  _.init = function(ch, html) {\n    super_.init.call(this, ch, '<var>'+(html || ch)+'</var>');\n  };\n  _.text = function() {\n    var text = this.ctrlSeq;\n    if (this[L] && !(this[L] instanceof Variable)\n        && !(this[L] instanceof BinaryOperator)\n        && this[L].ctrlSeq !== \"\\\\ \")\n      text = '*' + text;\n    if (this[R] && !(this[R] instanceof BinaryOperator)\n        && !(this[R] instanceof SupSub))\n      text += '*';\n    return text;\n  };\n});\n\nOptions.p.autoCommands = { _maxLength: 0 };\noptionProcessors.autoCommands = function(cmds) {\n  if (!/^[a-z]+(?: [a-z]+)*$/i.test(cmds)) {\n    throw '\"'+cmds+'\" not a space-delimited list of only letters';\n  }\n  var list = cmds.split(' '), dict = {}, maxLength = 0;\n  for (var i = 0; i < list.length; i += 1) {\n    var cmd = list[i];\n    if (cmd.length < 2) {\n      throw 'autocommand \"'+cmd+'\" not minimum length of 2';\n    }\n    if (LatexCmds[cmd] === OperatorName) {\n      throw '\"' + cmd + '\" is a built-in operator name';\n    }\n    dict[cmd] = 1;\n    maxLength = max(maxLength, cmd.length);\n  }\n  dict._maxLength = maxLength;\n  return dict;\n};\n\nvar Letter = P(Variable, function(_, super_) {\n  _.init = function(ch) { return super_.init.call(this, this.letter = ch); };\n  _.createLeftOf = function(cursor) {\n    var autoCmds = cursor.options.autoCommands, maxLength = autoCmds._maxLength;\n    if (maxLength > 0) {\n      // want longest possible autocommand, so join together longest\n      // sequence of letters\n      var str = this.letter, l = cursor[L], i = 1;\n      while (l instanceof Letter && i < maxLength) {\n        str = l.letter + str, l = l[L], i += 1;\n      }\n      // check for an autocommand, going thru substrings longest to shortest\n      while (str.length) {\n        if (autoCmds.hasOwnProperty(str)) {\n          for (var i = 2, l = cursor[L]; i < str.length; i += 1, l = l[L]);\n          Fragment(l, cursor[L]).remove();\n          cursor[L] = l[L];\n          return LatexCmds[str](str).createLeftOf(cursor);\n        }\n        str = str.slice(1);\n      }\n    }\n    super_.createLeftOf.apply(this, arguments);\n  };\n  _.italicize = function(bool) {\n    this.isItalic = bool;\n    this.jQ.toggleClass('mq-operator-name', !bool);\n    return this;\n  };\n  _.finalizeTree = _.siblingDeleted = _.siblingCreated = function(opts, dir) {\n    // don't auto-un-italicize if the sibling to my right changed (dir === R or\n    // undefined) and it's now a Letter, it will un-italicize everyone\n    if (dir !== L && this[R] instanceof Letter) return;\n    this.autoUnItalicize(opts);\n  };\n  _.autoUnItalicize = function(opts) {\n    var autoOps = opts.autoOperatorNames;\n    if (autoOps._maxLength === 0) return;\n    // want longest possible operator names, so join together entire contiguous\n    // sequence of letters\n    var str = this.letter;\n    for (var l = this[L]; l instanceof Letter; l = l[L]) str = l.letter + str;\n    for (var r = this[R]; r instanceof Letter; r = r[R]) str += r.letter;\n\n    // removeClass and delete flags from all letters before figuring out\n    // which, if any, are part of an operator name\n    Fragment(l[R] || this.parent.ends[L], r[L] || this.parent.ends[R]).each(function(el) {\n      el.italicize(true).jQ.removeClass('mq-first mq-last');\n      el.ctrlSeq = el.letter;\n    });\n\n    // check for operator names: at each position from left to right, check\n    // substrings from longest to shortest\n    outer: for (var i = 0, first = l[R] || this.parent.ends[L]; i < str.length; i += 1, first = first[R]) {\n      for (var len = min(autoOps._maxLength, str.length - i); len > 0; len -= 1) {\n        var word = str.slice(i, i + len);\n        if (autoOps.hasOwnProperty(word)) {\n          for (var j = 0, letter = first; j < len; j += 1, letter = letter[R]) {\n            letter.italicize(false);\n            var last = letter;\n          }\n\n          var isBuiltIn = BuiltInOpNames.hasOwnProperty(word);\n          first.ctrlSeq = (isBuiltIn ? '\\\\' : '\\\\operatorname{') + first.ctrlSeq;\n          last.ctrlSeq += (isBuiltIn ? ' ' : '}');\n          if (TwoWordOpNames.hasOwnProperty(word)) last[L][L][L].jQ.addClass('mq-last');\n          if (nonOperatorSymbol(first[L])) first.jQ.addClass('mq-first');\n          if (nonOperatorSymbol(last[R])) last.jQ.addClass('mq-last');\n\n          i += len - 1;\n          first = last;\n          continue outer;\n        }\n      }\n    }\n  };\n  function nonOperatorSymbol(node) {\n    return node instanceof Symbol && !(node instanceof BinaryOperator);\n  }\n});\nvar BuiltInOpNames = {}; // the set of operator names like \\sin, \\cos, etc that\n  // are built-into LaTeX: http://latex.wikia.com/wiki/List_of_LaTeX_symbols#Named_operators:_sin.2C_cos.2C_etc.\n  // MathQuill auto-unitalicizes some operator names not in that set, like 'hcf'\n  // and 'arsinh', which must be exported as \\operatorname{hcf} and\n  // \\operatorname{arsinh}. Note: over/under line/arrow \\lim variants like\n  // \\varlimsup are not supported\nvar AutoOpNames = Options.p.autoOperatorNames = { _maxLength: 9 }; // the set\n  // of operator names that MathQuill auto-unitalicizes by default; overridable\nvar TwoWordOpNames = { limsup: 1, liminf: 1, projlim: 1, injlim: 1 };\n(function() {\n  var mostOps = ('arg deg det dim exp gcd hom inf ker lg lim ln log max min sup'\n                 + ' limsup liminf injlim projlim Pr').split(' ');\n  for (var i = 0; i < mostOps.length; i += 1) {\n    BuiltInOpNames[mostOps[i]] = AutoOpNames[mostOps[i]] = 1;\n  }\n\n  var builtInTrigs = // why coth but not sech and csch, LaTeX?\n    'sin cos tan arcsin arccos arctan sinh cosh tanh sec csc cot coth'.split(' ');\n  for (var i = 0; i < builtInTrigs.length; i += 1) {\n    BuiltInOpNames[builtInTrigs[i]] = 1;\n  }\n\n  var autoTrigs = 'sin cos tan sec cosec csc cotan cot ctg'.split(' ');\n  for (var i = 0; i < autoTrigs.length; i += 1) {\n    AutoOpNames[autoTrigs[i]] =\n    AutoOpNames['arc'+autoTrigs[i]] =\n    AutoOpNames[autoTrigs[i]+'h'] =\n    AutoOpNames['ar'+autoTrigs[i]+'h'] =\n    AutoOpNames['arc'+autoTrigs[i]+'h'] = 1;\n  }\n\n  // compat with some of the nonstandard LaTeX exported by MathQuill\n  // before #247. None of these are real LaTeX commands so, seems safe\n  var moreNonstandardOps = 'gcf hcf lcm proj span'.split(' ');\n  for (var i = 0; i < moreNonstandardOps.length; i += 1) {\n    AutoOpNames[moreNonstandardOps[i]] = 1;\n  }\n}());\noptionProcessors.autoOperatorNames = function(cmds) {\n  if (!/^[a-z]+(?: [a-z]+)*$/i.test(cmds)) {\n    throw '\"'+cmds+'\" not a space-delimited list of only letters';\n  }\n  var list = cmds.split(' '), dict = {}, maxLength = 0;\n  for (var i = 0; i < list.length; i += 1) {\n    var cmd = list[i];\n    if (cmd.length < 2) {\n      throw '\"'+cmd+'\" not minimum length of 2';\n    }\n    dict[cmd] = 1;\n    maxLength = max(maxLength, cmd.length);\n  }\n  dict._maxLength = maxLength;\n  return dict;\n};\nvar OperatorName = P(Symbol, function(_, super_) {\n  _.init = function(fn) { this.ctrlSeq = fn; };\n  _.createLeftOf = function(cursor) {\n    var fn = this.ctrlSeq;\n    for (var i = 0; i < fn.length; i += 1) {\n      Letter(fn.charAt(i)).createLeftOf(cursor);\n    }\n  };\n  _.parser = function() {\n    var fn = this.ctrlSeq;\n    var block = MathBlock();\n    for (var i = 0; i < fn.length; i += 1) {\n      Letter(fn.charAt(i)).adopt(block, block.ends[R], 0);\n    }\n    return Parser.succeed(block.children());\n  };\n});\nfor (var fn in AutoOpNames) if (AutoOpNames.hasOwnProperty(fn)) {\n  LatexCmds[fn] = OperatorName;\n}\nLatexCmds.operatorname = P(MathCommand, function(_) {\n  _.createLeftOf = noop;\n  _.numBlocks = function() { return 1; };\n  _.parser = function() {\n    return latexMathParser.block.map(function(b) { return b.children(); });\n  };\n});\n\nLatexCmds.f = P(Letter, function(_, super_) {\n  _.init = function() {\n    Symbol.p.init.call(this, this.letter = 'f', '<var class=\"mq-f\">f</var>');\n  };\n  _.italicize = function(bool) {\n    this.jQ.html('f').toggleClass('mq-f', bool);\n    return super_.italicize.apply(this, arguments);\n  };\n});\n\n// VanillaSymbol's\nLatexCmds[' '] = LatexCmds.space = bind(VanillaSymbol, '\\\\ ', '&nbsp;');\n\nLatexCmds[\"'\"] = LatexCmds.prime = bind(VanillaSymbol, \"'\", '&prime;');\n\nLatexCmds.backslash = bind(VanillaSymbol,'\\\\backslash ','\\\\');\nif (!CharCmds['\\\\']) CharCmds['\\\\'] = LatexCmds.backslash;\n\nLatexCmds.$ = bind(VanillaSymbol, '\\\\$', '$');\n\n// does not use Symbola font\nvar NonSymbolaSymbol = P(Symbol, function(_, super_) {\n  _.init = function(ch, html) {\n    super_.init.call(this, ch, '<span class=\"mq-nonSymbola\">'+(html || ch)+'</span>');\n  };\n});\n\nLatexCmds['@'] = NonSymbolaSymbol;\nLatexCmds['&'] = bind(NonSymbolaSymbol, '\\\\&', '&amp;');\nLatexCmds['%'] = bind(NonSymbolaSymbol, '\\\\%', '%');\n\n//the following are all Greek to me, but this helped a lot: http://www.ams.org/STIX/ion/stixsig03.html\n\n//lowercase Greek letter variables\nLatexCmds.alpha =\nLatexCmds.beta =\nLatexCmds.gamma =\nLatexCmds.delta =\nLatexCmds.zeta =\nLatexCmds.eta =\nLatexCmds.theta =\nLatexCmds.iota =\nLatexCmds.kappa =\nLatexCmds.mu =\nLatexCmds.nu =\nLatexCmds.xi =\nLatexCmds.rho =\nLatexCmds.sigma =\nLatexCmds.tau =\nLatexCmds.chi =\nLatexCmds.psi =\nLatexCmds.omega = P(Variable, function(_, super_) {\n  _.init = function(latex) {\n    super_.init.call(this,'\\\\'+latex+' ','&'+latex+';');\n  };\n});\n\n//why can't anybody FUCKING agree on these\nLatexCmds.phi = //W3C or Unicode?\n  bind(Variable,'\\\\phi ','&#981;');\n\nLatexCmds.phiv = //Elsevier and 9573-13\nLatexCmds.varphi = //AMS and LaTeX\n  bind(Variable,'\\\\varphi ','&phi;');\n\nLatexCmds.epsilon = //W3C or Unicode?\n  bind(Variable,'\\\\epsilon ','&#1013;');\n\nLatexCmds.epsiv = //Elsevier and 9573-13\nLatexCmds.varepsilon = //AMS and LaTeX\n  bind(Variable,'\\\\varepsilon ','&epsilon;');\n\nLatexCmds.piv = //W3C/Unicode and Elsevier and 9573-13\nLatexCmds.varpi = //AMS and LaTeX\n  bind(Variable,'\\\\varpi ','&piv;');\n\nLatexCmds.sigmaf = //W3C/Unicode\nLatexCmds.sigmav = //Elsevier\nLatexCmds.varsigma = //LaTeX\n  bind(Variable,'\\\\varsigma ','&sigmaf;');\n\nLatexCmds.thetav = //Elsevier and 9573-13\nLatexCmds.vartheta = //AMS and LaTeX\nLatexCmds.thetasym = //W3C/Unicode\n  bind(Variable,'\\\\vartheta ','&thetasym;');\n\nLatexCmds.upsilon = //AMS and LaTeX and W3C/Unicode\nLatexCmds.upsi = //Elsevier and 9573-13\n  bind(Variable,'\\\\upsilon ','&upsilon;');\n\n//these aren't even mentioned in the HTML character entity references\nLatexCmds.gammad = //Elsevier\nLatexCmds.Gammad = //9573-13 -- WTF, right? I dunno if this was a typo in the reference (see above)\nLatexCmds.digamma = //LaTeX\n  bind(Variable,'\\\\digamma ','&#989;');\n\nLatexCmds.kappav = //Elsevier\nLatexCmds.varkappa = //AMS and LaTeX\n  bind(Variable,'\\\\varkappa ','&#1008;');\n\nLatexCmds.rhov = //Elsevier and 9573-13\nLatexCmds.varrho = //AMS and LaTeX\n  bind(Variable,'\\\\varrho ','&#1009;');\n\n//Greek constants, look best in non-italicized Times New Roman\nLatexCmds.pi = LatexCmds['\\u03c0'] = bind(NonSymbolaSymbol,'\\\\pi ','&pi;');\nLatexCmds.lambda = bind(NonSymbolaSymbol,'\\\\lambda ','&lambda;');\n\n//uppercase greek letters\n\nLatexCmds.Upsilon = //LaTeX\nLatexCmds.Upsi = //Elsevier and 9573-13\nLatexCmds.upsih = //W3C/Unicode \"upsilon with hook\"\nLatexCmds.Upsih = //'cos it makes sense to me\n  bind(Symbol,'\\\\Upsilon ','<var style=\"font-family: serif\">&upsih;</var>'); //Symbola's 'upsilon with a hook' is a capital Y without hooks :(\n\n//other symbols with the same LaTeX command and HTML character entity reference\nLatexCmds.Gamma =\nLatexCmds.Delta =\nLatexCmds.Theta =\nLatexCmds.Lambda =\nLatexCmds.Xi =\nLatexCmds.Pi =\nLatexCmds.Sigma =\nLatexCmds.Phi =\nLatexCmds.Psi =\nLatexCmds.Omega =\nLatexCmds.forall = P(VanillaSymbol, function(_, super_) {\n  _.init = function(latex) {\n    super_.init.call(this,'\\\\'+latex+' ','&'+latex+';');\n  };\n});\n\n// symbols that aren't a single MathCommand, but are instead a whole\n// Fragment. Creates the Fragment from a LaTeX string\nvar LatexFragment = P(MathCommand, function(_) {\n  _.init = function(latex) { this.latex = latex; };\n  _.createLeftOf = function(cursor) {\n    var block = latexMathParser.parse(this.latex);\n    block.children().adopt(cursor.parent, cursor[L], cursor[R]);\n    cursor[L] = block.ends[R];\n    block.jQize().insertBefore(cursor.jQ);\n    block.finalizeInsert(cursor.options, cursor);\n    if (block.ends[R][R].siblingCreated) block.ends[R][R].siblingCreated(cursor.options, L);\n    if (block.ends[L][L].siblingCreated) block.ends[L][L].siblingCreated(cursor.options, R);\n    cursor.parent.bubble('reflow');\n  };\n  _.parser = function() {\n    var frag = latexMathParser.parse(this.latex).children();\n    return Parser.succeed(frag);\n  };\n});\n\n// for what seems to me like [stupid reasons][1], Unicode provides\n// subscripted and superscripted versions of all ten Arabic numerals,\n// as well as [so-called \"vulgar fractions\"][2].\n// Nobody really cares about most of them, but some of them actually\n// predate Unicode, dating back to [ISO-8859-1][3], apparently also\n// known as \"Latin-1\", which among other things [Windows-1252][4]\n// largely coincides with, so Microsoft Word sometimes inserts them\n// and they get copy-pasted into MathQuill.\n//\n// (Irrelevant but funny story: though not a superset of Latin-1 aka\n// ISO-8859-1, Windows-1252 **is** a strict superset of the \"closely\n// related but distinct\"[3] \"ISO 8859-1\" -- see the lack of a dash\n// after \"ISO\"? Completely different character set, like elephants vs\n// elephant seals, or \"Zombies\" vs \"Zombie Redneck Torture Family\".\n// What kind of idiot would get them confused.\n// People in fact got them confused so much, it was so common to\n// mislabel Windows-1252 text as ISO-8859-1, that most modern web\n// browsers and email clients treat the MIME charset of ISO-8859-1\n// as actually Windows-1252, behavior now standard in the HTML5 spec.)\n//\n// [1]: http://en.wikipedia.org/wiki/Unicode_subscripts_andsuper_scripts\n// [2]: http://en.wikipedia.org/wiki/Number_Forms\n// [3]: http://en.wikipedia.org/wiki/ISO/IEC_8859-1\n// [4]: http://en.wikipedia.org/wiki/Windows-1252\nLatexCmds['\\u00b9'] = bind(LatexFragment, '^1');\nLatexCmds['\\u00b2'] = bind(LatexFragment, '^2');\nLatexCmds['\\u00b3'] = bind(LatexFragment, '^3');\nLatexCmds['\\u00bc'] = bind(LatexFragment, '\\\\frac14');\nLatexCmds['\\u00bd'] = bind(LatexFragment, '\\\\frac12');\nLatexCmds['\\u00be'] = bind(LatexFragment, '\\\\frac34');\n\nvar PlusMinus = P(BinaryOperator, function(_) {\n  _.init = VanillaSymbol.prototype.init;\n\n  _.contactWeld = _.siblingCreated = _.siblingDeleted = function(opts, dir) {\n    if (dir === R) return; // ignore if sibling only changed on the right\n    this.jQ[0].className =\n      (!this[L] || this[L] instanceof BinaryOperator ? '' : 'mq-binary-operator');\n    return this;\n  };\n});\n\nLatexCmds['+'] = bind(PlusMinus, '+', '+');\n//yes, these are different dashes, I think one is an en dash and the other is a hyphen\nLatexCmds['\\u2013'] = LatexCmds['-'] = bind(PlusMinus, '-', '&minus;');\nLatexCmds['\\u00b1'] = LatexCmds.pm = LatexCmds.plusmn = LatexCmds.plusminus =\n  bind(PlusMinus,'\\\\pm ','&plusmn;');\nLatexCmds.mp = LatexCmds.mnplus = LatexCmds.minusplus =\n  bind(PlusMinus,'\\\\mp ','&#8723;');\n\nCharCmds['*'] = LatexCmds.sdot = LatexCmds.cdot =\n  bind(BinaryOperator, '\\\\cdot ', '&middot;', '*');\n//semantically should be &sdot;, but &middot; looks better\n\nvar Inequality = P(BinaryOperator, function(_, super_) {\n  _.init = function(data, strict) {\n    this.data = data;\n    this.strict = strict;\n    var strictness = (strict ? 'Strict' : '');\n    super_.init.call(this, data['ctrlSeq'+strictness], data['html'+strictness],\n                     data['text'+strictness]);\n  };\n  _.swap = function(strict) {\n    this.strict = strict;\n    var strictness = (strict ? 'Strict' : '');\n    this.ctrlSeq = this.data['ctrlSeq'+strictness];\n    this.jQ.html(this.data['html'+strictness]);\n    this.textTemplate = [ this.data['text'+strictness] ];\n  };\n  _.deleteTowards = function(dir, cursor) {\n    if (dir === L && !this.strict) {\n      this.swap(true);\n      this.bubble('reflow');\n      return;\n    }\n    super_.deleteTowards.apply(this, arguments);\n  };\n});\n\nvar less = { ctrlSeq: '\\\\le ', html: '&le;', text: '\\u2264',\n             ctrlSeqStrict: '<', htmlStrict: '&lt;', textStrict: '<' };\nvar greater = { ctrlSeq: '\\\\ge ', html: '&ge;', text: '\\u2265',\n                ctrlSeqStrict: '>', htmlStrict: '&gt;', textStrict: '>' };\n\nLatexCmds['<'] = LatexCmds.lt = bind(Inequality, less, true);\nLatexCmds['>'] = LatexCmds.gt = bind(Inequality, greater, true);\nLatexCmds['\\u2264'] = LatexCmds.le = LatexCmds.leq = bind(Inequality, less, false);\nLatexCmds['\\u2265'] = LatexCmds.ge = LatexCmds.geq = bind(Inequality, greater, false);\n\nvar Equality = P(BinaryOperator, function(_, super_) {\n  _.init = function() {\n    super_.init.call(this, '=', '=');\n  };\n  _.createLeftOf = function(cursor) {\n    if (cursor[L] instanceof Inequality && cursor[L].strict) {\n      cursor[L].swap(false);\n      cursor[L].bubble('reflow');\n      return;\n    }\n    super_.createLeftOf.apply(this, arguments);\n  };\n});\nLatexCmds['='] = Equality;\n\nLatexCmds['\\u00d7'] = LatexCmds.times = bind(BinaryOperator, '\\\\times ', '&times;', '[x]');\n\nLatexCmds['\\u00f7'] = LatexCmds.div = LatexCmds.divide = LatexCmds.divides =\n  bind(BinaryOperator,'\\\\div ','&divide;', '[/]');\n\nCharCmds['~'] = LatexCmds.sim = bind(BinaryOperator, '\\\\sim ', '~', '~');\n/***************************\n * Commands and Operators.\n **************************/\n\nvar scale, // = function(jQ, x, y) { ... }\n//will use a CSS 2D transform to scale the jQuery-wrapped HTML elements,\n//or the filter matrix transform fallback for IE 5.5-8, or gracefully degrade to\n//increasing the fontSize to match the vertical Y scaling factor.\n\n//ideas from http://github.com/louisremi/jquery.transform.js\n//see also http://msdn.microsoft.com/en-us/library/ms533014(v=vs.85).aspx\n\n  forceIERedraw = noop,\n  div = document.createElement('div'),\n  div_style = div.style,\n  transformPropNames = {\n    transform:1,\n    WebkitTransform:1,\n    MozTransform:1,\n    OTransform:1,\n    msTransform:1\n  },\n  transformPropName;\n\nfor (var prop in transformPropNames) {\n  if (prop in div_style) {\n    transformPropName = prop;\n    break;\n  }\n}\n\nif (transformPropName) {\n  scale = function(jQ, x, y) {\n    jQ.css(transformPropName, 'scale('+x+','+y+')');\n  };\n}\nelse if ('filter' in div_style) { //IE 6, 7, & 8 fallback, see https://github.com/laughinghan/mathquill/wiki/Transforms\n  forceIERedraw = function(el){ el.className = el.className; };\n  scale = function(jQ, x, y) { //NOTE: assumes y > x\n    x /= (1+(y-1)/2);\n    jQ.css('fontSize', y + 'em');\n    if (!jQ.hasClass('mq-matrixed-container')) {\n      jQ.addClass('mq-matrixed-container')\n      .wrapInner('<span class=\"mq-matrixed\"></span>');\n    }\n    var innerjQ = jQ.children()\n    .css('filter', 'progid:DXImageTransform.Microsoft'\n        + '.Matrix(M11=' + x + \",SizingMethod='auto expand')\"\n    );\n    function calculateMarginRight() {\n      jQ.css('marginRight', (innerjQ.width()-1)*(x-1)/x + 'px');\n    }\n    calculateMarginRight();\n    var intervalId = setInterval(calculateMarginRight);\n    $(window).load(function() {\n      clearTimeout(intervalId);\n      calculateMarginRight();\n    });\n  };\n}\nelse {\n  scale = function(jQ, x, y) {\n    jQ.css('fontSize', y + 'em');\n  };\n}\n\nvar Style = P(MathCommand, function(_, super_) {\n  _.init = function(ctrlSeq, tagName, attrs) {\n    super_.init.call(this, ctrlSeq, '<'+tagName+' '+attrs+'>&0</'+tagName+'>');\n  };\n});\n\n//fonts\nLatexCmds.mathrm = bind(Style, '\\\\mathrm', 'span', 'class=\"mq-roman mq-font\"');\nLatexCmds.mathit = bind(Style, '\\\\mathit', 'i', 'class=\"mq-font\"');\nLatexCmds.mathbf = bind(Style, '\\\\mathbf', 'b', 'class=\"mq-font\"');\nLatexCmds.mathsf = bind(Style, '\\\\mathsf', 'span', 'class=\"mq-sans-serif mq-font\"');\nLatexCmds.mathtt = bind(Style, '\\\\mathtt', 'span', 'class=\"mq-monospace mq-font\"');\n//text-decoration\nLatexCmds.underline = bind(Style, '\\\\underline', 'span', 'class=\"mq-non-leaf mq-underline\"');\nLatexCmds.overline = LatexCmds.bar = bind(Style, '\\\\overline', 'span', 'class=\"mq-non-leaf mq-overline\"');\nLatexCmds.overrightarrow = bind(Style, '\\\\overrightarrow', 'span', 'class=\"mq-non-leaf mq-overarrow mq-arrow-right\"');\nLatexCmds.overleftarrow = bind(Style, '\\\\overleftarrow', 'span', 'class=\"mq-non-leaf mq-overarrow mq-arrow-left\"');\n\n// `\\textcolor{color}{math}` will apply a color to the given math content, where\n// `color` is any valid CSS Color Value (see [SitePoint docs][] (recommended),\n// [Mozilla docs][], or [W3C spec][]).\n//\n// [SitePoint docs]: http://reference.sitepoint.com/css/colorvalues\n// [Mozilla docs]: https://developer.mozilla.org/en-US/docs/CSS/color_value#Values\n// [W3C spec]: http://dev.w3.org/csswg/css3-color/#colorunits\nvar TextColor = LatexCmds.textcolor = P(MathCommand, function(_, super_) {\n  _.setColor = function(color) {\n    this.color = color;\n    this.htmlTemplate =\n      '<span class=\"mq-textcolor\" style=\"color:' + color + '\">&0</span>';\n  };\n  _.latex = function() {\n    return '\\\\textcolor{' + this.color + '}{' + this.blocks[0].latex() + '}';\n  };\n  _.parser = function() {\n    var self = this;\n    var optWhitespace = Parser.optWhitespace;\n    var string = Parser.string;\n    var regex = Parser.regex;\n\n    return optWhitespace\n      .then(string('{'))\n      .then(regex(/^[#\\w\\s.,()%-]*/))\n      .skip(string('}'))\n      .then(function(color) {\n        self.setColor(color);\n        return super_.parser.call(self);\n      })\n    ;\n  };\n});\n\n// Very similar to the \\textcolor command, but will add the given CSS class.\n// Usage: \\class{classname}{math}\n// Note regex that whitelists valid CSS classname characters:\n// https://github.com/mathquill/mathquill/pull/191#discussion_r4327442\nvar Class = LatexCmds['class'] = P(MathCommand, function(_, super_) {\n  _.parser = function() {\n    var self = this, string = Parser.string, regex = Parser.regex;\n    return Parser.optWhitespace\n      .then(string('{'))\n      .then(regex(/^[-\\w\\s\\\\\\xA0-\\xFF]*/))\n      .skip(string('}'))\n      .then(function(cls) {\n        self.htmlTemplate = '<span class=\"mq-class '+cls+'\">&0</span>';\n        return super_.parser.call(self);\n      })\n    ;\n  };\n});\n\nvar SupSub = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '_{...}^{...}';\n  _.createLeftOf = function(cursor) {\n    if (!cursor[L] && cursor.options.supSubsRequireOperand) return;\n    return super_.createLeftOf.apply(this, arguments);\n  };\n  _.contactWeld = function(cursor) {\n    // Look on either side for a SupSub, if one is found compare my\n    // .sub, .sup with its .sub, .sup. If I have one that it doesn't,\n    // then call .addBlock() on it with my block; if I have one that\n    // it also has, then insert my block's children into its block,\n    // unless my block has none, in which case insert the cursor into\n    // its block (and not mine, I'm about to remove myself) in the case\n    // I was just typed.\n    // TODO: simplify\n\n    // equiv. to [L, R].forEach(function(dir) { ... });\n    for (var dir = L; dir; dir = (dir === L ? R : false)) {\n      if (this[dir] instanceof SupSub) {\n        // equiv. to 'sub sup'.split(' ').forEach(function(supsub) { ... });\n        for (var supsub = 'sub'; supsub; supsub = (supsub === 'sub' ? 'sup' : false)) {\n          var src = this[supsub], dest = this[dir][supsub];\n          if (!src) continue;\n          if (!dest) this[dir].addBlock(src.disown());\n          else if (!src.isEmpty()) { // ins src children at -dir end of dest\n            src.jQ.children().insAtDirEnd(-dir, dest.jQ);\n            var children = src.children().disown();\n            var pt = Point(dest, children.ends[R], dest.ends[L]);\n            if (dir === L) children.adopt(dest, dest.ends[R], 0);\n            else children.adopt(dest, 0, dest.ends[L]);\n          }\n          else var pt = Point(dest, 0, dest.ends[L]);\n          this.placeCursor = (function(dest, src) { // TODO: don't monkey-patch\n            return function(cursor) { cursor.insAtDirEnd(-dir, dest || src); };\n          }(dest, src));\n        }\n        this.remove();\n        if (cursor && cursor[L] === this) {\n          if (dir === R && pt) {\n            pt[L] ? cursor.insRightOf(pt[L]) : cursor.insAtLeftEnd(pt.parent);\n          }\n          else cursor.insRightOf(this[dir]);\n        }\n        break;\n      }\n    }\n    this.respace();\n  };\n  Options.p.charsThatBreakOutOfSupSub = '';\n  _.finalizeTree = function() {\n    this.ends[L].write = function(cursor, ch) {\n      if (cursor.options.autoSubscriptNumerals && this === this.parent.sub) {\n        if (ch === '_') return;\n        var cmd = this.chToCmd(ch);\n        if (cmd instanceof Symbol) cursor.deleteSelection();\n        else cursor.clearSelection().insRightOf(this.parent);\n        return cmd.createLeftOf(cursor.show());\n      }\n      if (cursor[L] && !cursor[R] && !cursor.selection\n          && cursor.options.charsThatBreakOutOfSupSub.indexOf(ch) > -1) {\n        cursor.insRightOf(this.parent);\n      }\n      MathBlock.p.write.apply(this, arguments);\n    };\n  };\n  _.moveTowards = function(dir, cursor, updown) {\n    if (cursor.options.autoSubscriptNumerals && !this.sup) {\n      cursor.insDirOf(dir, this);\n    }\n    else super_.moveTowards.apply(this, arguments);\n  };\n  _.deleteTowards = function(dir, cursor) {\n    if (cursor.options.autoSubscriptNumerals && this.sub) {\n      var cmd = this.sub.ends[-dir];\n      if (cmd instanceof Symbol) cmd.remove();\n      else if (cmd) cmd.deleteTowards(dir, cursor.insAtDirEnd(-dir, this.sub));\n\n      // TODO: factor out a .removeBlock() or something\n      if (this.sub.isEmpty()) {\n        this.sub.deleteOutOf(L, cursor.insAtLeftEnd(this.sub));\n        if (this.sup) cursor.insDirOf(-dir, this);\n        // Note `-dir` because in e.g. x_1^2| want backspacing (leftward)\n        // to delete the 1 but to end up rightward of x^2; with non-negated\n        // `dir` (try it), the cursor appears to have gone \"through\" the ^2.\n      }\n    }\n    else super_.deleteTowards.apply(this, arguments);\n  };\n  _.latex = function() {\n    function latex(prefix, block) {\n      var l = block && block.latex();\n      return block ? prefix + (l.length === 1 ? l : '{' + (l || ' ') + '}') : '';\n    }\n    return latex('_', this.sub) + latex('^', this.sup);\n  };\n  _.respace = _.siblingCreated = _.siblingDeleted = function(opts, dir) {\n    if (dir === R) return; // ignore if sibling only changed on the right\n    this.jQ.toggleClass('mq-limit', this[L].ctrlSeq === '\\\\int ');\n  };\n  _.addBlock = function(block) {\n    if (this.supsub === 'sub') {\n      this.sup = this.upInto = this.sub.upOutOf = block;\n      block.adopt(this, this.sub, 0).downOutOf = this.sub;\n      block.jQ = $('<span class=\"mq-sup\"/>').append(block.jQ.children())\n        .attr(mqBlockId, block.id).prependTo(this.jQ);\n    }\n    else {\n      this.sub = this.downInto = this.sup.downOutOf = block;\n      block.adopt(this, 0, this.sup).upOutOf = this.sup;\n      block.jQ = $('<span class=\"mq-sub\"></span>').append(block.jQ.children())\n        .attr(mqBlockId, block.id).appendTo(this.jQ.removeClass('mq-sup-only'));\n      this.jQ.append('<span style=\"display:inline-block;width:0\">&#8203;</span>');\n    }\n    // like 'sub sup'.split(' ').forEach(function(supsub) { ... });\n    for (var i = 0; i < 2; i += 1) (function(cmd, supsub, oppositeSupsub, updown) {\n      cmd[supsub].deleteOutOf = function(dir, cursor) {\n        cursor.insDirOf((this[dir] ? -dir : dir), this.parent);\n        if (!this.isEmpty()) {\n          var end = this.ends[dir];\n          this.children().disown()\n            .withDirAdopt(dir, cursor.parent, cursor[dir], cursor[-dir])\n            .jQ.insDirOf(-dir, cursor.jQ);\n          cursor[-dir] = end;\n        }\n        cmd.supsub = oppositeSupsub;\n        delete cmd[supsub];\n        delete cmd[updown+'Into'];\n        cmd[oppositeSupsub][updown+'OutOf'] = insLeftOfMeUnlessAtEnd;\n        delete cmd[oppositeSupsub].deleteOutOf;\n        if (supsub === 'sub') $(cmd.jQ.addClass('mq-sup-only')[0].lastChild).remove();\n        this.remove();\n      };\n    }(this, 'sub sup'.split(' ')[i], 'sup sub'.split(' ')[i], 'down up'.split(' ')[i]));\n  };\n});\n\nfunction insLeftOfMeUnlessAtEnd(cursor) {\n  // cursor.insLeftOf(cmd), unless cursor at the end of block, and every\n  // ancestor cmd is at the end of every ancestor block\n  var cmd = this.parent, ancestorCmd = cursor;\n  do {\n    if (ancestorCmd[R]) return cursor.insLeftOf(cmd);\n    ancestorCmd = ancestorCmd.parent.parent;\n  } while (ancestorCmd !== cmd);\n  cursor.insRightOf(cmd);\n}\n\nLatexCmds.subscript =\nLatexCmds._ = P(SupSub, function(_, super_) {\n  _.supsub = 'sub';\n  _.htmlTemplate =\n      '<span class=\"mq-supsub mq-non-leaf\">'\n    +   '<span class=\"mq-sub\">&0</span>'\n    +   '<span style=\"display:inline-block;width:0\">&#8203;</span>'\n    + '</span>'\n  ;\n  _.textTemplate = [ '_' ];\n  _.finalizeTree = function() {\n    this.downInto = this.sub = this.ends[L];\n    this.sub.upOutOf = insLeftOfMeUnlessAtEnd;\n    super_.finalizeTree.call(this);\n  };\n});\n\nLatexCmds.superscript =\nLatexCmds.supscript =\nLatexCmds['^'] = P(SupSub, function(_, super_) {\n  _.supsub = 'sup';\n  _.htmlTemplate =\n      '<span class=\"mq-supsub mq-non-leaf mq-sup-only\">'\n    +   '<span class=\"mq-sup\">&0</span>'\n    + '</span>'\n  ;\n  _.textTemplate = [ '^' ];\n  _.finalizeTree = function() {\n    this.upInto = this.sup = this.ends[R];\n    this.sup.downOutOf = insLeftOfMeUnlessAtEnd;\n    super_.finalizeTree.call(this);\n  };\n});\n\nvar SummationNotation = P(MathCommand, function(_, super_) {\n  _.init = function(ch, html) {\n    var htmlTemplate =\n      '<span class=\"mq-large-operator mq-non-leaf\">'\n    +   '<span class=\"mq-to\"><span>&1</span></span>'\n    +   '<big>'+html+'</big>'\n    +   '<span class=\"mq-from\"><span>&0</span></span>'\n    + '</span>'\n    ;\n    Symbol.prototype.init.call(this, ch, htmlTemplate);\n  };\n  _.createLeftOf = function(cursor) {\n    super_.createLeftOf.apply(this, arguments);\n    if (cursor.options.sumStartsWithNEquals) {\n      Letter('n').createLeftOf(cursor);\n      Equality().createLeftOf(cursor);\n    }\n  };\n  _.latex = function() {\n    function simplify(latex) {\n      return latex.length === 1 ? latex : '{' + (latex || ' ') + '}';\n    }\n    return this.ctrlSeq + '_' + simplify(this.ends[L].latex()) +\n      '^' + simplify(this.ends[R].latex());\n  };\n  _.parser = function() {\n    var string = Parser.string;\n    var optWhitespace = Parser.optWhitespace;\n    var succeed = Parser.succeed;\n    var block = latexMathParser.block;\n\n    var self = this;\n    var blocks = self.blocks = [ MathBlock(), MathBlock() ];\n    for (var i = 0; i < blocks.length; i += 1) {\n      blocks[i].adopt(self, self.ends[R], 0);\n    }\n\n    return optWhitespace.then(string('_').or(string('^'))).then(function(supOrSub) {\n      var child = blocks[supOrSub === '_' ? 0 : 1];\n      return block.then(function(block) {\n        block.children().adopt(child, child.ends[R], 0);\n        return succeed(self);\n      });\n    }).many().result(self);\n  };\n  _.finalizeTree = function() {\n    this.downInto = this.ends[L];\n    this.upInto = this.ends[R];\n    this.ends[L].upOutOf = this.ends[R];\n    this.ends[R].downOutOf = this.ends[L];\n  };\n});\n\nLatexCmds['\\u2211'] =\nLatexCmds.sum =\nLatexCmds.summation = bind(SummationNotation,'\\\\sum ','&sum;');\n\nLatexCmds['\\u220f'] =\nLatexCmds.prod =\nLatexCmds.product = bind(SummationNotation,'\\\\prod ','&prod;');\n\nLatexCmds.coprod =\nLatexCmds.coproduct = bind(SummationNotation,'\\\\coprod ','&#8720;');\n\nvar Fraction =\nLatexCmds.frac =\nLatexCmds.dfrac =\nLatexCmds.cfrac =\nLatexCmds.fraction = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '\\\\frac';\n  _.htmlTemplate =\n      '<span class=\"mq-fraction mq-non-leaf\">'\n    +   '<span class=\"mq-numerator\">&0</span>'\n    +   '<span class=\"mq-denominator\">&1</span>'\n    +   '<span style=\"display:inline-block;width:0\">&#8203;</span>'\n    + '</span>'\n  ;\n  _.textTemplate = ['(', ')/(', ')'];\n  _.finalizeTree = function() {\n    this.upInto = this.ends[R].upOutOf = this.ends[L];\n    this.downInto = this.ends[L].downOutOf = this.ends[R];\n  };\n});\n\nvar LiveFraction =\nLatexCmds.over =\nCharCmds['/'] = P(Fraction, function(_, super_) {\n  _.createLeftOf = function(cursor) {\n    if (!this.replacedFragment) {\n      var leftward = cursor[L];\n      while (leftward &&\n        !(\n          leftward instanceof BinaryOperator ||\n          leftward instanceof (LatexCmds.text || noop) ||\n          leftward instanceof SummationNotation ||\n          leftward.ctrlSeq === '\\\\ ' ||\n          /^[,;:]$/.test(leftward.ctrlSeq)\n        ) //lookbehind for operator\n      ) leftward = leftward[L];\n\n      if (leftward instanceof SummationNotation && leftward[R] instanceof SupSub) {\n        leftward = leftward[R];\n        if (leftward[R] instanceof SupSub && leftward[R].ctrlSeq != leftward.ctrlSeq)\n          leftward = leftward[R];\n      }\n\n      if (leftward !== cursor[L]) {\n        this.replaces(Fragment(leftward[R] || cursor.parent.ends[L], cursor[L]));\n        cursor[L] = leftward;\n      }\n    }\n    super_.createLeftOf.call(this, cursor);\n  };\n});\n\nvar SquareRoot =\nLatexCmds.sqrt =\nLatexCmds['\\u221a'] = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '\\\\sqrt';\n  _.htmlTemplate =\n      '<span class=\"mq-non-leaf\">'\n    +   '<span class=\"mq-scaled mq-sqrt-prefix\">&radic;</span>'\n    +   '<span class=\"mq-non-leaf mq-sqrt-stem\">&0</span>'\n    + '</span>'\n  ;\n  _.textTemplate = ['sqrt(', ')'];\n  _.parser = function() {\n    return latexMathParser.optBlock.then(function(optBlock) {\n      return latexMathParser.block.map(function(block) {\n        var nthroot = NthRoot();\n        nthroot.blocks = [ optBlock, block ];\n        optBlock.adopt(nthroot, 0, 0);\n        block.adopt(nthroot, optBlock, 0);\n        return nthroot;\n      });\n    }).or(super_.parser.call(this));\n  };\n  _.reflow = function() {\n    var block = this.ends[R].jQ;\n    scale(block.prev(), 1, block.innerHeight()/+block.css('fontSize').slice(0,-2) - .1);\n  };\n});\n\nvar Vec = LatexCmds.vec = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '\\\\vec';\n  _.htmlTemplate =\n      '<span class=\"mq-non-leaf\">'\n    +   '<span class=\"mq-vector-prefix\">&rarr;</span>'\n    +   '<span class=\"mq-vector-stem\">&0</span>'\n    + '</span>'\n  ;\n  _.textTemplate = ['vec(', ')'];\n});\n\nvar NthRoot =\nLatexCmds.nthroot = P(SquareRoot, function(_, super_) {\n  _.htmlTemplate =\n      '<sup class=\"mq-nthroot mq-non-leaf\">&0</sup>'\n    + '<span class=\"mq-scaled\">'\n    +   '<span class=\"mq-sqrt-prefix mq-scaled\">&radic;</span>'\n    +   '<span class=\"mq-sqrt-stem mq-non-leaf\">&1</span>'\n    + '</span>'\n  ;\n  _.textTemplate = ['sqrt[', '](', ')'];\n  _.latex = function() {\n    return '\\\\sqrt['+this.ends[L].latex()+']{'+this.ends[R].latex()+'}';\n  };\n});\n\nfunction DelimsMixin(_, super_) {\n  _.jQadd = function() {\n    super_.jQadd.apply(this, arguments);\n    this.delimjQs = this.jQ.children(':first').add(this.jQ.children(':last'));\n    this.contentjQ = this.jQ.children(':eq(1)');\n  };\n  _.reflow = function() {\n    var height = this.contentjQ.outerHeight()\n                 / parseFloat(this.contentjQ.css('fontSize'));\n    scale(this.delimjQs, min(1 + .2*(height - 1), 1.2), 1.2*height);\n  };\n}\n\n// Round/Square/Curly/Angle Brackets (aka Parens/Brackets/Braces)\n//   first typed as one-sided bracket with matching \"ghost\" bracket at\n//   far end of current block, until you type an opposing one\nvar Bracket = P(P(MathCommand, DelimsMixin), function(_, super_) {\n  _.init = function(side, open, close, ctrlSeq, end) {\n    super_.init.call(this, '\\\\left'+ctrlSeq, undefined, [open, close]);\n    this.side = side;\n    this.sides = {};\n    this.sides[L] = { ch: open, ctrlSeq: ctrlSeq };\n    this.sides[R] = { ch: close, ctrlSeq: end };\n  };\n  _.numBlocks = function() { return 1; };\n  _.html = function() { // wait until now so that .side may\n    this.htmlTemplate = // be set by createLeftOf or parser\n        '<span class=\"mq-non-leaf\">'\n      +   '<span class=\"mq-scaled mq-paren'+(this.side === R ? ' mq-ghost' : '')+'\">'\n      +     this.sides[L].ch\n      +   '</span>'\n      +   '<span class=\"mq-non-leaf\">&0</span>'\n      +   '<span class=\"mq-scaled mq-paren'+(this.side === L ? ' mq-ghost' : '')+'\">'\n      +     this.sides[R].ch\n      +   '</span>'\n      + '</span>'\n    ;\n    return super_.html.call(this);\n  };\n  _.latex = function() {\n    return '\\\\left'+this.sides[L].ctrlSeq+this.ends[L].latex()+'\\\\right'+this.sides[R].ctrlSeq;\n  };\n  _.oppBrack = function(opts, node, expectedSide) {\n    // return node iff it's a 1-sided bracket of expected side (if any, may be\n    // undefined), and of opposite side from me if I'm not a pipe\n    return node instanceof Bracket && node.side && node.side !== -expectedSide\n      && (this.sides[this.side].ch === '|' || node.side === -this.side)\n      && (!opts.restrictMismatchedBrackets\n        || OPP_BRACKS[this.sides[this.side].ch] === node.sides[node.side].ch\n        || { '(': ']', '[': ')' }[this.sides[L].ch] === node.sides[R].ch) && node;\n  };\n  _.closeOpposing = function(brack) {\n    brack.side = 0;\n    brack.sides[this.side] = this.sides[this.side]; // copy over my info (may be\n    brack.delimjQs.eq(this.side === L ? 0 : 1) // mismatched, like [a, b))\n      .removeClass('mq-ghost').html(this.sides[this.side].ch);\n  };\n  _.createLeftOf = function(cursor) {\n    if (!this.replacedFragment) { // unless wrapping seln in brackets,\n        // check if next to or inside an opposing one-sided bracket\n        // (must check both sides 'cos I might be a pipe)\n      var opts = cursor.options;\n      var brack = this.oppBrack(opts, cursor[L], L)\n                  || this.oppBrack(opts, cursor[R], R)\n                  || this.oppBrack(opts, cursor.parent.parent);\n    }\n    if (brack) {\n      var side = this.side = -brack.side; // may be pipe with .side not yet set\n      this.closeOpposing(brack);\n      if (brack === cursor.parent.parent && cursor[side]) { // move the stuff between\n        Fragment(cursor[side], cursor.parent.ends[side], -side) // me and ghost outside\n          .disown().withDirAdopt(-side, brack.parent, brack, brack[side])\n          .jQ.insDirOf(side, brack.jQ);\n        brack.bubble('reflow');\n      }\n    }\n    else {\n      brack = this, side = brack.side;\n      if (brack.replacedFragment) brack.side = 0; // wrapping seln, don't be one-sided\n      else if (cursor[-side]) { // elsewise, auto-expand so ghost is at far end\n        brack.replaces(Fragment(cursor[-side], cursor.parent.ends[-side], side));\n        cursor[-side] = 0;\n      }\n      super_.createLeftOf.call(brack, cursor);\n    }\n    if (side === L) cursor.insAtLeftEnd(brack.ends[L]);\n    else cursor.insRightOf(brack);\n  };\n  _.placeCursor = noop;\n  _.unwrap = function() {\n    this.ends[L].children().disown().adopt(this.parent, this, this[R])\n      .jQ.insertAfter(this.jQ);\n    this.remove();\n  };\n  _.deleteSide = function(side, outward, cursor) {\n    var parent = this.parent, sib = this[side], farEnd = parent.ends[side];\n\n    if (side === this.side) { // deleting non-ghost of one-sided bracket, unwrap\n      this.unwrap();\n      sib ? cursor.insDirOf(-side, sib) : cursor.insAtDirEnd(side, parent);\n      return;\n    }\n\n    var opts = cursor.options, wasSolid = !this.side;\n    this.side = -side;\n    // if deleting like, outer close-brace of [(1+2)+3} where inner open-paren\n    if (this.oppBrack(opts, this.ends[L].ends[this.side], side)) { // is ghost,\n      this.closeOpposing(this.ends[L].ends[this.side]); // then become [1+2)+3\n      var origEnd = this.ends[L].ends[side];\n      this.unwrap();\n      if (origEnd.siblingCreated) origEnd.siblingCreated(cursor.options, side);\n      sib ? cursor.insDirOf(-side, sib) : cursor.insAtDirEnd(side, parent);\n    }\n    else { // if deleting like, inner close-brace of ([1+2}+3) where outer\n      if (this.oppBrack(opts, this.parent.parent, side)) { // open-paren is\n        this.parent.parent.closeOpposing(this); // ghost, then become [1+2+3)\n        this.parent.parent.unwrap();\n      } // else if deleting outward from a solid pair, unwrap\n      else if (outward && wasSolid) {\n        this.unwrap();\n        sib ? cursor.insDirOf(-side, sib) : cursor.insAtDirEnd(side, parent);\n        return;\n      }\n      else { // else deleting just one of a pair of brackets, become one-sided\n        this.sides[side] = { ch: OPP_BRACKS[this.sides[this.side].ch],\n                             ctrlSeq: OPP_BRACKS[this.sides[this.side].ctrlSeq] };\n        this.delimjQs.removeClass('mq-ghost')\n          .eq(side === L ? 0 : 1).addClass('mq-ghost').html(this.sides[side].ch);\n      }\n      if (sib) { // auto-expand so ghost is at far end\n        var origEnd = this.ends[L].ends[side];\n        Fragment(sib, farEnd, -side).disown()\n          .withDirAdopt(-side, this.ends[L], origEnd, 0)\n          .jQ.insAtDirEnd(side, this.ends[L].jQ.removeClass('mq-empty'));\n        if (origEnd.siblingCreated) origEnd.siblingCreated(cursor.options, side);\n        cursor.insDirOf(-side, sib);\n      } // didn't auto-expand, cursor goes just outside or just inside parens\n      else (outward ? cursor.insDirOf(side, this)\n                    : cursor.insAtDirEnd(side, this.ends[L]));\n    }\n  };\n  _.deleteTowards = function(dir, cursor) {\n    this.deleteSide(-dir, false, cursor);\n  };\n  _.finalizeTree = function() {\n    this.ends[L].deleteOutOf = function(dir, cursor) {\n      this.parent.deleteSide(dir, true, cursor);\n    };\n    // FIXME HACK: after initial creation/insertion, finalizeTree would only be\n    // called if the paren is selected and replaced, e.g. by LiveFraction\n    this.finalizeTree = this.intentionalBlur = function() {\n      this.delimjQs.eq(this.side === L ? 1 : 0).removeClass('mq-ghost');\n      this.side = 0;\n    };\n  };\n  _.siblingCreated = function(opts, dir) { // if something typed between ghost and far\n    if (dir === -this.side) this.finalizeTree(); // end of its block, solidify\n  };\n});\n\nvar OPP_BRACKS = {\n  '(': ')',\n  ')': '(',\n  '[': ']',\n  ']': '[',\n  '{': '}',\n  '}': '{',\n  '\\\\{': '\\\\}',\n  '\\\\}': '\\\\{',\n  '&lang;': '&rang;',\n  '&rang;': '&lang;',\n  '\\\\langle ': '\\\\rangle ',\n  '\\\\rangle ': '\\\\langle ',\n  '|': '|'\n};\n\nfunction bindCharBracketPair(open, ctrlSeq) {\n  var ctrlSeq = ctrlSeq || open, close = OPP_BRACKS[open], end = OPP_BRACKS[ctrlSeq];\n  CharCmds[open] = bind(Bracket, L, open, close, ctrlSeq, end);\n  CharCmds[close] = bind(Bracket, R, open, close, ctrlSeq, end);\n}\nbindCharBracketPair('(');\nbindCharBracketPair('[');\nbindCharBracketPair('{', '\\\\{');\nLatexCmds.langle = bind(Bracket, L, '&lang;', '&rang;', '\\\\langle ', '\\\\rangle ');\nLatexCmds.rangle = bind(Bracket, R, '&lang;', '&rang;', '\\\\langle ', '\\\\rangle ');\nCharCmds['|'] = bind(Bracket, L, '|', '|', '|', '|');\n\nLatexCmds.left = P(MathCommand, function(_) {\n  _.parser = function() {\n    var regex = Parser.regex;\n    var string = Parser.string;\n    var succeed = Parser.succeed;\n    var optWhitespace = Parser.optWhitespace;\n\n    return optWhitespace.then(regex(/^(?:[([|]|\\\\\\{)/))\n      .then(function(ctrlSeq) { // TODO: \\langle, \\rangle\n        var open = (ctrlSeq.charAt(0) === '\\\\' ? ctrlSeq.slice(1) : ctrlSeq);\n        return latexMathParser.then(function (block) {\n          return string('\\\\right').skip(optWhitespace)\n            .then(regex(/^(?:[\\])|]|\\\\\\})/)).map(function(end) {\n              var close = (end.charAt(0) === '\\\\' ? end.slice(1) : end);\n              var cmd = Bracket(0, open, close, ctrlSeq, end);\n              cmd.blocks = [ block ];\n              block.adopt(cmd, 0, 0);\n              return cmd;\n            })\n          ;\n        });\n      })\n    ;\n  };\n});\n\nLatexCmds.right = P(MathCommand, function(_) {\n  _.parser = function() {\n    return Parser.fail('unmatched \\\\right');\n  };\n});\n\nvar Binomial =\nLatexCmds.binom =\nLatexCmds.binomial = P(P(MathCommand, DelimsMixin), function(_, super_) {\n  _.ctrlSeq = '\\\\binom';\n  _.htmlTemplate =\n      '<span class=\"mq-non-leaf\">'\n    +   '<span class=\"mq-paren mq-scaled\">(</span>'\n    +   '<span class=\"mq-non-leaf\">'\n    +     '<span class=\"mq-array mq-non-leaf\">'\n    +       '<span>&0</span>'\n    +       '<span>&1</span>'\n    +     '</span>'\n    +   '</span>'\n    +   '<span class=\"mq-paren mq-scaled\">)</span>'\n    + '</span>'\n  ;\n  _.textTemplate = ['choose(',',',')'];\n});\n\nvar Choose =\nLatexCmds.choose = P(Binomial, function(_) {\n  _.createLeftOf = LiveFraction.prototype.createLeftOf;\n});\n\nLatexCmds.editable = // backcompat with before cfd3620 on #233\nLatexCmds.MathQuillMathField = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '\\\\MathQuillMathField';\n  _.htmlTemplate =\n      '<span class=\"mq-editable-field\">'\n    +   '<span class=\"mq-root-block\">&0</span>'\n    + '</span>'\n  ;\n  _.parser = function() {\n    var self = this,\n      string = Parser.string, regex = Parser.regex, succeed = Parser.succeed;\n    return string('[').then(regex(/^[a-z][a-z0-9]*/i)).skip(string(']'))\n      .map(function(name) { self.name = name; }).or(succeed())\n      .then(super_.parser.call(self));\n  };\n  _.finalizeTree = function() {\n    var ctrlr = Controller(this.ends[L], this.jQ, Options());\n    ctrlr.KIND_OF_MQ = 'MathField';\n    ctrlr.editable = true;\n    ctrlr.createTextarea();\n    ctrlr.editablesTextareaEvents();\n    ctrlr.cursor.insAtRightEnd(ctrlr.root);\n    RootBlockMixin(ctrlr.root);\n  };\n  _.registerInnerField = function(innerFields, MathField) {\n    innerFields.push(innerFields[this.name] = MathField(this.ends[L].controller));\n  };\n  _.latex = function(){ return this.ends[L].latex(); };\n  _.text = function(){ return this.ends[L].text(); };\n});\n\n// Embed arbitrary things\n// Probably the closest DOM analogue would be an iframe?\n// From MathQuill's perspective, it's a Symbol, it can be\n// anywhere and the cursor can go around it but never in it.\n// Create by calling public API method .dropEmbedded(),\n// or by calling the global public API method .registerEmbed()\n// and rendering LaTeX like \\embed{registeredName} (see test).\nvar Embed = LatexCmds.embed = P(Symbol, function(_, super_) {\n  _.setOptions = function(options) {\n    function noop () { return \"\"; }\n    this.text = options.text || noop;\n    this.htmlTemplate = options.htmlString || \"\";\n    this.latex = options.latex || noop;\n    return this;\n  };\n  _.parser = function() {\n    var self = this;\n      string = Parser.string, regex = Parser.regex, succeed = Parser.succeed;\n    return string('{').then(regex(/^[a-z][a-z0-9]*/i)).skip(string('}'))\n      .then(function(name) {\n        // the chars allowed in the optional data block are arbitrary other than\n        // excluding curly braces and square brackets (which'd be too confusing)\n        return string('[').then(regex(/^[-\\w\\s]*/)).skip(string(']'))\n          .or(succeed()).map(function(data) {\n            return self.setOptions(EMBEDS[name](data));\n          })\n        ;\n      })\n    ;\n  };\n});\nvar MQ1 = getInterface(1);\nfor (var key in MQ1) (function(key, val) {\n  if (typeof val === 'function') {\n    MathQuill[key] = function() {\n      insistOnInterVer();\n      return val.apply(this, arguments);\n    };\n    MathQuill[key].prototype = val.prototype;\n  }\n  else MathQuill[key] = val;\n}(key, MQ1[key]));\n\n}());\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = window.MathQuill;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tYXRocXVpbGwvbWF0aHF1aWxsLmpzP2QwODQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWEsRUFBRTtBQUNsRSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUIscUNBQXFDLEVBQUU7QUFDNUUsMkJBQTJCO0FBQzNCO0FBQ0EsaUJBQWlCLG9DQUFvQyx3QkFBd0IsRUFBRTtBQUMvRSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUJBQXlCLGNBQWMsRUFBRSxFQUFFO0FBQ25ELFFBQVEseUJBQXlCLGNBQWMsRUFBRSxFQUFFO0FBQ25ELFFBQVEseUJBQXlCLGNBQWMsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBNEM7QUFDNUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RCwwQkFBMEIsZ0NBQWdDOztBQUUxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhDQUE4QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiwyQkFBMkI7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGtCQUFrQixFQUFFOzs7QUFHaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnRUFBZ0U7QUFDaEU7O0FBRUEsdUJBQXVCLDJCQUEyQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJDQUEyQyw0QkFBNEI7QUFDdkUsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0NBQWtDO0FBQ2xDLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEMsMENBQTBDO0FBQzFDOztBQUVBLG9DQUFvQztBQUNwQyw0Q0FBNEM7QUFDNUM7O0FBRUEsOEJBQThCO0FBQzlCLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakUsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQixrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQWlEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDOzs7QUFHRDtBQUNBIiwiZmlsZSI6IjIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWF0aFF1aWxsIHYwLjEwLjEgICAgICAgICAgICAgICBodHRwOi8vbWF0aHF1aWxsLmNvbVxuICogYnkgSGFuLCBKZWFuaW5lLCBhbmQgTWFyeSAgbWFpbnRhaW5lcnNAbWF0aHF1aWxsLmNvbVxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGVcbiAqIE1vemlsbGEgUHVibGljIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUExcbiAqIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluXG4gKiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5cbihmdW5jdGlvbigpIHtcblxudmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG4gIHVuZGVmaW5lZCxcbiAgbXFDbWRJZCA9ICdtYXRocXVpbGwtY29tbWFuZC1pZCcsXG4gIG1xQmxvY2tJZCA9ICdtYXRocXVpbGwtYmxvY2staWQnLFxuICBtaW4gPSBNYXRoLm1pbixcbiAgbWF4ID0gTWF0aC5tYXg7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcbiAqIEEgdXRpbGl0eSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCBtYWtlcyBkZWZpbmluZyB2YXJpYWRpY1xuICogZnVuY3Rpb25zIG1vcmUgY29udmVuaWVudCBieSBsZXR0aW5nIHlvdSBlc3NlbnRpYWxseSBkZWZpbmUgZnVuY3Rpb25zXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50IGFzIGEgc3BsYXQsIGkuZS4gdGhlIGxhc3QgYXJndW1lbnQgXCJnYXRoZXJzIHVwXCJcbiAqIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uOlxuICogICB2YXIgZG9TdHVmZiA9IHZhcmlhZGljKGZ1bmN0aW9uKGZpcnN0LCByZXN0KSB7IHJldHVybiByZXN0OyB9KTtcbiAqICAgZG9TdHVmZigxLCAyLCAzKTsgLy8gPT4gWzIsIDNdXG4gKi9cbnZhciBfX3NsaWNlID0gW10uc2xpY2U7XG5mdW5jdGlvbiB2YXJpYWRpYyhmbikge1xuICB2YXIgbnVtRml4ZWRBcmdzID0gZm4ubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgbnVtRml4ZWRBcmdzKTtcbiAgICB2YXIgdmFyQXJnID0gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgbnVtRml4ZWRBcmdzKTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncy5jb25jYXQoWyB2YXJBcmcgXSkpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgdXRpbGl0eSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCBtYWtlcyBjb21iaW5pbmcgb2JqZWN0LW9yaWVudGVkXG4gKiBwcm9ncmFtbWluZyBhbmQgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyB0ZWNobmlxdWVzIG1vcmUgY29udmVuaWVudDpcbiAqIGdpdmVuIGEgbWV0aG9kIG5hbWUgYW5kIGFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGJlIGJvdW5kLCByZXR1cm5zXG4gKiBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgaXQncyBmaXJzdCBhcmd1bWVudCdzIG1ldGhvZCBvZiB0aGF0IG5hbWUgKGlmXG4gKiBpdCBleGlzdHMpIHdpdGggdGhlIGJvdW5kIGFyZ3VtZW50cyBhbmQgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXRcbiAqIGFyZSBwYXNzZWQ6XG4gKiAgIHZhciBzZW5kTWV0aG9kID0gc2VuZCgnbWV0aG9kJywgMSwgMik7XG4gKiAgIHZhciBvYmogPSB7IG1ldGhvZDogZnVuY3Rpb24oKSB7IHJldHVybiBBcnJheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IH07XG4gKiAgIHNlbmRNZXRob2Qob2JqLCAzLCA0KTsgLy8gPT4gWzEsIDIsIDMsIDRdXG4gKiAgIC8vIG9yIG1vcmUgc3BlY2lmaWNhbGx5LFxuICogICB2YXIgb2JqMiA9IHsgbWV0aG9kOiBmdW5jdGlvbihvbmUsIHR3bywgdGhyZWUpIHsgcmV0dXJuIG9uZSp0d28gKyB0aHJlZTsgfSB9O1xuICogICBzZW5kTWV0aG9kKG9iajIsIDMpOyAvLyA9PiA1XG4gKiAgIHNlbmRNZXRob2Qob2JqMiwgNCk7IC8vID0+IDZcbiAqL1xudmFyIHNlbmQgPSB2YXJpYWRpYyhmdW5jdGlvbihtZXRob2QsIGFyZ3MpIHtcbiAgcmV0dXJuIHZhcmlhZGljKGZ1bmN0aW9uKG9iaiwgbW9yZUFyZ3MpIHtcbiAgICBpZiAobWV0aG9kIGluIG9iaikgcmV0dXJuIG9ialttZXRob2RdLmFwcGx5KG9iaiwgYXJncy5jb25jYXQobW9yZUFyZ3MpKTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBBIHV0aWxpdHkgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBcImltcGxpY2l0IGl0ZXJhdG9yc1wiXG4gKiBmcm9tIFwiZ2VuZXJhdG9yc1wiOiBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gYSBzb2xlIGFyZ3VtZW50LFxuICogYSBcInlpZWxkX1wiIGZ1bmN0aW9uLCB0aGF0IGNhbGxzIFwieWllbGRfXCIgcmVwZWF0ZWRseSB3aXRoIGFuIG9iamVjdCBhc1xuICogYSBzb2xlIGFyZ3VtZW50IChwcmVzdW1hYmx5IG9iamVjdHMgYmVpbmcgaXRlcmF0ZWQgb3ZlciksIHJldHVybnNcbiAqIGEgZnVuY3Rpb24gdGhhdCBjYWxscyBpdCdzIGZpcnN0IGFyZ3VtZW50IG9uIGVhY2ggb2YgdGhvc2Ugb2JqZWN0c1xuICogKGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLCBpdCBpcyBjYWxsZWQgcmVwZWF0ZWRseSB3aXRoXG4gKiBlYWNoIG9iamVjdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIG90aGVyd2lzZSBpdCBpcyBzdHJpbmdpZmllZCBhbmRcbiAqIHRoZSBtZXRob2Qgb2YgdGhhdCBuYW1lIGlzIGNhbGxlZCBvbiBlYWNoIG9iamVjdCAoaWYgc3VjaCBhIG1ldGhvZFxuICogZXhpc3RzKSksIHBhc3NpbmcgYWxvbmcgYWxsIGFkZGl0aW9uYWwgYXJndW1lbnRzOlxuICogICB2YXIgYSA9IFtcbiAqICAgICB7IG1ldGhvZDogZnVuY3Rpb24obGlzdCkgeyBsaXN0LnB1c2goMSk7IH0gfSxcbiAqICAgICB7IG1ldGhvZDogZnVuY3Rpb24obGlzdCkgeyBsaXN0LnB1c2goMik7IH0gfSxcbiAqICAgICB7IG1ldGhvZDogZnVuY3Rpb24obGlzdCkgeyBsaXN0LnB1c2goMyk7IH0gfVxuICogICBdO1xuICogICBhLmVhY2ggPSBpdGVyYXRvcihmdW5jdGlvbih5aWVsZF8pIHtcbiAqICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHlpZWxkXyh0aGlzW2ldKTtcbiAqICAgfSk7XG4gKiAgIHZhciBsaXN0ID0gW107XG4gKiAgIGEuZWFjaCgnbWV0aG9kJywgbGlzdCk7XG4gKiAgIGxpc3Q7IC8vID0+IFsxLCAyLCAzXVxuICogICAvLyBOb3RlIHRoYXQgdGhlIGZvci1pbiBsb29wIHdpbGwgeWllbGQgJ2VhY2gnLCBidXQgJ2VhY2gnIG1hcHMgdG9cbiAqICAgLy8gdGhlIGZ1bmN0aW9uIG9iamVjdCBjcmVhdGVkIGJ5IGl0ZXJhdG9yKCkgd2hpY2ggZG9lcyBub3QgaGF2ZSBhXG4gKiAgIC8vIC5tZXRob2QoKSBtZXRob2QsIHNvIHRoYXQganVzdCBmYWlscyBzaWxlbnRseS5cbiAqL1xuZnVuY3Rpb24gaXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gIHJldHVybiB2YXJpYWRpYyhmdW5jdGlvbihmbiwgYXJncykge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIGZuID0gc2VuZChmbik7XG4gICAgdmFyIHlpZWxkXyA9IGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gZm4uYXBwbHkob2JqLCBbIG9iaiBdLmNvbmNhdChhcmdzKSk7IH07XG4gICAgcmV0dXJuIGdlbmVyYXRvci5jYWxsKHRoaXMsIHlpZWxkXyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIHN1Z2FyIHRvIG1ha2UgZGVmaW5pbmcgbG90cyBvZiBjb21tYW5kcyBlYXNpZXIuXG4gKiBUT0RPOiByZXRoaW5rIHRoaXMuXG4gKi9cbmZ1bmN0aW9uIGJpbmQoY29ucyAvKiwgYXJncy4uLiAqLykge1xuICB2YXIgYXJncyA9IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnMuYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogYSBkZXZlbG9wbWVudC1vbmx5IGRlYnVnIG1ldGhvZC4gIFRoaXMgZGVmaW5pdGlvbiBhbmQgYWxsXG4gKiBjYWxscyB0byBgcHJheWAgd2lsbCBiZSBzdHJpcHBlZCBmcm9tIHRoZSBtaW5pZmllZFxuICogYnVpbGQgb2YgbWF0aHF1aWxsLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYnkgbmFtZSB0byBiZSByZW1vdmVkXG4gKiBhdCBjb21waWxlIHRpbWUuICBEbyBub3QgZGVmaW5lIGFub3RoZXIgZnVuY3Rpb25cbiAqIHdpdGggdGhlIHNhbWUgbmFtZSwgYW5kIG9ubHkgY2FsbCB0aGlzIGZ1bmN0aW9uIGJ5XG4gKiBuYW1lLlxuICovXG5mdW5jdGlvbiBwcmF5KG1lc3NhZ2UsIGNvbmQpIHtcbiAgaWYgKCFjb25kKSB0aHJvdyBuZXcgRXJyb3IoJ3ByYXllciBmYWlsZWQ6ICcrbWVzc2FnZSk7XG59XG52YXIgUCA9IChmdW5jdGlvbihwcm90b3R5cGUsIG93blByb3BlcnR5LCB1bmRlZmluZWQpIHtcbiAgLy8gaGVscGVyIGZ1bmN0aW9ucyB0aGF0IGFsc28gaGVscCBtaW5pZmljYXRpb25cbiAgZnVuY3Rpb24gaXNPYmplY3QobykgeyByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnOyB9XG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24oZikgeyByZXR1cm4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbic7IH1cblxuICAvLyB1c2VkIHRvIGV4dGVuZCB0aGUgcHJvdG90eXBlcyBvZiBzdXBlcmNsYXNzZXMgKHdoaWNoIG1pZ2h0IG5vdFxuICAvLyBoYXZlIGAuQmFyZWBzKVxuICBmdW5jdGlvbiBTdXBlcmNsYXNzQmFyZSgpIHt9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIFAoX3N1cGVyY2xhc3MgLyogPSBPYmplY3QgKi8sIGRlZmluaXRpb24pIHtcbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgbm8gc3VwZXJjbGFzcyBpcyBnaXZlblxuICAgIGlmIChkZWZpbml0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlZmluaXRpb24gPSBfc3VwZXJjbGFzcztcbiAgICAgIF9zdXBlcmNsYXNzID0gT2JqZWN0O1xuICAgIH1cblxuICAgIC8vIEMgaXMgdGhlIGNsYXNzIHRvIGJlIHJldHVybmVkLlxuICAgIC8vXG4gICAgLy8gSXQgZGVsZWdhdGVzIHRvIGluc3RhbnRpYXRpbmcgYW4gaW5zdGFuY2Ugb2YgYEJhcmVgLCBzbyB0aGF0IGl0XG4gICAgLy8gd2lsbCBhbHdheXMgcmV0dXJuIGEgbmV3IGluc3RhbmNlIHJlZ2FyZGxlc3Mgb2YgdGhlIGNhbGxpbmdcbiAgICAvLyBjb250ZXh0LlxuICAgIC8vXG4gICAgLy8gIFRPRE86IHRoZSBDaHJvbWUgaW5zcGVjdG9yIHNob3dzIGFsbCBjcmVhdGVkIG9iamVjdHMgYXMgYENgXG4gICAgLy8gICAgICAgIHJhdGhlciB0aGFuIGBPYmplY3RgLiAgU2V0dGluZyB0aGUgLm5hbWUgcHJvcGVydHkgc2VlbXMgdG9cbiAgICAvLyAgICAgICAgaGF2ZSBubyBlZmZlY3QuICBJcyB0aGVyZSBhIHdheSB0byBvdmVycmlkZSB0aGlzIGJlaGF2aW9yP1xuICAgIGZ1bmN0aW9uIEMoKSB7XG4gICAgICB2YXIgc2VsZiA9IG5ldyBCYXJlO1xuICAgICAgaWYgKGlzRnVuY3Rpb24oc2VsZi5pbml0KSkgc2VsZi5pbml0LmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBDLkJhcmUgaXMgYSBjbGFzcyB3aXRoIGEgbm9vcCBjb25zdHJ1Y3Rvci4gIEl0cyBwcm90b3R5cGUgaXMgdGhlXG4gICAgLy8gc2FtZSBhcyBDLCBzbyB0aGF0IGluc3RhbmNlcyBvZiBDLkJhcmUgYXJlIGFsc28gaW5zdGFuY2VzIG9mIEMuXG4gICAgLy8gTmV3IG9iamVjdHMgY2FuIGJlIGFsbG9jYXRlZCB3aXRob3V0IGluaXRpYWxpemF0aW9uIGJ5IGNhbGxpbmdcbiAgICAvLyBgbmV3IE15Q2xhc3MuQmFyZWAuXG4gICAgZnVuY3Rpb24gQmFyZSgpIHt9XG4gICAgQy5CYXJlID0gQmFyZTtcblxuICAgIC8vIFNldCB1cCB0aGUgcHJvdG90eXBlIG9mIHRoZSBuZXcgY2xhc3MuXG4gICAgdmFyIF9zdXBlciA9IFN1cGVyY2xhc3NCYXJlW3Byb3RvdHlwZV0gPSBfc3VwZXJjbGFzc1twcm90b3R5cGVdO1xuICAgIHZhciBwcm90byA9IEJhcmVbcHJvdG90eXBlXSA9IENbcHJvdG90eXBlXSA9IEMucCA9IG5ldyBTdXBlcmNsYXNzQmFyZTtcblxuICAgIC8vIG90aGVyIHZhcmlhYmxlcywgYXMgYSBtaW5pZmllciBvcHRpbWl6YXRpb25cbiAgICB2YXIgZXh0ZW5zaW9ucztcblxuXG4gICAgLy8gc2V0IHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlLCBmb3IgY29udmVuaWVuY2VcbiAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG5cbiAgICBDLm1peGluID0gZnVuY3Rpb24oZGVmKSB7XG4gICAgICBCYXJlW3Byb3RvdHlwZV0gPSBDW3Byb3RvdHlwZV0gPSBQKEMsIGRlZilbcHJvdG90eXBlXTtcbiAgICAgIHJldHVybiBDO1xuICAgIH1cblxuICAgIHJldHVybiAoQy5vcGVuID0gZnVuY3Rpb24oZGVmKSB7XG4gICAgICBleHRlbnNpb25zID0ge307XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGRlZikpIHtcbiAgICAgICAgLy8gY2FsbCB0aGUgZGVmaW5pbmcgZnVuY3Rpb24gd2l0aCBhbGwgdGhlIGFyZ3VtZW50cyB5b3UgbmVlZFxuICAgICAgICAvLyBleHRlbnNpb25zIGNhcHR1cmVzIHRoZSByZXR1cm4gdmFsdWUuXG4gICAgICAgIGV4dGVuc2lvbnMgPSBkZWYuY2FsbChDLCBwcm90bywgX3N1cGVyLCBDLCBfc3VwZXJjbGFzcyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgICAgIC8vIGlmIHlvdSBwYXNzZWQgYW4gb2JqZWN0IGluc3RlYWQsIHdlJ2xsIHRha2UgaXRcbiAgICAgICAgZXh0ZW5zaW9ucyA9IGRlZjtcbiAgICAgIH1cblxuICAgICAgLy8gLi4uYW5kIGV4dGVuZCBpdFxuICAgICAgaWYgKGlzT2JqZWN0KGV4dGVuc2lvbnMpKSB7XG4gICAgICAgIGZvciAodmFyIGV4dCBpbiBleHRlbnNpb25zKSB7XG4gICAgICAgICAgaWYgKG93blByb3BlcnR5LmNhbGwoZXh0ZW5zaW9ucywgZXh0KSkge1xuICAgICAgICAgICAgcHJvdG9bZXh0XSA9IGV4dGVuc2lvbnNbZXh0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUncyBubyBpbml0LCB3ZSBhc3N1bWUgd2UncmUgaW5oZXJpdGluZyBhIG5vbi1wanMgY2xhc3MsIHNvXG4gICAgICAvLyB3ZSBkZWZhdWx0IHRvIGFwcGx5aW5nIHRoZSBzdXBlcmNsYXNzJ3MgY29uc3RydWN0b3IuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24ocHJvdG8uaW5pdCkpIHtcbiAgICAgICAgcHJvdG8uaW5pdCA9IF9zdXBlcmNsYXNzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQztcbiAgICB9KShkZWZpbml0aW9uKTtcbiAgfVxuXG4gIC8vIGFzIGEgbWluaWZpZXIgb3B0aW1pemF0aW9uLCB3ZSd2ZSBjbG9zdXJlZCBpbiBhIGZldyBoZWxwZXIgZnVuY3Rpb25zXG4gIC8vIGFuZCB0aGUgc3RyaW5nICdwcm90b3R5cGUnIChDW3BdIGlzIG11Y2ggc2hvcnRlciB0aGFuIEMucHJvdG90eXBlKVxufSkoJ3Byb3RvdHlwZScsICh7fSkuaGFzT3duUHJvcGVydHkpO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEJhc2UgY2xhc3NlcyBvZiBlZGl0IHRyZWUtcmVsYXRlZCBvYmplY3RzXG4gKlxuICogT25seSBkb2luZyB0cmVlIG5vZGUgbWFuaXB1bGF0aW9uIHZpYSB0aGVzZVxuICogYWRvcHQvIGRpc293biBtZXRob2RzIGd1YXJhbnRlZXMgd2VsbC1mb3JtZWRuZXNzXG4gKiBvZiB0aGUgdHJlZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEwgPSAnbGVmdCdcbi8vIFIgPSAncmlnaHQnXG4vL1xuLy8gdGhlIGNvbnRyYWN0IGlzIHRoYXQgdGhleSBjYW4gYmUgdXNlZCBhcyBvYmplY3QgcHJvcGVydGllc1xuLy8gYW5kICgtTCkgPT09IFIsIGFuZCAoLVIpID09PSBMLlxudmFyIEwgPSAtMTtcbnZhciBSID0gMTtcblxuZnVuY3Rpb24gcHJheURpcmVjdGlvbihkaXIpIHtcbiAgcHJheSgnYSBkaXJlY3Rpb24gd2FzIHBhc3NlZCcsIGRpciA9PT0gTCB8fCBkaXIgPT09IFIpO1xufVxuXG4vKipcbiAqIFRpbnkgZXh0ZW5zaW9uIG9mIGpRdWVyeSBhZGRpbmcgZGlyZWN0aW9uYWxpemVkIERPTSBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAqXG4gKiBGdW5ueSBob3cgUGpzIHYzIGFsbW9zdCBqdXN0IHdvcmtzIHdpdGggYGpRdWVyeS5mbi5pbml0YC5cbiAqXG4gKiBqUXVlcnkgZmVhdHVyZXMgdGhhdCBkb24ndCB3b3JrIG9uICQ6XG4gKiAgIC0galF1ZXJ5LiosIGxpa2UgalF1ZXJ5LmFqYXgsIG9idmlvdXNseSAoUGpzIGRvZXNuJ3QgYW5kIHNob3VsZG4ndFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkgY29uc3RydWN0b3IgcHJvcGVydGllcylcbiAqXG4gKiAgIC0galF1ZXJ5KGZ1bmN0aW9uKSwgdGhlIHNob3J0Y3V0IGZvciBgalF1ZXJ5KGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbilgLFxuICogICAgIGJlY2F1c2UgYGpRdWVyeS5mbi5pbml0YCBpcyBpZGlvc3luY3JhdGljIGFuZCBQanMgZG9pbmcsIGVzc2VudGlhbGx5LFxuICogICAgIGBqUXVlcnkuZm4uaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpYCBpc24ndCBxdWl0ZSByaWdodCwgeW91IG5lZWQ6XG4gKlxuICogICAgICAgXy5pbml0ID0gZnVuY3Rpb24ocywgYykgeyBqUXVlcnkuZm4uaW5pdC5jYWxsKHRoaXMsIHMsIGMsICQoZG9jdW1lbnQpKTsgfTtcbiAqXG4gKiAgICAgaWYgeW91IGFjdHVhbGx5IGdpdmUgYSBzaGl0IChyZWFsbHksIGRvbid0IGJvdGhlciksXG4gKiAgICAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvMS43LjIvc3JjL2NvcmUuanMjTDg4OVxuICpcbiAqICAgLSBqUXVlcnkoc2VsZWN0b3IpLCBiZWNhdXNlIGpRdWVyeSB0cmFuc2xhdGVzIHRoYXQgdG9cbiAqICAgICBgalF1ZXJ5KGRvY3VtZW50KS5maW5kKHNlbGVjdG9yKWAsIGJ1dCBQanMgZG9lc24ndCAoc2hvdWxkIGl0PykgbGV0XG4gKiAgICAgeW91IG92ZXJyaWRlIHRoZSByZXN1bHQgb2YgYSBjb25zdHJ1Y3RvciBjYWxsXG4gKiAgICAgICArIG5vdGUgdGhhdCBiZWNhdXNlIG9mIHRoZSBqUXVlcnkoZG9jdW1lbnQpIHNob3J0Y3V0LW5lc3MsIHRoZXJlJ3MgYWxzb1xuICogICAgICAgICB0aGUgM3JkLWFyZ3VtZW50LW5lZWRzLXRvLWJlLWAkKGRvY3VtZW50KWAgdGhpbmcgYWJvdmUsIGJ1dCB0aGUgZml4XG4gKiAgICAgICAgIGZvciB0aGF0IChhcyBjYW4gYmUgc2VlbiBhYm92ZSkgaXMgcmVhbGx5IGVhc3kuIFRoaXMgcHJvYmxlbSByZXF1aXJlc1xuICogICAgICAgICBhIHdheSBtb3JlIGludHJ1c2l2ZSBmaXhcbiAqXG4gKiBBbmQgdGhhdCdzIGl0ISBFdmVyeXRoaW5nIGVsc2UganVzdCBtYWdpY2FsbHkgd29ya3MgYmVjYXVzZSBqUXVlcnkgaW50ZXJuYWxseVxuICogdXNlcyBgdGhpcy5jb25zdHJ1Y3RvcigpYCBldmVyeXdoZXJlIChoZW5jZSBjYWxsaW5nIGAkYCksIGJ1dCBuZXZlciBldmVyIGRvZXNcbiAqIGB0aGlzLmNvbnN0cnVjdG9yLmZpbmRgIG9yIGFueXRoaW5nIGxpa2UgdGhhdCwgYWx3YXlzIGRvaW5nIGBqUXVlcnkuZmluZGAuXG4gKi9cbnZhciAkID0gUChqUXVlcnksIGZ1bmN0aW9uKF8pIHtcbiAgXy5pbnNEaXJPZiA9IGZ1bmN0aW9uKGRpciwgZWwpIHtcbiAgICByZXR1cm4gZGlyID09PSBMID9cbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGVsLmZpcnN0KCkpIDogdGhpcy5pbnNlcnRBZnRlcihlbC5sYXN0KCkpO1xuICB9O1xuICBfLmluc0F0RGlyRW5kID0gZnVuY3Rpb24oZGlyLCBlbCkge1xuICAgIHJldHVybiBkaXIgPT09IEwgPyB0aGlzLnByZXBlbmRUbyhlbCkgOiB0aGlzLmFwcGVuZFRvKGVsKTtcbiAgfTtcbn0pO1xuXG52YXIgUG9pbnQgPSBQKGZ1bmN0aW9uKF8pIHtcbiAgXy5wYXJlbnQgPSAwO1xuICBfW0xdID0gMDtcbiAgX1tSXSA9IDA7XG5cbiAgXy5pbml0ID0gZnVuY3Rpb24ocGFyZW50LCBsZWZ0d2FyZCwgcmlnaHR3YXJkKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpc1tMXSA9IGxlZnR3YXJkO1xuICAgIHRoaXNbUl0gPSByaWdodHdhcmQ7XG4gIH07XG5cbiAgdGhpcy5jb3B5ID0gZnVuY3Rpb24ocHQpIHtcbiAgICByZXR1cm4gUG9pbnQocHQucGFyZW50LCBwdFtMXSwgcHRbUl0pO1xuICB9O1xufSk7XG5cbi8qKlxuICogTWF0aFF1aWxsIHZpcnR1YWwtRE9NIHRyZWUtbm9kZSBhYnN0cmFjdCBiYXNlIGNsYXNzXG4gKi9cbnZhciBOb2RlID0gUChmdW5jdGlvbihfKSB7XG4gIF9bTF0gPSAwO1xuICBfW1JdID0gMFxuICBfLnBhcmVudCA9IDA7XG5cbiAgdmFyIGlkID0gMDtcbiAgZnVuY3Rpb24gdW5pcXVlTm9kZUlkKCkgeyByZXR1cm4gaWQgKz0gMTsgfVxuICB0aGlzLmJ5SWQgPSB7fTtcblxuICBfLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlkID0gdW5pcXVlTm9kZUlkKCk7XG4gICAgTm9kZS5ieUlkW3RoaXMuaWRdID0gdGhpcztcblxuICAgIHRoaXMuZW5kcyA9IHt9O1xuICAgIHRoaXMuZW5kc1tMXSA9IDA7XG4gICAgdGhpcy5lbmRzW1JdID0gMDtcbiAgfTtcblxuICBfLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHsgZGVsZXRlIE5vZGUuYnlJZFt0aGlzLmlkXTsgfTtcblxuICBfLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAne3sgTWF0aFF1aWxsIE5vZGUgIycrdGhpcy5pZCsnIH19JzsgfTtcblxuICBfLmpRID0gJCgpO1xuICBfLmpRYWRkID0gZnVuY3Rpb24oalEpIHsgcmV0dXJuIHRoaXMualEgPSB0aGlzLmpRLmFkZChqUSk7IH07XG4gIF8ualFpemUgPSBmdW5jdGlvbihqUSkge1xuICAgIC8vIGpRdWVyeS1pZmllcyB0aGlzLmh0bWwoKSBhbmQgbGlua3MgdXAgdGhlIC5qUSBvZiBhbGwgY29ycmVzcG9uZGluZyBOb2Rlc1xuICAgIHZhciBqUSA9ICQoalEgfHwgdGhpcy5odG1sKCkpO1xuXG4gICAgZnVuY3Rpb24galFhZGQoZWwpIHtcbiAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIGNtZElkID0gZWwuZ2V0QXR0cmlidXRlKCdtYXRocXVpbGwtY29tbWFuZC1pZCcpO1xuICAgICAgICB2YXIgYmxvY2tJZCA9IGVsLmdldEF0dHJpYnV0ZSgnbWF0aHF1aWxsLWJsb2NrLWlkJyk7XG4gICAgICAgIGlmIChjbWRJZCkgTm9kZS5ieUlkW2NtZElkXS5qUWFkZChlbCk7XG4gICAgICAgIGlmIChibG9ja0lkKSBOb2RlLmJ5SWRbYmxvY2tJZF0ualFhZGQoZWwpO1xuICAgICAgfVxuICAgICAgZm9yIChlbCA9IGVsLmZpcnN0Q2hpbGQ7IGVsOyBlbCA9IGVsLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGpRYWRkKGVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpRLmxlbmd0aDsgaSArPSAxKSBqUWFkZChqUVtpXSk7XG4gICAgcmV0dXJuIGpRO1xuICB9O1xuXG4gIF8uY3JlYXRlRGlyID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBwcmF5RGlyZWN0aW9uKGRpcik7XG4gICAgdmFyIG5vZGUgPSB0aGlzO1xuICAgIG5vZGUualFpemUoKTtcbiAgICBub2RlLmpRLmluc0Rpck9mKGRpciwgY3Vyc29yLmpRKTtcbiAgICBjdXJzb3JbZGlyXSA9IG5vZGUuYWRvcHQoY3Vyc29yLnBhcmVudCwgY3Vyc29yW0xdLCBjdXJzb3JbUl0pO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGVsKSB7IHJldHVybiB0aGlzLmNyZWF0ZURpcihMLCBlbCk7IH07XG5cbiAgXy5zZWxlY3RDaGlsZHJlbiA9IGZ1bmN0aW9uKGxlZnRFbmQsIHJpZ2h0RW5kKSB7XG4gICAgcmV0dXJuIFNlbGVjdGlvbihsZWZ0RW5kLCByaWdodEVuZCk7XG4gIH07XG5cbiAgXy5idWJibGUgPSBpdGVyYXRvcihmdW5jdGlvbih5aWVsZF8pIHtcbiAgICBmb3IgKHZhciBhbmNlc3RvciA9IHRoaXM7IGFuY2VzdG9yOyBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHlpZWxkXyhhbmNlc3Rvcik7XG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIF8ucG9zdE9yZGVyID0gaXRlcmF0b3IoZnVuY3Rpb24oeWllbGRfKSB7XG4gICAgKGZ1bmN0aW9uIHJlY3Vyc2UoZGVzY2VuZGFudCkge1xuICAgICAgZGVzY2VuZGFudC5lYWNoQ2hpbGQocmVjdXJzZSk7XG4gICAgICB5aWVsZF8oZGVzY2VuZGFudCk7XG4gICAgfSkodGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kc1tMXSA9PT0gMCAmJiB0aGlzLmVuZHNbUl0gPT09IDA7XG4gIH07XG5cbiAgXy5jaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBGcmFnbWVudCh0aGlzLmVuZHNbTF0sIHRoaXMuZW5kc1tSXSk7XG4gIH07XG5cbiAgXy5lYWNoQ2hpbGQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZWFjaC5hcHBseShjaGlsZHJlbiwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfLmZvbGRDaGlsZHJlbiA9IGZ1bmN0aW9uKGZvbGQsIGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4oKS5mb2xkKGZvbGQsIGZuKTtcbiAgfTtcblxuICBfLndpdGhEaXJBZG9wdCA9IGZ1bmN0aW9uKGRpciwgcGFyZW50LCB3aXRoRGlyLCBvcHBEaXIpIHtcbiAgICBGcmFnbWVudCh0aGlzLCB0aGlzKS53aXRoRGlyQWRvcHQoZGlyLCBwYXJlbnQsIHdpdGhEaXIsIG9wcERpcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgXy5hZG9wdCA9IGZ1bmN0aW9uKHBhcmVudCwgbGVmdHdhcmQsIHJpZ2h0d2FyZCkge1xuICAgIEZyYWdtZW50KHRoaXMsIHRoaXMpLmFkb3B0KHBhcmVudCwgbGVmdHdhcmQsIHJpZ2h0d2FyZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgXy5kaXNvd24gPSBmdW5jdGlvbigpIHtcbiAgICBGcmFnbWVudCh0aGlzLCB0aGlzKS5kaXNvd24oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMualEucmVtb3ZlKCk7XG4gICAgdGhpcy5wb3N0T3JkZXIoJ2Rpc3Bvc2UnKTtcbiAgICByZXR1cm4gdGhpcy5kaXNvd24oKTtcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBwcmF5V2VsbEZvcm1lZChwYXJlbnQsIGxlZnR3YXJkLCByaWdodHdhcmQpIHtcbiAgcHJheSgnYSBwYXJlbnQgaXMgYWx3YXlzIHByZXNlbnQnLCBwYXJlbnQpO1xuICBwcmF5KCdsZWZ0d2FyZCBpcyBwcm9wZXJseSBzZXQgdXAnLCAoZnVuY3Rpb24oKSB7XG4gICAgLy8gZWl0aGVyIGl0J3MgZW1wdHkgYW5kIGByaWdodHdhcmRgIGlzIHRoZSBsZWZ0IGVuZCBjaGlsZCAocG9zc2libHkgZW1wdHkpXG4gICAgaWYgKCFsZWZ0d2FyZCkgcmV0dXJuIHBhcmVudC5lbmRzW0xdID09PSByaWdodHdhcmQ7XG5cbiAgICAvLyBvciBpdCdzIHRoZXJlIGFuZCBpdHMgW1JdIGFuZCAucGFyZW50IGFyZSBwcm9wZXJseSBzZXQgdXBcbiAgICByZXR1cm4gbGVmdHdhcmRbUl0gPT09IHJpZ2h0d2FyZCAmJiBsZWZ0d2FyZC5wYXJlbnQgPT09IHBhcmVudDtcbiAgfSkoKSk7XG5cbiAgcHJheSgncmlnaHR3YXJkIGlzIHByb3Blcmx5IHNldCB1cCcsIChmdW5jdGlvbigpIHtcbiAgICAvLyBlaXRoZXIgaXQncyBlbXB0eSBhbmQgYGxlZnR3YXJkYCBpcyB0aGUgcmlnaHQgZW5kIGNoaWxkIChwb3NzaWJseSBlbXB0eSlcbiAgICBpZiAoIXJpZ2h0d2FyZCkgcmV0dXJuIHBhcmVudC5lbmRzW1JdID09PSBsZWZ0d2FyZDtcblxuICAgIC8vIG9yIGl0J3MgdGhlcmUgYW5kIGl0cyBbTF0gYW5kIC5wYXJlbnQgYXJlIHByb3Blcmx5IHNldCB1cFxuICAgIHJldHVybiByaWdodHdhcmRbTF0gPT09IGxlZnR3YXJkICYmIHJpZ2h0d2FyZC5wYXJlbnQgPT09IHBhcmVudDtcbiAgfSkoKSk7XG59XG5cblxuLyoqXG4gKiBBbiBlbnRpdHkgb3V0c2lkZSB0aGUgdmlydHVhbCB0cmVlIHdpdGggb25lLXdheSBwb2ludGVycyAoc28gaXQncyBvbmx5IGFcbiAqIFwidmlld1wiIG9mIHBhcnQgb2YgdGhlIHRyZWUsIG5vdCBhbiBhY3R1YWwgbm9kZS9lbnRpdHkgaW4gdGhlIHRyZWUpIHRoYXRcbiAqIGRlbGltaXRzIGEgZG91Ymx5LWxpbmtlZCBsaXN0IG9mIHNpYmxpbmcgbm9kZXMuXG4gKiBJdCdzIGxpa2UgYSBmYW5maWMgbG92ZS1jaGlsZCBiZXR3ZWVuIEhUTUwgRE9NIERvY3VtZW50RnJhZ21lbnQgYW5kIHRoZSBSYW5nZVxuICogY2xhc3NlczogbGlrZSBEb2N1bWVudEZyYWdtZW50LCBpdHMgY29udGVudHMgbXVzdCBiZSBzaWJsaW5nIG5vZGVzXG4gKiAodW5saWtlIFJhbmdlLCB3aG9zZSBjb250ZW50cyBhcmUgYXJiaXRyYXJ5IGNvbnRpZ3VvdXMgcGllY2VzIG9mIHN1YnRyZWVzKSxcbiAqIGJ1dCBsaWtlIFJhbmdlLCBpdCBoYXMgb25seSBvbmUtd2F5IHBvaW50ZXJzIHRvIGl0cyBjb250ZW50cywgaXRzIGNvbnRlbnRzXG4gKiBoYXZlIG5vIHJlZmVyZW5jZSB0byBpdCBhbmQgaW4gZmFjdCBtYXkgc3RpbGwgYmUgaW4gdGhlIHZpc2libGUgdHJlZSAodW5saWtlXG4gKiBEb2N1bWVudEZyYWdtZW50LCB3aG9zZSBjb250ZW50cyBtdXN0IGJlIGRldGFjaGVkIGZyb20gdGhlIHZpc2libGUgdHJlZVxuICogYW5kIGhhdmUgdGhlaXIgJ3BhcmVudCcgcG9pbnRlcnMgc2V0IHRvIHRoZSBEb2N1bWVudEZyYWdtZW50KS5cbiAqL1xudmFyIEZyYWdtZW50ID0gUChmdW5jdGlvbihfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKHdpdGhEaXIsIG9wcERpciwgZGlyKSB7XG4gICAgaWYgKGRpciA9PT0gdW5kZWZpbmVkKSBkaXIgPSBMO1xuICAgIHByYXlEaXJlY3Rpb24oZGlyKTtcblxuICAgIHByYXkoJ25vIGhhbGYtZW1wdHkgZnJhZ21lbnRzJywgIXdpdGhEaXIgPT09ICFvcHBEaXIpO1xuXG4gICAgdGhpcy5lbmRzID0ge307XG5cbiAgICBpZiAoIXdpdGhEaXIpIHJldHVybjtcblxuICAgIHByYXkoJ3dpdGhEaXIgaXMgcGFzc2VkIHRvIEZyYWdtZW50Jywgd2l0aERpciBpbnN0YW5jZW9mIE5vZGUpO1xuICAgIHByYXkoJ29wcERpciBpcyBwYXNzZWQgdG8gRnJhZ21lbnQnLCBvcHBEaXIgaW5zdGFuY2VvZiBOb2RlKTtcbiAgICBwcmF5KCd3aXRoRGlyIGFuZCBvcHBEaXIgaGF2ZSB0aGUgc2FtZSBwYXJlbnQnLFxuICAgICAgICAgd2l0aERpci5wYXJlbnQgPT09IG9wcERpci5wYXJlbnQpO1xuXG4gICAgdGhpcy5lbmRzW2Rpcl0gPSB3aXRoRGlyO1xuICAgIHRoaXMuZW5kc1stZGlyXSA9IG9wcERpcjtcblxuICAgIC8vIFRvIGJ1aWxkIHRoZSBqcXVlcnkgY29sbGVjdGlvbiBmb3IgYSBmcmFnbWVudCwgYWNjdW11bGF0ZSBlbGVtZW50c1xuICAgIC8vIGludG8gYW4gYXJyYXkgYW5kIHRoZW4gY2FsbCBqUS5hZGQgb25jZSBvbiB0aGUgcmVzdWx0LiBqUS5hZGQgc29ydHMgdGhlXG4gICAgLy8gY29sbGVjdGlvbiBhY2NvcmRpbmcgdG8gZG9jdW1lbnQgb3JkZXIgZWFjaCB0aW1lIGl0IGlzIGNhbGxlZCwgc29cbiAgICAvLyBidWlsZGluZyBhIGNvbGxlY3Rpb24gYnkgZm9sZGluZyBqUS5hZGQgZGlyZWN0bHkgdGFrZXMgbW9yZSB0aGFuXG4gICAgLy8gcXVhZHJhdGljIHRpbWUgaW4gdGhlIG51bWJlciBvZiBlbGVtZW50cy5cbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvMi4xLjQvc3JjL3RyYXZlcnNpbmcuanMjTDExMlxuICAgIHZhciBhY2N1bSA9IHRoaXMuZm9sZChbXSwgZnVuY3Rpb24gKGFjY3VtLCBlbCkge1xuICAgICAgYWNjdW0ucHVzaC5hcHBseShhY2N1bSwgZWwualEuZ2V0KCkpO1xuICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0pO1xuXG4gICAgdGhpcy5qUSA9IHRoaXMualEuYWRkKGFjY3VtKTtcbiAgfTtcbiAgXy5qUSA9ICQoKTtcblxuICAvLyBsaWtlIEN1cnNvcjo6d2l0aERpckluc2VydEF0KGRpciwgcGFyZW50LCB3aXRoRGlyLCBvcHBEaXIpXG4gIF8ud2l0aERpckFkb3B0ID0gZnVuY3Rpb24oZGlyLCBwYXJlbnQsIHdpdGhEaXIsIG9wcERpcikge1xuICAgIHJldHVybiAoZGlyID09PSBMID8gdGhpcy5hZG9wdChwYXJlbnQsIHdpdGhEaXIsIG9wcERpcilcbiAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuYWRvcHQocGFyZW50LCBvcHBEaXIsIHdpdGhEaXIpKTtcbiAgfTtcbiAgXy5hZG9wdCA9IGZ1bmN0aW9uKHBhcmVudCwgbGVmdHdhcmQsIHJpZ2h0d2FyZCkge1xuICAgIHByYXlXZWxsRm9ybWVkKHBhcmVudCwgbGVmdHdhcmQsIHJpZ2h0d2FyZCk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5kaXNvd25lZCA9IGZhbHNlO1xuXG4gICAgdmFyIGxlZnRFbmQgPSBzZWxmLmVuZHNbTF07XG4gICAgaWYgKCFsZWZ0RW5kKSByZXR1cm4gdGhpcztcblxuICAgIHZhciByaWdodEVuZCA9IHNlbGYuZW5kc1tSXTtcblxuICAgIGlmIChsZWZ0d2FyZCkge1xuICAgICAgLy8gTkI6IHRoaXMgaXMgaGFuZGxlZCBpbiB0aGUgOjplYWNoKCkgYmxvY2tcbiAgICAgIC8vIGxlZnR3YXJkW1JdID0gbGVmdEVuZFxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuZW5kc1tMXSA9IGxlZnRFbmQ7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0d2FyZCkge1xuICAgICAgcmlnaHR3YXJkW0xdID0gcmlnaHRFbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5lbmRzW1JdID0gcmlnaHRFbmQ7XG4gICAgfVxuXG4gICAgc2VsZi5lbmRzW1JdW1JdID0gcmlnaHR3YXJkO1xuXG4gICAgc2VsZi5lYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICBlbFtMXSA9IGxlZnR3YXJkO1xuICAgICAgZWwucGFyZW50ID0gcGFyZW50O1xuICAgICAgaWYgKGxlZnR3YXJkKSBsZWZ0d2FyZFtSXSA9IGVsO1xuXG4gICAgICBsZWZ0d2FyZCA9IGVsO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgXy5kaXNvd24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxlZnRFbmQgPSBzZWxmLmVuZHNbTF07XG5cbiAgICAvLyBndWFyZCBmb3IgZW1wdHkgYW5kIGFscmVhZHktZGlzb3duZWQgZnJhZ21lbnRzXG4gICAgaWYgKCFsZWZ0RW5kIHx8IHNlbGYuZGlzb3duZWQpIHJldHVybiBzZWxmO1xuXG4gICAgc2VsZi5kaXNvd25lZCA9IHRydWU7XG5cbiAgICB2YXIgcmlnaHRFbmQgPSBzZWxmLmVuZHNbUl1cbiAgICB2YXIgcGFyZW50ID0gbGVmdEVuZC5wYXJlbnQ7XG5cbiAgICBwcmF5V2VsbEZvcm1lZChwYXJlbnQsIGxlZnRFbmRbTF0sIGxlZnRFbmQpO1xuICAgIHByYXlXZWxsRm9ybWVkKHBhcmVudCwgcmlnaHRFbmQsIHJpZ2h0RW5kW1JdKTtcblxuICAgIGlmIChsZWZ0RW5kW0xdKSB7XG4gICAgICBsZWZ0RW5kW0xdW1JdID0gcmlnaHRFbmRbUl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5lbmRzW0xdID0gcmlnaHRFbmRbUl07XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0RW5kW1JdKSB7XG4gICAgICByaWdodEVuZFtSXVtMXSA9IGxlZnRFbmRbTF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5lbmRzW1JdID0gbGVmdEVuZFtMXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICBfLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMualEucmVtb3ZlKCk7XG4gICAgdGhpcy5lYWNoKCdwb3N0T3JkZXInLCAnZGlzcG9zZScpO1xuICAgIHJldHVybiB0aGlzLmRpc293bigpO1xuICB9O1xuXG4gIF8uZWFjaCA9IGl0ZXJhdG9yKGZ1bmN0aW9uKHlpZWxkXykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSBzZWxmLmVuZHNbTF07XG4gICAgaWYgKCFlbCkgcmV0dXJuIHNlbGY7XG5cbiAgICBmb3IgKDsgZWwgIT09IHNlbGYuZW5kc1tSXVtSXTsgZWwgPSBlbFtSXSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHlpZWxkXyhlbCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0pO1xuXG4gIF8uZm9sZCA9IGZ1bmN0aW9uKGZvbGQsIGZuKSB7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICBmb2xkID0gZm4uY2FsbCh0aGlzLCBmb2xkLCBlbCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZm9sZDtcbiAgfTtcbn0pO1xuXG5cbi8qKlxuICogUmVnaXN0cnkgb2YgTGFUZVggY29tbWFuZHMgYW5kIGNvbW1hbmRzIGNyZWF0ZWQgd2hlbiB0eXBpbmdcbiAqIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAqXG4gKiAoQ29tbWFuZHMgYXJlIGFsbCBzdWJjbGFzc2VzIG9mIE5vZGUuKVxuICovXG52YXIgTGF0ZXhDbWRzID0ge30sIENoYXJDbWRzID0ge307XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEN1cnNvciBhbmQgU2VsZWN0aW9uIFwic2luZ2xldG9uXCIgY2xhc3Nlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qIFRoZSBtYWluIHRoaW5nIHRoYXQgbWFuaXB1bGF0ZXMgdGhlIE1hdGggRE9NLiBNYWtlcyBzdXJlIHRvIG1hbmlwdWxhdGUgdGhlXG5IVE1MIERPTSB0byBtYXRjaC4gKi9cblxuLyogU29ydCBvZiBzaW5nbGV0b25zLCBzaW5jZSB0aGVyZSBzaG91bGQgb25seSBiZSBvbmUgcGVyIGVkaXRhYmxlIG1hdGhcbnRleHRib3gsIGJ1dCBhbnkgb25lIEhUTUwgZG9jdW1lbnQgY2FuIGNvbnRhaW4gbWFueSBzdWNoIHRleHRib3hlcywgc28gYW55IG9uZVxuSlMgZW52aXJvbm1lbnQgY291bGQgYWN0dWFsbHkgY29udGFpbiBtYW55IGluc3RhbmNlcy4gKi9cblxuLy9BIGZha2UgY3Vyc29yIGluIHRoZSBmYWtlIHRleHRib3ggdGhhdCB0aGUgbWF0aCBpcyByZW5kZXJlZCBpbi5cbnZhciBDdXJzb3IgPSBQKFBvaW50LCBmdW5jdGlvbihfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGluaXRQYXJlbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnBhcmVudCA9IGluaXRQYXJlbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHZhciBqUSA9IHRoaXMualEgPSB0aGlzLl9qUSA9ICQoJzxzcGFuIGNsYXNzPVwibXEtY3Vyc29yXCI+JiM4MjAzOzwvc3Bhbj4nKTtcbiAgICAvL2Nsb3N1cmVkIGZvciBzZXRJbnRlcnZhbFxuICAgIHRoaXMuYmxpbmsgPSBmdW5jdGlvbigpeyBqUS50b2dnbGVDbGFzcygnbXEtYmxpbmsnKTsgfTtcblxuICAgIHRoaXMudXBEb3duQ2FjaGUgPSB7fTtcbiAgfTtcblxuICBfLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmpRID0gdGhpcy5falEucmVtb3ZlQ2xhc3MoJ21xLWJsaW5rJyk7XG4gICAgaWYgKCdpbnRlcnZhbElkJyBpbiB0aGlzKSAvL2FscmVhZHkgd2FzIHNob3duLCBqdXN0IHJlc3RhcnQgaW50ZXJ2YWxcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICBlbHNlIHsgLy93YXMgaGlkZGVuIGFuZCBkZXRhY2hlZCwgaW5zZXJ0IHRoaXMualEgYmFjayBpbnRvIEhUTUwgRE9NXG4gICAgICBpZiAodGhpc1tSXSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5zZWxlY3Rpb24uZW5kc1tMXVtMXSA9PT0gdGhpc1tMXSlcbiAgICAgICAgICB0aGlzLmpRLmluc2VydEJlZm9yZSh0aGlzLnNlbGVjdGlvbi5qUSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLmpRLmluc2VydEJlZm9yZSh0aGlzW1JdLmpRLmZpcnN0KCkpO1xuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLmpRLmFwcGVuZFRvKHRoaXMucGFyZW50LmpRKTtcbiAgICAgIHRoaXMucGFyZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRoaXMuYmxpbmssIDUwMCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF8uaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgnaW50ZXJ2YWxJZCcgaW4gdGhpcylcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICBkZWxldGUgdGhpcy5pbnRlcnZhbElkO1xuICAgIHRoaXMualEuZGV0YWNoKCk7XG4gICAgdGhpcy5qUSA9ICQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfLndpdGhEaXJJbnNlcnRBdCA9IGZ1bmN0aW9uKGRpciwgcGFyZW50LCB3aXRoRGlyLCBvcHBEaXIpIHtcbiAgICB2YXIgb2xkUGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpc1tkaXJdID0gd2l0aERpcjtcbiAgICB0aGlzWy1kaXJdID0gb3BwRGlyO1xuICAgIC8vIGJ5IGNvbnRyYWN0LCAuYmx1cigpIGlzIGNhbGxlZCBhZnRlciBhbGwgaGFzIGJlZW4gc2FpZCBhbmQgZG9uZVxuICAgIC8vIGFuZCB0aGUgY3Vyc29yIGhhcyBhY3R1YWxseSBiZWVuIG1vdmVkXG4gICAgaWYgKG9sZFBhcmVudCAhPT0gcGFyZW50ICYmIG9sZFBhcmVudC5ibHVyKSBvbGRQYXJlbnQuYmx1cigpO1xuICB9O1xuICBfLmluc0Rpck9mID0gZnVuY3Rpb24oZGlyLCBlbCkge1xuICAgIHByYXlEaXJlY3Rpb24oZGlyKTtcbiAgICB0aGlzLmpRLmluc0Rpck9mKGRpciwgZWwualEpO1xuICAgIHRoaXMud2l0aERpckluc2VydEF0KGRpciwgZWwucGFyZW50LCBlbFtkaXJdLCBlbCk7XG4gICAgdGhpcy5wYXJlbnQualEuYWRkQ2xhc3MoJ21xLWhhc0N1cnNvcicpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfLmluc0xlZnRPZiA9IGZ1bmN0aW9uKGVsKSB7IHJldHVybiB0aGlzLmluc0Rpck9mKEwsIGVsKTsgfTtcbiAgXy5pbnNSaWdodE9mID0gZnVuY3Rpb24oZWwpIHsgcmV0dXJuIHRoaXMuaW5zRGlyT2YoUiwgZWwpOyB9O1xuXG4gIF8uaW5zQXREaXJFbmQgPSBmdW5jdGlvbihkaXIsIGVsKSB7XG4gICAgcHJheURpcmVjdGlvbihkaXIpO1xuICAgIHRoaXMualEuaW5zQXREaXJFbmQoZGlyLCBlbC5qUSk7XG4gICAgdGhpcy53aXRoRGlySW5zZXJ0QXQoZGlyLCBlbCwgMCwgZWwuZW5kc1tkaXJdKTtcbiAgICBlbC5mb2N1cygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfLmluc0F0TGVmdEVuZCA9IGZ1bmN0aW9uKGVsKSB7IHJldHVybiB0aGlzLmluc0F0RGlyRW5kKEwsIGVsKTsgfTtcbiAgXy5pbnNBdFJpZ2h0RW5kID0gZnVuY3Rpb24oZWwpIHsgcmV0dXJuIHRoaXMuaW5zQXREaXJFbmQoUiwgZWwpOyB9O1xuXG4gIC8qKlxuICAgKiBqdW1wIHVwIG9yIGRvd24gZnJvbSBvbmUgYmxvY2sgTm9kZSB0byBhbm90aGVyOlxuICAgKiAtIGNhY2hlIHRoZSBjdXJyZW50IFBvaW50IGluIHRoZSBub2RlIHdlJ3JlIGp1bXBpbmcgZnJvbVxuICAgKiAtIGNoZWNrIGlmIHRoZXJlJ3MgYSBQb2ludCBpbiBpdCBjYWNoZWQgZm9yIHRoZSBub2RlIHdlJ3JlIGp1bXBpbmcgdG9cbiAgICogICArIGlmIHNvIHB1dCB0aGUgY3Vyc29yIHRoZXJlLFxuICAgKiAgICsgaWYgbm90IHNlZWsgYSBwb3NpdGlvbiBpbiB0aGUgbm9kZSB0aGF0IGlzIGhvcml6b250YWxseSBjbG9zZXN0IHRvXG4gICAqICAgICB0aGUgY3Vyc29yJ3MgY3VycmVudCBwb3NpdGlvblxuICAgKi9cbiAgXy5qdW1wVXBEb3duID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi51cERvd25DYWNoZVtmcm9tLmlkXSA9IFBvaW50LmNvcHkoc2VsZik7XG4gICAgdmFyIGNhY2hlZCA9IHNlbGYudXBEb3duQ2FjaGVbdG8uaWRdO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIGNhY2hlZFtSXSA/IHNlbGYuaW5zTGVmdE9mKGNhY2hlZFtSXSkgOiBzZWxmLmluc0F0UmlnaHRFbmQoY2FjaGVkLnBhcmVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhZ2VYID0gc2VsZi5vZmZzZXQoKS5sZWZ0O1xuICAgICAgdG8uc2VlayhwYWdlWCwgc2VsZik7XG4gICAgfVxuICB9O1xuICBfLm9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vaW4gT3BlcmEgMTEuNjIsIC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBhbmQgaGVuY2UgalF1ZXJ5OjpvZmZzZXQoKVxuICAgIC8vcmV0dXJucyBhbGwgMCdzIG9uIGlubGluZSBlbGVtZW50cyB3aXRoIG5lZ2F0aXZlIG1hcmdpbi1yaWdodCAobGlrZVxuICAgIC8vdGhlIGN1cnNvcikgYXQgdGhlIGVuZCBvZiB0aGVpciBwYXJlbnQsIHNvIHRlbXBvcmFyaWx5IHJlbW92ZSB0aGVcbiAgICAvL25lZ2F0aXZlIG1hcmdpbi1yaWdodCB3aGVuIGNhbGxpbmcgalF1ZXJ5OjpvZmZzZXQoKVxuICAgIC8vT3BlcmEgYnVnIERTSy0zNjAwNDNcbiAgICAvL2h0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzExNTIzXG4gICAgLy9odHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzcxN1xuICAgIHZhciBzZWxmID0gdGhpcywgb2Zmc2V0ID0gc2VsZi5qUS5yZW1vdmVDbGFzcygnbXEtY3Vyc29yJykub2Zmc2V0KCk7XG4gICAgc2VsZi5qUS5hZGRDbGFzcygnbXEtY3Vyc29yJyk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuICBfLnVud3JhcEdyYW1wID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdyYW1wID0gdGhpcy5wYXJlbnQucGFyZW50O1xuICAgIHZhciBncmVhdGdyYW1wID0gZ3JhbXAucGFyZW50O1xuICAgIHZhciByaWdodHdhcmQgPSBncmFtcFtSXTtcbiAgICB2YXIgY3Vyc29yID0gdGhpcztcblxuICAgIHZhciBsZWZ0d2FyZCA9IGdyYW1wW0xdO1xuICAgIGdyYW1wLmRpc293bigpLmVhY2hDaGlsZChmdW5jdGlvbih1bmNsZSkge1xuICAgICAgaWYgKHVuY2xlLmlzRW1wdHkoKSkgcmV0dXJuO1xuXG4gICAgICB1bmNsZS5jaGlsZHJlbigpXG4gICAgICAgIC5hZG9wdChncmVhdGdyYW1wLCBsZWZ0d2FyZCwgcmlnaHR3YXJkKVxuICAgICAgICAuZWFjaChmdW5jdGlvbihjb3VzaW4pIHtcbiAgICAgICAgICBjb3VzaW4ualEuaW5zZXJ0QmVmb3JlKGdyYW1wLmpRLmZpcnN0KCkpO1xuICAgICAgICB9KVxuICAgICAgO1xuXG4gICAgICBsZWZ0d2FyZCA9IHVuY2xlLmVuZHNbUl07XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXNbUl0pIHsgLy90aGVuIGZpbmQgc29tZXRoaW5nIHRvIGJlIHJpZ2h0d2FyZCB0byBpbnNMZWZ0T2ZcbiAgICAgIGlmICh0aGlzW0xdKVxuICAgICAgICB0aGlzW1JdID0gdGhpc1tMXVtSXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAoIXRoaXNbUl0pIHtcbiAgICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMucGFyZW50W1JdO1xuICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHRoaXNbUl0gPSB0aGlzLnBhcmVudC5lbmRzW0xdO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tSXSA9IGdyYW1wW1JdO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBncmVhdGdyYW1wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzW1JdKVxuICAgICAgdGhpcy5pbnNMZWZ0T2YodGhpc1tSXSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5pbnNBdFJpZ2h0RW5kKGdyZWF0Z3JhbXApO1xuXG4gICAgZ3JhbXAualEucmVtb3ZlKCk7XG5cbiAgICBpZiAoZ3JhbXBbTF0uc2libGluZ0RlbGV0ZWQpIGdyYW1wW0xdLnNpYmxpbmdEZWxldGVkKGN1cnNvci5vcHRpb25zLCBSKTtcbiAgICBpZiAoZ3JhbXBbUl0uc2libGluZ0RlbGV0ZWQpIGdyYW1wW1JdLnNpYmxpbmdEZWxldGVkKGN1cnNvci5vcHRpb25zLCBMKTtcbiAgfTtcbiAgXy5zdGFydFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhbnRpY3Vyc29yID0gdGhpcy5hbnRpY3Vyc29yID0gUG9pbnQuY29weSh0aGlzKTtcbiAgICB2YXIgYW5jZXN0b3JzID0gYW50aWN1cnNvci5hbmNlc3RvcnMgPSB7fTsgLy8gYSBtYXAgZnJvbSBlYWNoIGFuY2VzdG9yIG9mXG4gICAgICAvLyB0aGUgYW50aWN1cnNvciwgdG8gaXRzIGNoaWxkIHRoYXQgaXMgYWxzbyBhbiBhbmNlc3RvcjsgaW4gb3RoZXIgd29yZHMsXG4gICAgICAvLyB0aGUgYW50aWN1cnNvcidzIGFuY2VzdG9yIGNoYWluIGluIHJldmVyc2Ugb3JkZXJcbiAgICBmb3IgKHZhciBhbmNlc3RvciA9IGFudGljdXJzb3I7IGFuY2VzdG9yLnBhcmVudDsgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQpIHtcbiAgICAgIGFuY2VzdG9yc1thbmNlc3Rvci5wYXJlbnQuaWRdID0gYW5jZXN0b3I7XG4gICAgfVxuICB9O1xuICBfLmVuZFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzLmFudGljdXJzb3I7XG4gIH07XG4gIF8uc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFudGljdXJzb3IgPSB0aGlzLmFudGljdXJzb3I7XG4gICAgaWYgKHRoaXNbTF0gPT09IGFudGljdXJzb3JbTF0gJiYgdGhpcy5wYXJlbnQgPT09IGFudGljdXJzb3IucGFyZW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBGaW5kIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIChgbGNhYCksIGFuZCB0aGUgYW5jZXN0b3Igb2YgdGhlIGN1cnNvclxuICAgIC8vIHdob3NlIHBhcmVudCBpcyB0aGUgTENBICh3aGljaCdsbCBiZSBhbiBlbmQgb2YgdGhlIHNlbGVjdGlvbiBmcmFnbWVudCkuXG4gICAgZm9yICh2YXIgYW5jZXN0b3IgPSB0aGlzOyBhbmNlc3Rvci5wYXJlbnQ7IGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50KSB7XG4gICAgICBpZiAoYW5jZXN0b3IucGFyZW50LmlkIGluIGFudGljdXJzb3IuYW5jZXN0b3JzKSB7XG4gICAgICAgIHZhciBsY2EgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmF5KCdjdXJzb3IgYW5kIGFudGljdXJzb3IgaW4gdGhlIHNhbWUgdHJlZScsIGxjYSk7XG4gICAgLy8gVGhlIGN1cnNvciBhbmQgdGhlIGFudGljdXJzb3Igc2hvdWxkIGJlIGluIHRoZSBzYW1lIHRyZWUsIGJlY2F1c2UgdGhlXG4gICAgLy8gbW91c2Vtb3ZlIGhhbmRsZXIgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LCB1bmxpa2UgdGhlIG9uZSBhdHRhY2hlZCB0b1xuICAgIC8vIHRoZSByb290IEhUTUwgRE9NIGVsZW1lbnQsIGRvZXNuJ3QgdHJ5IHRvIGdldCB0aGUgbWF0aCB0cmVlIG5vZGUgb2YgdGhlXG4gICAgLy8gbW91c2Vtb3ZlIHRhcmdldCwgYW5kIEN1cnNvcjo6c2VlaygpIGJhc2VkIHNvbGVseSBvbiBjb29yZGluYXRlcyBzdGF5c1xuICAgIC8vIHdpdGhpbiB0aGUgdHJlZSBvZiBgdGhpc2AgY3Vyc29yJ3Mgcm9vdC5cblxuICAgIC8vIFRoZSBvdGhlciBlbmQgb2YgdGhlIHNlbGVjdGlvbiBmcmFnbWVudCwgdGhlIGFuY2VzdG9yIG9mIHRoZSBhbnRpY3Vyc29yXG4gICAgLy8gd2hvc2UgcGFyZW50IGlzIHRoZSBMQ0EuXG4gICAgdmFyIGFudGlBbmNlc3RvciA9IGFudGljdXJzb3IuYW5jZXN0b3JzW2xjYS5pZF07XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSB0d28gZWl0aGVyIE5vZGVzIG9yIFBvaW50cywgZ3VhcmFudGVlZCB0byBoYXZlIGEgY29tbW9uXG4gICAgLy8gcGFyZW50IGFuZCBndWFyYW50ZWVkIHRoYXQgaWYgYm90aCBhcmUgUG9pbnRzLCB0aGV5IGFyZSBub3QgdGhlIHNhbWUsXG4gICAgLy8gYW5kIHdlIGhhdmUgdG8gZmlndXJlIG91dCB3aGljaCBpcyB0aGUgbGVmdCBlbmQgYW5kIHdoaWNoIHRoZSByaWdodCBlbmRcbiAgICAvLyBvZiB0aGUgc2VsZWN0aW9uLlxuICAgIHZhciBsZWZ0RW5kLCByaWdodEVuZCwgZGlyID0gUjtcblxuICAgIC8vIFRoaXMgaXMgYW4gZXh0cmVtZWx5IHN1YnRsZSBhbGdvcml0aG0uXG4gICAgLy8gQXMgYSBzcGVjaWFsIGNhc2UsIGBhbmNlc3RvcmAgY291bGQgYmUgYSBQb2ludCBhbmQgYGFudGlBbmNlc3RvcmAgYSBOb2RlXG4gICAgLy8gaW1tZWRpYXRlbHkgdG8gYGFuY2VzdG9yYCdzIGxlZnQuXG4gICAgLy8gSW4gYWxsIG90aGVyIGNhc2VzLFxuICAgIC8vIC0gYm90aCBOb2Rlc1xuICAgIC8vIC0gYGFuY2VzdG9yYCBhIFBvaW50IGFuZCBgYW50aUFuY2VzdG9yYCBhIE5vZGVcbiAgICAvLyAtIGBhbmNlc3RvcmAgYSBOb2RlIGFuZCBgYW50aUFuY2VzdG9yYCBhIFBvaW50XG4gICAgLy8gYGFudGlBbmNlc3RvcltSXSA9PT0gcmlnaHR3YXJkW1JdYCBmb3Igc29tZSBgcmlnaHR3YXJkYCB0aGF0IGlzXG4gICAgLy8gYGFuY2VzdG9yYCBvciB0byBpdHMgcmlnaHQsIGlmIGFuZCBvbmx5IGlmIGBhbnRpQW5jZXN0b3JgIGlzIHRvXG4gICAgLy8gdGhlIHJpZ2h0IG9mIGBhbmNlc3RvcmAuXG4gICAgaWYgKGFuY2VzdG9yW0xdICE9PSBhbnRpQW5jZXN0b3IpIHtcbiAgICAgIGZvciAodmFyIHJpZ2h0d2FyZCA9IGFuY2VzdG9yOyByaWdodHdhcmQ7IHJpZ2h0d2FyZCA9IHJpZ2h0d2FyZFtSXSkge1xuICAgICAgICBpZiAocmlnaHR3YXJkW1JdID09PSBhbnRpQW5jZXN0b3JbUl0pIHtcbiAgICAgICAgICBkaXIgPSBMO1xuICAgICAgICAgIGxlZnRFbmQgPSBhbmNlc3RvcjtcbiAgICAgICAgICByaWdodEVuZCA9IGFudGlBbmNlc3RvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlyID09PSBSKSB7XG4gICAgICBsZWZ0RW5kID0gYW50aUFuY2VzdG9yO1xuICAgICAgcmlnaHRFbmQgPSBhbmNlc3RvcjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHdhbnQgdG8gc2VsZWN0IE5vZGVzIHVwIHRvIFBvaW50cywgY2FuJ3Qgc2VsZWN0IFBvaW50cyB0aGVtc2VsdmVzXG4gICAgaWYgKGxlZnRFbmQgaW5zdGFuY2VvZiBQb2ludCkgbGVmdEVuZCA9IGxlZnRFbmRbUl07XG4gICAgaWYgKHJpZ2h0RW5kIGluc3RhbmNlb2YgUG9pbnQpIHJpZ2h0RW5kID0gcmlnaHRFbmRbTF07XG5cbiAgICB0aGlzLmhpZGUoKS5zZWxlY3Rpb24gPSBsY2Euc2VsZWN0Q2hpbGRyZW4obGVmdEVuZCwgcmlnaHRFbmQpO1xuICAgIHRoaXMuaW5zRGlyT2YoZGlyLCB0aGlzLnNlbGVjdGlvbi5lbmRzW2Rpcl0pO1xuICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF8uY2xlYXJTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb247XG4gICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF8uZGVsZXRlU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNlbGVjdGlvbikgcmV0dXJuO1xuXG4gICAgdGhpc1tMXSA9IHRoaXMuc2VsZWN0aW9uLmVuZHNbTF1bTF07XG4gICAgdGhpc1tSXSA9IHRoaXMuc2VsZWN0aW9uLmVuZHNbUl1bUl07XG4gICAgdGhpcy5zZWxlY3Rpb24ucmVtb3ZlKCk7XG4gICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uO1xuICB9O1xuICBfLnJlcGxhY2VTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgIGlmIChzZWxuKSB7XG4gICAgICB0aGlzW0xdID0gc2Vsbi5lbmRzW0xdW0xdO1xuICAgICAgdGhpc1tSXSA9IHNlbG4uZW5kc1tSXVtSXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHNlbG47XG4gIH07XG59KTtcblxudmFyIFNlbGVjdGlvbiA9IFAoRnJhZ21lbnQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBzdXBlcl8uaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMualEgPSB0aGlzLmpRLndyYXBBbGwoJzxzcGFuIGNsYXNzPVwibXEtc2VsZWN0aW9uXCI+PC9zcGFuPicpLnBhcmVudCgpO1xuICAgICAgLy9jYW4ndCBkbyB3cmFwQWxsKHRoaXMualEgPSAkKC4uLikpIGJlY2F1c2Ugd3JhcEFsbCB3aWxsIGNsb25lIGl0XG4gIH07XG4gIF8uYWRvcHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmpRLnJlcGxhY2VXaXRoKHRoaXMualEgPSB0aGlzLmpRLmNoaWxkcmVuKCkpO1xuICAgIHJldHVybiBzdXBlcl8uYWRvcHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgXy5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVzaW5nIHRoZSBicm93c2VyJ3MgbmF0aXZlIC5jaGlsZE5vZGVzIHByb3BlcnR5IHNvIHRoYXQgd2VcbiAgICAvLyBkb24ndCBkaXNjYXJkIHRleHQgbm9kZXMuXG4gICAgdGhpcy5qUS5yZXBsYWNlV2l0aCh0aGlzLmpRWzBdLmNoaWxkTm9kZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfLmpvaW4gPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9sZCgnJywgZnVuY3Rpb24oZm9sZCwgY2hpbGQpIHtcbiAgICAgIHJldHVybiBmb2xkICsgY2hpbGRbbWV0aG9kTmFtZV0oKTtcbiAgICB9KTtcbiAgfTtcbn0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29udHJvbGxlciBmb3IgYSBNYXRoUXVpbGwgaW5zdGFuY2UsXG4gKiBvbiB3aGljaCBzZXJ2aWNlcyBhcmUgcmVnaXN0ZXJlZCB3aXRoXG4gKlxuICogICBDb250cm9sbGVyLm9wZW4oZnVuY3Rpb24oXykgeyAuLi4gfSk7XG4gKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgQ29udHJvbGxlciA9IFAoZnVuY3Rpb24oXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihyb290LCBjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkID0gcm9vdC5pZDtcbiAgICB0aGlzLmRhdGEgPSB7fTtcblxuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHJvb3QuY29udHJvbGxlciA9IHRoaXM7XG5cbiAgICB0aGlzLmN1cnNvciA9IHJvb3QuY3Vyc29yID0gQ3Vyc29yKHJvb3QsIG9wdGlvbnMpO1xuICAgIC8vIFRPRE86IHN0b3AgZGVwZW5kaW5nIG9uIHJvb3QuY3Vyc29yLCBhbmQgcm0gaXRcbiAgfTtcblxuICBfLmhhbmRsZSA9IGZ1bmN0aW9uKG5hbWUsIGRpcikge1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMub3B0aW9ucy5oYW5kbGVycztcbiAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMuZm5zW25hbWVdKSB7XG4gICAgICB2YXIgbXEgPSBoYW5kbGVycy5BUElDbGFzc2VzW3RoaXMuS0lORF9PRl9NUV0odGhpcyk7XG4gICAgICBpZiAoZGlyID09PSBMIHx8IGRpciA9PT0gUikgaGFuZGxlcnMuZm5zW25hbWVdKGRpciwgbXEpO1xuICAgICAgZWxzZSBoYW5kbGVycy5mbnNbbmFtZV0obXEpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbm90aWZ5ZWVzID0gW107XG4gIHRoaXMub25Ob3RpZnkgPSBmdW5jdGlvbihmKSB7IG5vdGlmeWVlcy5wdXNoKGYpOyB9O1xuICBfLm5vdGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90aWZ5ZWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBub3RpZnllZXNbaV0uYXBwbHkodGhpcy5jdXJzb3IsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBUaGUgcHVibGljbHkgZXhwb3NlZCBNYXRoUXVpbGwgQVBJLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgQVBJID0ge30sIE9wdGlvbnMgPSBQKCksIG9wdGlvblByb2Nlc3NvcnMgPSB7fSwgUHJvZ2Vub3RlID0gUCgpLCBFTUJFRFMgPSB7fTtcblxuLyoqXG4gKiBJbnRlcmZhY2UgVmVyc2lvbmluZyAoIzQ1OSwgIzQ5NSkgdG8gYWxsb3cgdXMgdG8gdmlydHVhbGx5IGd1YXJhbnRlZVxuICogYmFja2NvbXBhdC4gdjAuMTAueCBpbnRyb2R1Y2VzIGl0LCBzbyBmb3Igbm93LCBkb24ndCBjb21wbGV0ZWx5IGJyZWFrIHRoZVxuICogQVBJIGZvciBwZW9wbGUgd2hvIGRvbid0IGtub3cgYWJvdXQgaXQsIGp1c3QgY29tcGxhaW4gd2l0aCBjb25zb2xlLndhcm4oKS5cbiAqXG4gKiBUaGUgbWV0aG9kcyBhcmUgc2hpbW1lZCBpbiBvdXRyby5qcyBzbyB0aGF0IE1RLk1hdGhGaWVsZC5wcm90b3R5cGUgZXRjIGNhblxuICogYmUgYWNjZXNzZWQuXG4gKi9cbmZ1bmN0aW9uIGluc2lzdE9uSW50ZXJWZXIoKSB7XG4gIGlmICh3aW5kb3cuY29uc29sZSkgY29uc29sZS53YXJuKFxuICAgICdZb3UgYXJlIHVzaW5nIHRoZSBNYXRoUXVpbGwgQVBJIHdpdGhvdXQgc3BlY2lmeWluZyBhbiBpbnRlcmZhY2UgdmVyc2lvbiwgJyArXG4gICAgJ3doaWNoIHdpbGwgZmFpbCBpbiB2MS4wLjAuIFlvdSBjYW4gZml4IHRoaXMgZWFzaWx5IGJ5IGRvaW5nIHRoaXMgYmVmb3JlICcgK1xuICAgICdkb2luZyBhbnl0aGluZyBlbHNlOlxcbicgK1xuICAgICdcXG4nICtcbiAgICAnICAgIE1hdGhRdWlsbCA9IE1hdGhRdWlsbC5nZXRJbnRlcmZhY2UoMSk7XFxuJyArXG4gICAgJyAgICAvLyBub3cgTWF0aFF1aWxsLk1hdGhGaWVsZCgpIHdvcmtzIGxpa2UgaXQgdXNlZCB0b1xcbicgK1xuICAgICdcXG4nICtcbiAgICAnU2VlIGFsc28gdGhlIFwiYGRldmAgYnJhbmNoICgyMDE0XFx1MjAxMzIwMTUpIFxcdTIxOTIgdjAuMTAuMCBNaWdyYXRpb24gR3VpZGVcIiBhdFxcbicgK1xuICAgICcgIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRocXVpbGwvbWF0aHF1aWxsL3dpa2kvJTYwZGV2JTYwLWJyYW5jaC0oMjAxNCVFMiU4MCU5MzIwMTUpLSVFMiU4NiU5Mi12MC4xMC4wLU1pZ3JhdGlvbi1HdWlkZSdcbiAgKTtcbn1cbi8vIGdsb2JhbGx5IGV4cG9ydGVkIEFQSSBvYmplY3RcbmZ1bmN0aW9uIE1hdGhRdWlsbChlbCkge1xuICBpbnNpc3RPbkludGVyVmVyKCk7XG4gIHJldHVybiBNUTEoZWwpO1xufTtcbk1hdGhRdWlsbC5wcm90b3R5cGUgPSBQcm9nZW5vdGUucDtcbk1hdGhRdWlsbC5pbnRlcmZhY2VWZXJzaW9uID0gZnVuY3Rpb24odikge1xuICAvLyBzaGltIGZvciAjNDU5LWVyYSBpbnRlcmZhY2UgdmVyc2lvbmluZyAoZW5kZWQgd2l0aCAjNDk1KVxuICBpZiAodiAhPT0gMSkgdGhyb3cgJ09ubHkgaW50ZXJmYWNlIHZlcnNpb24gMSBzdXBwb3J0ZWQuIFlvdSBzcGVjaWZpZWQ6ICcgKyB2O1xuICBpbnNpc3RPbkludGVyVmVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdpbmRvdy5jb25zb2xlKSBjb25zb2xlLndhcm4oXG4gICAgICAnWW91IGNhbGxlZCBNYXRoUXVpbGwuaW50ZXJmYWNlVmVyc2lvbigxKTsgdG8gc3BlY2lmeSB0aGUgaW50ZXJmYWNlICcgK1xuICAgICAgJ3ZlcnNpb24sIHdoaWNoIHdpbGwgZmFpbCBpbiB2MS4wLjAuIFlvdSBjYW4gZml4IHRoaXMgZWFzaWx5IGJ5IGRvaW5nICcgK1xuICAgICAgJ3RoaXMgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2U6XFxuJyArXG4gICAgICAnXFxuJyArXG4gICAgICAnICAgIE1hdGhRdWlsbCA9IE1hdGhRdWlsbC5nZXRJbnRlcmZhY2UoMSk7XFxuJyArXG4gICAgICAnICAgIC8vIG5vdyBNYXRoUXVpbGwuTWF0aEZpZWxkKCkgd29ya3MgbGlrZSBpdCB1c2VkIHRvXFxuJyArXG4gICAgICAnXFxuJyArXG4gICAgICAnU2VlIGFsc28gdGhlIFwiYGRldmAgYnJhbmNoICgyMDE0XFx1MjAxMzIwMTUpIFxcdTIxOTIgdjAuMTAuMCBNaWdyYXRpb24gR3VpZGVcIiBhdFxcbicgK1xuICAgICAgJyAgaHR0cHM6Ly9naXRodWIuY29tL21hdGhxdWlsbC9tYXRocXVpbGwvd2lraS8lNjBkZXYlNjAtYnJhbmNoLSgyMDE0JUUyJTgwJTkzMjAxNSktJUUyJTg2JTkyLXYwLjEwLjAtTWlncmF0aW9uLUd1aWRlJ1xuICAgICk7XG4gIH07XG4gIGluc2lzdE9uSW50ZXJWZXIoKTtcbiAgcmV0dXJuIE1hdGhRdWlsbDtcbn07XG5NYXRoUXVpbGwuZ2V0SW50ZXJmYWNlID0gZ2V0SW50ZXJmYWNlO1xuXG52YXIgTUlOID0gZ2V0SW50ZXJmYWNlLk1JTiA9IDEsIE1BWCA9IGdldEludGVyZmFjZS5NQVggPSAyO1xuZnVuY3Rpb24gZ2V0SW50ZXJmYWNlKHYpIHtcbiAgaWYgKCEoTUlOIDw9IHYgJiYgdiA8PSBNQVgpKSB0aHJvdyAnT25seSBpbnRlcmZhY2UgdmVyc2lvbnMgYmV0d2VlbiAnICtcbiAgICBNSU4gKyAnIGFuZCAnICsgTUFYICsgJyBzdXBwb3J0ZWQuIFlvdSBzcGVjaWZpZWQ6ICcgKyB2O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHRha2VzIGFuIEhUTUwgZWxlbWVudCBhbmQsIGlmIGl0J3MgdGhlIHJvb3QgSFRNTCBlbGVtZW50IG9mIGFcbiAgICogc3RhdGljIG1hdGggb3IgbWF0aCBvciB0ZXh0IGZpZWxkLCByZXR1cm5zIGFuIEFQSSBvYmplY3QgZm9yIGl0IChlbHNlLCBudWxsKS5cbiAgICpcbiAgICogICB2YXIgbWF0aGZpZWxkID0gTVEuTWF0aEZpZWxkKG1hdGhGaWVsZFNwYW4pO1xuICAgKiAgIGFzc2VydChNUShtYXRoRmllbGRTcGFuKS5pZCA9PT0gbWF0aGZpZWxkLmlkKTtcbiAgICogICBhc3NlcnQoTVEobWF0aEZpZWxkU3BhbikuaWQgPT09IE1RKG1hdGhGaWVsZFNwYW4pLmlkKTtcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIE1RKGVsKSB7XG4gICAgaWYgKCFlbCB8fCAhZWwubm9kZVR5cGUpIHJldHVybiBudWxsOyAvLyBjaGVjayB0aGF0IGBlbGAgaXMgYSBIVE1MIGVsZW1lbnQsIHVzaW5nIHRoZVxuICAgICAgLy8gc2FtZSB0ZWNobmlxdWUgYXMgalF1ZXJ5OiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzY3OTUzNmVlNGI3YTkyYWU2NGE1ZjU4ZDkwZTljYzM4YzAwMWU4MDcvc3JjL2NvcmUvaW5pdC5qcyNMOTJcbiAgICB2YXIgYmxvY2tJZCA9ICQoZWwpLmNoaWxkcmVuKCcubXEtcm9vdC1ibG9jaycpLmF0dHIobXFCbG9ja0lkKTtcbiAgICB2YXIgY3RybHIgPSBibG9ja0lkICYmIE5vZGUuYnlJZFtibG9ja0lkXS5jb250cm9sbGVyO1xuICAgIHJldHVybiBjdHJsciA/IEFQSUNsYXNzZXNbY3RybHIuS0lORF9PRl9NUV0oY3RybHIpIDogbnVsbDtcbiAgfTtcbiAgdmFyIEFQSUNsYXNzZXMgPSB7fTtcblxuICBNUS5MID0gTDtcbiAgTVEuUiA9IFI7XG5cbiAgZnVuY3Rpb24gY29uZmlnKGN1cnJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKG5ld09wdGlvbnMgJiYgbmV3T3B0aW9ucy5oYW5kbGVycykge1xuICAgICAgbmV3T3B0aW9ucy5oYW5kbGVycyA9IHsgZm5zOiBuZXdPcHRpb25zLmhhbmRsZXJzLCBBUElDbGFzc2VzOiBBUElDbGFzc2VzIH07XG4gICAgfVxuICAgIGZvciAodmFyIG5hbWUgaW4gbmV3T3B0aW9ucykgaWYgKG5ld09wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG5ld09wdGlvbnNbbmFtZV0sIHByb2Nlc3NvciA9IG9wdGlvblByb2Nlc3NvcnNbbmFtZV07XG4gICAgICBjdXJyZW50T3B0aW9uc1tuYW1lXSA9IChwcm9jZXNzb3IgPyBwcm9jZXNzb3IodmFsdWUpIDogdmFsdWUpO1xuICAgIH1cbiAgfVxuICBNUS5jb25maWcgPSBmdW5jdGlvbihvcHRzKSB7IGNvbmZpZyhPcHRpb25zLnAsIG9wdHMpOyByZXR1cm4gdGhpczsgfTtcbiAgTVEucmVnaXN0ZXJFbWJlZCA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIS9eW2Etel1bYS16MC05XSokL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgJ0VtYmVkIG5hbWUgbXVzdCBzdGFydCB3aXRoIGxldHRlciBhbmQgYmUgb25seSBsZXR0ZXJzIGFuZCBkaWdpdHMnO1xuICAgIH1cbiAgICBFTUJFRFNbbmFtZV0gPSBvcHRpb25zO1xuICB9O1xuXG4gIHZhciBBYnN0cmFjdE1hdGhRdWlsbCA9IEFQSUNsYXNzZXMuQWJzdHJhY3RNYXRoUXVpbGwgPSBQKFByb2dlbm90ZSwgZnVuY3Rpb24oXykge1xuICAgIF8uaW5pdCA9IGZ1bmN0aW9uKGN0cmxyKSB7XG4gICAgICB0aGlzLl9fY29udHJvbGxlciA9IGN0cmxyO1xuICAgICAgdGhpcy5fX29wdGlvbnMgPSBjdHJsci5vcHRpb25zO1xuICAgICAgdGhpcy5pZCA9IGN0cmxyLmlkO1xuICAgICAgdGhpcy5kYXRhID0gY3RybHIuZGF0YTtcbiAgICB9O1xuICAgIF8uX19tYXRocXVpbGxpZnkgPSBmdW5jdGlvbihjbGFzc05hbWVzKSB7XG4gICAgICB2YXIgY3RybHIgPSB0aGlzLl9fY29udHJvbGxlciwgcm9vdCA9IGN0cmxyLnJvb3QsIGVsID0gY3RybHIuY29udGFpbmVyO1xuICAgICAgY3RybHIuY3JlYXRlVGV4dGFyZWEoKTtcblxuICAgICAgdmFyIGNvbnRlbnRzID0gZWwuYWRkQ2xhc3MoY2xhc3NOYW1lcykuY29udGVudHMoKS5kZXRhY2goKTtcbiAgICAgIHJvb3QualEgPVxuICAgICAgICAkKCc8c3BhbiBjbGFzcz1cIm1xLXJvb3QtYmxvY2tcIi8+JykuYXR0cihtcUJsb2NrSWQsIHJvb3QuaWQpLmFwcGVuZFRvKGVsKTtcbiAgICAgIHRoaXMubGF0ZXgoY29udGVudHMudGV4dCgpKTtcblxuICAgICAgdGhpcy5yZXZlcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGVsLmVtcHR5KCkudW5iaW5kKCcubWF0aHF1aWxsJylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdtcS1lZGl0YWJsZS1maWVsZCBtcS1tYXRoLW1vZGUgbXEtdGV4dC1tb2RlJylcbiAgICAgICAgLmFwcGVuZChjb250ZW50cyk7XG4gICAgICB9O1xuICAgIH07XG4gICAgXy5jb25maWcgPSBmdW5jdGlvbihvcHRzKSB7IGNvbmZpZyh0aGlzLl9fb3B0aW9ucywgb3B0cyk7IHJldHVybiB0aGlzOyB9O1xuICAgIF8uZWwgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX19jb250cm9sbGVyLmNvbnRhaW5lclswXTsgfTtcbiAgICBfLnRleHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX19jb250cm9sbGVyLmV4cG9ydFRleHQoKTsgfTtcbiAgICBfLmxhdGV4ID0gZnVuY3Rpb24obGF0ZXgpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl9fY29udHJvbGxlci5yZW5kZXJMYXRleE1hdGgobGF0ZXgpO1xuICAgICAgICBpZiAodGhpcy5fX2NvbnRyb2xsZXIuYmx1cnJlZCkgdGhpcy5fX2NvbnRyb2xsZXIuY3Vyc29yLmhpZGUoKS5wYXJlbnQuYmx1cigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9fY29udHJvbGxlci5leHBvcnRMYXRleCgpO1xuICAgIH07XG4gICAgXy5odG1sID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2NvbnRyb2xsZXIucm9vdC5qUS5odG1sKClcbiAgICAgICAgLnJlcGxhY2UoLyBtYXRocXVpbGwtKD86Y29tbWFuZHxibG9jayktaWQ9XCI/XFxkK1wiPy9nLCAnJylcbiAgICAgICAgLnJlcGxhY2UoLzxzcGFuIGNsYXNzPVwiP21xLWN1cnNvciggbXEtYmxpbmspP1wiPz4uPzxcXC9zcGFuPi9pLCAnJylcbiAgICAgICAgLnJlcGxhY2UoLyBtcS1oYXNDdXJzb3J8bXEtaGFzQ3Vyc29yID8vLCAnJylcbiAgICAgICAgLnJlcGxhY2UoLyBjbGFzcz0oXCJcInwoPz0gfD4pKS9nLCAnJyk7XG4gICAgfTtcbiAgICBfLnJlZmxvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2NvbnRyb2xsZXIucm9vdC5wb3N0T3JkZXIoJ3JlZmxvdycpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSk7XG4gIE1RLnByb3RvdHlwZSA9IEFic3RyYWN0TWF0aFF1aWxsLnByb3RvdHlwZTtcblxuICBBUElDbGFzc2VzLkVkaXRhYmxlRmllbGQgPSBQKEFic3RyYWN0TWF0aFF1aWxsLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgICBfLl9fbWF0aHF1aWxsaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzdXBlcl8uX19tYXRocXVpbGxpZnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyLmVkaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyLmRlbGVnYXRlTW91c2VFdmVudHMoKTtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyLmVkaXRhYmxlc1RleHRhcmVhRXZlbnRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF8uZm9jdXMgPSBmdW5jdGlvbigpIHsgdGhpcy5fX2NvbnRyb2xsZXIudGV4dGFyZWEuZm9jdXMoKTsgcmV0dXJuIHRoaXM7IH07XG4gICAgXy5ibHVyID0gZnVuY3Rpb24oKSB7IHRoaXMuX19jb250cm9sbGVyLnRleHRhcmVhLmJsdXIoKTsgcmV0dXJuIHRoaXM7IH07XG4gICAgXy53cml0ZSA9IGZ1bmN0aW9uKGxhdGV4KSB7XG4gICAgICB0aGlzLl9fY29udHJvbGxlci53cml0ZUxhdGV4KGxhdGV4KTtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyLnNjcm9sbEhvcml6KCk7XG4gICAgICBpZiAodGhpcy5fX2NvbnRyb2xsZXIuYmx1cnJlZCkgdGhpcy5fX2NvbnRyb2xsZXIuY3Vyc29yLmhpZGUoKS5wYXJlbnQuYmx1cigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfLmNtZCA9IGZ1bmN0aW9uKGNtZCkge1xuICAgICAgdmFyIGN0cmxyID0gdGhpcy5fX2NvbnRyb2xsZXIubm90aWZ5KCksIGN1cnNvciA9IGN0cmxyLmN1cnNvcjtcbiAgICAgIGlmICgvXlxcXFxbYS16XSskL2kudGVzdChjbWQpKSB7XG4gICAgICAgIGNtZCA9IGNtZC5zbGljZSgxKTtcbiAgICAgICAgdmFyIGtsYXNzID0gTGF0ZXhDbWRzW2NtZF07XG4gICAgICAgIGlmIChrbGFzcykge1xuICAgICAgICAgIGNtZCA9IGtsYXNzKGNtZCk7XG4gICAgICAgICAgaWYgKGN1cnNvci5zZWxlY3Rpb24pIGNtZC5yZXBsYWNlcyhjdXJzb3IucmVwbGFjZVNlbGVjdGlvbigpKTtcbiAgICAgICAgICBjbWQuY3JlYXRlTGVmdE9mKGN1cnNvci5zaG93KCkpO1xuICAgICAgICAgIHRoaXMuX19jb250cm9sbGVyLnNjcm9sbEhvcml6KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAvKiBUT0RPOiBBUEkgbmVlZHMgYmV0dGVyIGVycm9yIHJlcG9ydGluZyAqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgY3Vyc29yLnBhcmVudC53cml0ZShjdXJzb3IsIGNtZCk7XG4gICAgICBpZiAoY3RybHIuYmx1cnJlZCkgY3Vyc29yLmhpZGUoKS5wYXJlbnQuYmx1cigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN0cmxyID0gdGhpcy5fX2NvbnRyb2xsZXI7XG4gICAgICBjdHJsci5ub3RpZnkoJ21vdmUnKS5jdXJzb3IuaW5zQXRSaWdodEVuZChjdHJsci5yb290KTtcbiAgICAgIHdoaWxlIChjdHJsci5jdXJzb3JbTF0pIGN0cmxyLnNlbGVjdExlZnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXy5jbGVhclNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2NvbnRyb2xsZXIuY3Vyc29yLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgXy5tb3ZlVG9EaXJFbmQgPSBmdW5jdGlvbihkaXIpIHtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyLm5vdGlmeSgnbW92ZScpLmN1cnNvci5pbnNBdERpckVuZChkaXIsIHRoaXMuX19jb250cm9sbGVyLnJvb3QpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfLm1vdmVUb0xlZnRFbmQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubW92ZVRvRGlyRW5kKEwpOyB9O1xuICAgIF8ubW92ZVRvUmlnaHRFbmQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubW92ZVRvRGlyRW5kKFIpOyB9O1xuXG4gICAgXy5rZXlzdHJva2UgPSBmdW5jdGlvbihrZXlzKSB7XG4gICAgICB2YXIga2V5cyA9IGtleXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpLnNwbGl0KC9cXHMrLyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5fX2NvbnRyb2xsZXIua2V5c3Ryb2tlKGtleXNbaV0sIHsgcHJldmVudERlZmF1bHQ6IG5vb3AgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF8udHlwZWRUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSArPSAxKSB0aGlzLl9fY29udHJvbGxlci50eXBlZFRleHQodGV4dC5jaGFyQXQoaSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfLmRyb3BFbWJlZGRlZCA9IGZ1bmN0aW9uKHBhZ2VYLCBwYWdlWSwgb3B0aW9ucykge1xuICAgICAgdmFyIGNsaWVudFggPSBwYWdlWCAtICQod2luZG93KS5zY3JvbGxMZWZ0KCk7XG4gICAgICB2YXIgY2xpZW50WSA9IHBhZ2VZIC0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuXG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgdGhpcy5fX2NvbnRyb2xsZXIuc2VlaygkKGVsKSwgcGFnZVgsIHBhZ2VZKTtcbiAgICAgIHZhciBjbWQgPSBFbWJlZCgpLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBjbWQuY3JlYXRlTGVmdE9mKHRoaXMuX19jb250cm9sbGVyLmN1cnNvcik7XG4gICAgfTtcbiAgfSk7XG4gIE1RLkVkaXRhYmxlRmllbGQgPSBmdW5jdGlvbigpIHsgdGhyb3cgXCJ3dGYgZG9uJ3QgY2FsbCBtZSwgSSdtICdhYnN0cmFjdCdcIjsgfTtcbiAgTVEuRWRpdGFibGVGaWVsZC5wcm90b3R5cGUgPSBBUElDbGFzc2VzLkVkaXRhYmxlRmllbGQucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBFeHBvcnQgdGhlIEFQSSBmdW5jdGlvbnMgdGhhdCBNYXRoUXVpbGwtaWZ5IGFuIEhUTUwgZWxlbWVudCBpbnRvIEFQSSBvYmplY3RzXG4gICAqIG9mIGVhY2ggY2xhc3MuIElmIHRoZSBlbGVtZW50IGhhZCBhbHJlYWR5IGJlZW4gTWF0aFF1aWxsLWlmaWVkIGJ1dCBpbnRvIGFcbiAgICogZGlmZmVyZW50IGtpbmQgKG9yIGl0J3Mgbm90IGFuIEhUTUwgZWxlbWVudCksIHJldHVybiBudWxsLlxuICAgKi9cbiAgZm9yICh2YXIga2luZCBpbiBBUEkpIChmdW5jdGlvbihraW5kLCBkZWZBUElDbGFzcykge1xuICAgIHZhciBBUElDbGFzcyA9IEFQSUNsYXNzZXNba2luZF0gPSBkZWZBUElDbGFzcyhBUElDbGFzc2VzKTtcbiAgICBNUVtraW5kXSA9IGZ1bmN0aW9uKGVsLCBvcHRzKSB7XG4gICAgICB2YXIgbXEgPSBNUShlbCk7XG4gICAgICBpZiAobXEgaW5zdGFuY2VvZiBBUElDbGFzcyB8fCAhZWwgfHwgIWVsLm5vZGVUeXBlKSByZXR1cm4gbXE7XG4gICAgICB2YXIgY3RybHIgPSBDb250cm9sbGVyKEFQSUNsYXNzLlJvb3RCbG9jaygpLCAkKGVsKSwgT3B0aW9ucygpKTtcbiAgICAgIGN0cmxyLktJTkRfT0ZfTVEgPSBraW5kO1xuICAgICAgcmV0dXJuIEFQSUNsYXNzKGN0cmxyKS5fX21hdGhxdWlsbGlmeShvcHRzLCB2KTtcbiAgICB9O1xuICAgIE1RW2tpbmRdLnByb3RvdHlwZSA9IEFQSUNsYXNzLnByb3RvdHlwZTtcbiAgfShraW5kLCBBUElba2luZF0pKTtcblxuICByZXR1cm4gTVE7XG59XG5cbk1hdGhRdWlsbC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5NYXRoUXVpbGwgPSBvcmlnTWF0aFF1aWxsO1xuICByZXR1cm4gTWF0aFF1aWxsO1xufTtcbnZhciBvcmlnTWF0aFF1aWxsID0gd2luZG93Lk1hdGhRdWlsbDtcbndpbmRvdy5NYXRoUXVpbGwgPSBNYXRoUXVpbGw7XG5cbmZ1bmN0aW9uIFJvb3RCbG9ja01peGluKF8pIHtcbiAgdmFyIG5hbWVzID0gJ21vdmVPdXRPZiBkZWxldGVPdXRPZiBzZWxlY3RPdXRPZiB1cE91dE9mIGRvd25PdXRPZicuc3BsaXQoJyAnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkgKz0gMSkgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfW25hbWVdID0gZnVuY3Rpb24oZGlyKSB7IHRoaXMuY29udHJvbGxlci5oYW5kbGUobmFtZSwgZGlyKTsgfTtcbiAgfShuYW1lc1tpXSkpO1xuICBfLnJlZmxvdyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udHJvbGxlci5oYW5kbGUoJ3JlZmxvdycpO1xuICAgIHRoaXMuY29udHJvbGxlci5oYW5kbGUoJ2VkaXRlZCcpO1xuICAgIHRoaXMuY29udHJvbGxlci5oYW5kbGUoJ2VkaXQnKTtcbiAgfTtcbn1cbnZhciBQYXJzZXIgPSBQKGZ1bmN0aW9uKF8sIHN1cGVyXywgUGFyc2VyKSB7XG4gIC8vIFRoZSBQYXJzZXIgb2JqZWN0IGlzIGEgd3JhcHBlciBmb3IgYSBwYXJzZXIgZnVuY3Rpb24uXG4gIC8vIEV4dGVybmFsbHksIHlvdSB1c2Ugb25lIHRvIHBhcnNlIGEgc3RyaW5nIGJ5IGNhbGxpbmdcbiAgLy8gICB2YXIgcmVzdWx0ID0gU29tZVBhcnNlci5wYXJzZSgnTWUgTWUgTWUhIFBhcnNlIE1lIScpO1xuICAvLyBZb3Ugc2hvdWxkIG5ldmVyIGNhbGwgdGhlIGNvbnN0cnVjdG9yLCByYXRoZXIgeW91IHNob3VsZFxuICAvLyBjb25zdHJ1Y3QgeW91ciBQYXJzZXIgZnJvbSB0aGUgYmFzZSBwYXJzZXJzIGFuZCB0aGVcbiAgLy8gcGFyc2VyIGNvbWJpbmF0b3IgbWV0aG9kcy5cblxuICBmdW5jdGlvbiBwYXJzZUVycm9yKHN0cmVhbSwgbWVzc2FnZSkge1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHN0cmVhbSA9IFwiJ1wiK3N0cmVhbStcIidcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdHJlYW0gPSAnRU9GJztcbiAgICB9XG5cbiAgICB0aHJvdyAnUGFyc2UgRXJyb3I6ICcrbWVzc2FnZSsnIGF0ICcrc3RyZWFtO1xuICB9XG5cbiAgXy5pbml0ID0gZnVuY3Rpb24oYm9keSkgeyB0aGlzLl8gPSBib2R5OyB9O1xuXG4gIF8ucGFyc2UgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gdGhpcy5za2lwKGVvZikuXygnJytzdHJlYW0sIHN1Y2Nlc3MsIHBhcnNlRXJyb3IpO1xuXG4gICAgZnVuY3Rpb24gc3VjY2VzcyhzdHJlYW0sIHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0OyB9XG4gIH07XG5cbiAgLy8gLSotIHByaW1pdGl2ZSBjb21iaW5hdG9ycyAtKi0gLy9cbiAgXy5vciA9IGZ1bmN0aW9uKGFsdGVybmF0aXZlKSB7XG4gICAgcHJheSgnb3IgaXMgcGFzc2VkIGEgcGFyc2VyJywgYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBQYXJzZXIpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIFBhcnNlcihmdW5jdGlvbihzdHJlYW0sIG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gICAgICByZXR1cm4gc2VsZi5fKHN0cmVhbSwgb25TdWNjZXNzLCBmYWlsdXJlKTtcblxuICAgICAgZnVuY3Rpb24gZmFpbHVyZShuZXdTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGFsdGVybmF0aXZlLl8oc3RyZWFtLCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgXy50aGVuID0gZnVuY3Rpb24obmV4dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiBQYXJzZXIoZnVuY3Rpb24oc3RyZWFtLCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICAgICAgcmV0dXJuIHNlbGYuXyhzdHJlYW0sIHN1Y2Nlc3MsIG9uRmFpbHVyZSk7XG5cbiAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MobmV3U3RyZWFtLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5leHRQYXJzZXIgPSAobmV4dCBpbnN0YW5jZW9mIFBhcnNlciA/IG5leHQgOiBuZXh0KHJlc3VsdCkpO1xuICAgICAgICBwcmF5KCdhIHBhcnNlciBpcyByZXR1cm5lZCcsIG5leHRQYXJzZXIgaW5zdGFuY2VvZiBQYXJzZXIpO1xuICAgICAgICByZXR1cm4gbmV4dFBhcnNlci5fKG5ld1N0cmVhbSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIC0qLSBvcHRpbWl6ZWQgaXRlcmF0aXZlIGNvbWJpbmF0b3JzIC0qLSAvL1xuICBfLm1hbnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gUGFyc2VyKGZ1bmN0aW9uKHN0cmVhbSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICAgIHZhciB4cyA9IFtdO1xuICAgICAgd2hpbGUgKHNlbGYuXyhzdHJlYW0sIHN1Y2Nlc3MsIGZhaWx1cmUpKTtcbiAgICAgIHJldHVybiBvblN1Y2Nlc3Moc3RyZWFtLCB4cyk7XG5cbiAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MobmV3U3RyZWFtLCB4KSB7XG4gICAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcbiAgICAgICAgeHMucHVzaCh4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfLnRpbWVzID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIG1heCA9IG1pbjtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gUGFyc2VyKGZ1bmN0aW9uKHN0cmVhbSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICAgIHZhciB4cyA9IFtdO1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICB2YXIgZmFpbHVyZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkgKz0gMSkge1xuICAgICAgICByZXN1bHQgPSBzZWxmLl8oc3RyZWFtLCBzdWNjZXNzLCBmaXJzdEZhaWx1cmUpO1xuICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIG9uRmFpbHVyZShzdHJlYW0sIGZhaWx1cmUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IG1heCAmJiByZXN1bHQ7IGkgKz0gMSkge1xuICAgICAgICByZXN1bHQgPSBzZWxmLl8oc3RyZWFtLCBzdWNjZXNzLCBzZWNvbmRGYWlsdXJlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9uU3VjY2VzcyhzdHJlYW0sIHhzKTtcblxuICAgICAgZnVuY3Rpb24gc3VjY2VzcyhuZXdTdHJlYW0sIHgpIHtcbiAgICAgICAgeHMucHVzaCh4KTtcbiAgICAgICAgc3RyZWFtID0gbmV3U3RyZWFtO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmlyc3RGYWlsdXJlKG5ld1N0cmVhbSwgbXNnKSB7XG4gICAgICAgIGZhaWx1cmUgPSBtc2c7XG4gICAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZWNvbmRGYWlsdXJlKG5ld1N0cmVhbSwgbXNnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyAtKi0gaGlnaGVyLWxldmVsIGNvbWJpbmF0b3JzIC0qLSAvL1xuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKHJlcykgeyByZXR1cm4gdGhpcy50aGVuKHN1Y2NlZWQocmVzKSk7IH07XG4gIF8uYXRNb3N0ID0gZnVuY3Rpb24obikgeyByZXR1cm4gdGhpcy50aW1lcygwLCBuKTsgfTtcbiAgXy5hdExlYXN0ID0gZnVuY3Rpb24obikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gc2VsZi50aW1lcyhuKS50aGVuKGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgICByZXR1cm4gc2VsZi5tYW55KCkubWFwKGZ1bmN0aW9uKGVuZCkge1xuICAgICAgICByZXR1cm4gc3RhcnQuY29uY2F0KGVuZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfLm1hcCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihyZXN1bHQpIHsgcmV0dXJuIHN1Y2NlZWQoZm4ocmVzdWx0KSk7IH0pO1xuICB9O1xuXG4gIF8uc2tpcCA9IGZ1bmN0aW9uKHR3bykge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7IHJldHVybiB0d28ucmVzdWx0KHJlc3VsdCk7IH0pO1xuICB9O1xuXG4gIC8vIC0qLSBwcmltaXRpdmUgcGFyc2VycyAtKi0gLy9cbiAgdmFyIHN0cmluZyA9IHRoaXMuc3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGV4cGVjdGVkID0gXCJleHBlY3RlZCAnXCIrc3RyK1wiJ1wiO1xuXG4gICAgcmV0dXJuIFBhcnNlcihmdW5jdGlvbihzdHJlYW0sIG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gICAgICB2YXIgaGVhZCA9IHN0cmVhbS5zbGljZSgwLCBsZW4pO1xuXG4gICAgICBpZiAoaGVhZCA9PT0gc3RyKSB7XG4gICAgICAgIHJldHVybiBvblN1Y2Nlc3Moc3RyZWFtLnNsaWNlKGxlbiksIGhlYWQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBvbkZhaWx1cmUoc3RyZWFtLCBleHBlY3RlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlZ2V4ID0gdGhpcy5yZWdleCA9IGZ1bmN0aW9uKHJlKSB7XG4gICAgcHJheSgncmVnZXhwIHBhcnNlciBpcyBhbmNob3JlZCcsIHJlLnRvU3RyaW5nKCkuY2hhckF0KDEpID09PSAnXicpO1xuXG4gICAgdmFyIGV4cGVjdGVkID0gJ2V4cGVjdGVkICcrcmU7XG5cbiAgICByZXR1cm4gUGFyc2VyKGZ1bmN0aW9uKHN0cmVhbSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMoc3RyZWFtKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBtYXRjaFswXTtcbiAgICAgICAgcmV0dXJuIG9uU3VjY2VzcyhzdHJlYW0uc2xpY2UocmVzdWx0Lmxlbmd0aCksIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9uRmFpbHVyZShzdHJlYW0sIGV4cGVjdGVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgc3VjY2VlZCA9IFBhcnNlci5zdWNjZWVkID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgcmV0dXJuIFBhcnNlcihmdW5jdGlvbihzdHJlYW0sIG9uU3VjY2Vzcykge1xuICAgICAgcmV0dXJuIG9uU3VjY2VzcyhzdHJlYW0sIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGZhaWwgPSBQYXJzZXIuZmFpbCA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHJldHVybiBQYXJzZXIoZnVuY3Rpb24oc3RyZWFtLCBfLCBvbkZhaWx1cmUpIHtcbiAgICAgIHJldHVybiBvbkZhaWx1cmUoc3RyZWFtLCBtc2cpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBsZXR0ZXIgPSBQYXJzZXIubGV0dGVyID0gcmVnZXgoL15bYS16XS9pKTtcbiAgdmFyIGxldHRlcnMgPSBQYXJzZXIubGV0dGVycyA9IHJlZ2V4KC9eW2Etel0qL2kpO1xuICB2YXIgZGlnaXQgPSBQYXJzZXIuZGlnaXQgPSByZWdleCgvXlswLTldLyk7XG4gIHZhciBkaWdpdHMgPSBQYXJzZXIuZGlnaXRzID0gcmVnZXgoL15bMC05XSovKTtcbiAgdmFyIHdoaXRlc3BhY2UgPSBQYXJzZXIud2hpdGVzcGFjZSA9IHJlZ2V4KC9eXFxzKy8pO1xuICB2YXIgb3B0V2hpdGVzcGFjZSA9IFBhcnNlci5vcHRXaGl0ZXNwYWNlID0gcmVnZXgoL15cXHMqLyk7XG5cbiAgdmFyIGFueSA9IFBhcnNlci5hbnkgPSBQYXJzZXIoZnVuY3Rpb24oc3RyZWFtLCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICAgIGlmICghc3RyZWFtKSByZXR1cm4gb25GYWlsdXJlKHN0cmVhbSwgJ2V4cGVjdGVkIGFueSBjaGFyYWN0ZXInKTtcblxuICAgIHJldHVybiBvblN1Y2Nlc3Moc3RyZWFtLnNsaWNlKDEpLCBzdHJlYW0uY2hhckF0KDApKTtcbiAgfSk7XG5cbiAgdmFyIGFsbCA9IFBhcnNlci5hbGwgPSBQYXJzZXIoZnVuY3Rpb24oc3RyZWFtLCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICAgIHJldHVybiBvblN1Y2Nlc3MoJycsIHN0cmVhbSk7XG4gIH0pO1xuXG4gIHZhciBlb2YgPSBQYXJzZXIuZW9mID0gUGFyc2VyKGZ1bmN0aW9uKHN0cmVhbSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICBpZiAoc3RyZWFtKSByZXR1cm4gb25GYWlsdXJlKHN0cmVhbSwgJ2V4cGVjdGVkIEVPRicpO1xuXG4gICAgcmV0dXJuIG9uU3VjY2VzcyhzdHJlYW0sIHN0cmVhbSk7XG4gIH0pO1xufSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogU2FuZSBLZXlib2FyZCBFdmVudHMgU2hpbVxuICpcbiAqIEFuIGFic3RyYWN0aW9uIGxheWVyIHdyYXBwaW5nIHRoZSB0ZXh0YXJlYSBpblxuICogYW4gb2JqZWN0IHdpdGggbWV0aG9kcyB0byBtYW5pcHVsYXRlIGFuZCBsaXN0ZW5cbiAqIHRvIGV2ZW50cyBvbiwgdGhhdCBoaWRlcyBhbGwgdGhlIG5hc3R5IGNyb3NzLVxuICogYnJvd3NlciBpbmNvbXBhdGliaWxpdGllcyBiZWhpbmQgYSB1bmlmb3JtIEFQSS5cbiAqXG4gKiBEZXNpZ24gZ29hbDogVGhpcyBpcyBhICpIQVJEKiBpbnRlcm5hbFxuICogYWJzdHJhY3Rpb24gYmFycmllci4gQ3Jvc3MtYnJvd3NlclxuICogaW5jb25zaXN0ZW5jaWVzIGFyZSBub3QgYWxsb3dlZCB0byBsZWFrIHRocm91Z2hcbiAqIGFuZCBiZSBkZWFsdCB3aXRoIGJ5IGV2ZW50IGhhbmRsZXJzLiBBbGwgZnV0dXJlXG4gKiBjcm9zcy1icm93c2VyIGlzc3VlcyB0aGF0IGFyaXNlIG11c3QgYmUgZGVhbHRcbiAqIHdpdGggaGVyZSwgYW5kIGlmIG5lY2Vzc2FyeSwgdGhlIEFQSSB1cGRhdGVkLlxuICpcbiAqIE9yZ2FuaXphdGlvbjpcbiAqIC0ga2V5IHZhbHVlcyBtYXAgYW5kIHN0cmluZ2lmeSgpXG4gKiAtIHNhbmVLZXlib2FyZEV2ZW50cygpXG4gKiAgICArIGRlZmVyKCkgYW5kIGZsdXNoKClcbiAqICAgICsgZXZlbnQgaGFuZGxlciBsb2dpY1xuICogICAgKyBhdHRhY2ggZXZlbnQgaGFuZGxlcnMgYW5kIGV4cG9ydCBtZXRob2RzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgc2FuZUtleWJvYXJkRXZlbnRzID0gKGZ1bmN0aW9uKCkge1xuICAvLyBUaGUgZm9sbG93aW5nIFtrZXkgdmFsdWVzXVsxXSBtYXAgd2FzIGNvbXBpbGVkIGZyb20gdGhlXG4gIC8vIFtET00zIEV2ZW50cyBhcHBlbmRpeCBzZWN0aW9uIG9uIGtleSBjb2Rlc11bMl0gYW5kXG4gIC8vIFthIHdpZGVseSBjaXRlZCByZXBvcnQgb24gY3Jvc3MtYnJvd3NlciB0ZXN0cyBvZiBrZXkgY29kZXNdWzNdLFxuICAvLyBleGNlcHQgZm9yIDEwOiAnRW50ZXInLCB3aGljaCBJJ3ZlIGVtcGlyaWNhbGx5IG9ic2VydmVkIGluIFNhZmFyaSBvbiBpT1NcbiAgLy8gYW5kIGRvZXNuJ3QgYXBwZWFyIHRvIGNvbmZsaWN0IHdpdGggYW55IG90aGVyIGtub3duIGtleSBjb2Rlcy5cbiAgLy9cbiAgLy8gWzFdOiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEyMDYxNC8ja2V5cy1rZXl2YWx1ZXNcbiAgLy8gWzJdOiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEyMDYxNC8jZml4ZWQtdmlydHVhbC1rZXktY29kZXNcbiAgLy8gWzNdOiBodHRwOi8vdW5peHBhcGEuY29tL2pzL2tleS5odG1sXG4gIHZhciBLRVlfVkFMVUVTID0ge1xuICAgIDg6ICdCYWNrc3BhY2UnLFxuICAgIDk6ICdUYWInLFxuXG4gICAgMTA6ICdFbnRlcicsIC8vIGZvciBTYWZhcmkgb24gaU9TXG5cbiAgICAxMzogJ0VudGVyJyxcblxuICAgIDE2OiAnU2hpZnQnLFxuICAgIDE3OiAnQ29udHJvbCcsXG4gICAgMTg6ICdBbHQnLFxuICAgIDIwOiAnQ2Fwc0xvY2snLFxuXG4gICAgMjc6ICdFc2MnLFxuXG4gICAgMzI6ICdTcGFjZWJhcicsXG5cbiAgICAzMzogJ1BhZ2VVcCcsXG4gICAgMzQ6ICdQYWdlRG93bicsXG4gICAgMzU6ICdFbmQnLFxuICAgIDM2OiAnSG9tZScsXG5cbiAgICAzNzogJ0xlZnQnLFxuICAgIDM4OiAnVXAnLFxuICAgIDM5OiAnUmlnaHQnLFxuICAgIDQwOiAnRG93bicsXG5cbiAgICA0NTogJ0luc2VydCcsXG5cbiAgICA0NjogJ0RlbCcsXG5cbiAgICAxNDQ6ICdOdW1Mb2NrJ1xuICB9O1xuXG4gIC8vIFRvIHRoZSBleHRlbnQgcG9zc2libGUsIGNyZWF0ZSBhIG5vcm1hbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gIC8vIG9mIHRoZSBrZXkgY29tYm8gKGkuZS4sIGtleSBjb2RlIGFuZCBtb2RpZmllciBrZXlzKS5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5KGV2dCkge1xuICAgIHZhciB3aGljaCA9IGV2dC53aGljaCB8fCBldnQua2V5Q29kZTtcbiAgICB2YXIga2V5VmFsID0gS0VZX1ZBTFVFU1t3aGljaF07XG4gICAgdmFyIGtleTtcbiAgICB2YXIgbW9kaWZpZXJzID0gW107XG5cbiAgICBpZiAoZXZ0LmN0cmxLZXkpIG1vZGlmaWVycy5wdXNoKCdDdHJsJyk7XG4gICAgaWYgKGV2dC5vcmlnaW5hbEV2ZW50ICYmIGV2dC5vcmlnaW5hbEV2ZW50Lm1ldGFLZXkpIG1vZGlmaWVycy5wdXNoKCdNZXRhJyk7XG4gICAgaWYgKGV2dC5hbHRLZXkpIG1vZGlmaWVycy5wdXNoKCdBbHQnKTtcbiAgICBpZiAoZXZ0LnNoaWZ0S2V5KSBtb2RpZmllcnMucHVzaCgnU2hpZnQnKTtcblxuICAgIGtleSA9IGtleVZhbCB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKHdoaWNoKTtcblxuICAgIGlmICghbW9kaWZpZXJzLmxlbmd0aCAmJiAha2V5VmFsKSByZXR1cm4ga2V5O1xuXG4gICAgbW9kaWZpZXJzLnB1c2goa2V5KTtcbiAgICByZXR1cm4gbW9kaWZpZXJzLmpvaW4oJy0nKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBhIGtleWJvYXJkIGV2ZW50cyBzaGltIHRoYXQgY2FsbHMgY2FsbGJhY2tzIGF0IHVzZWZ1bCB0aW1lc1xuICAvLyBhbmQgZXhwb3J0cyB1c2VmdWwgcHVibGljIG1ldGhvZHNcbiAgcmV0dXJuIGZ1bmN0aW9uIHNhbmVLZXlib2FyZEV2ZW50cyhlbCwgaGFuZGxlcnMpIHtcbiAgICB2YXIga2V5ZG93biA9IG51bGw7XG4gICAgdmFyIGtleXByZXNzID0gbnVsbDtcblxuICAgIHZhciB0ZXh0YXJlYSA9IGpRdWVyeShlbCk7XG4gICAgdmFyIHRhcmdldCA9IGpRdWVyeShoYW5kbGVycy5jb250YWluZXIgfHwgdGV4dGFyZWEpO1xuXG4gICAgLy8gY2hlY2tUZXh0YXJlYUZvcigpIGlzIGNhbGxlZCBhZnRlciBrZXlwcmVzcyBvciBwYXN0ZSBldmVudHMgdG9cbiAgICAvLyBzYXkgXCJIZXksIEkgdGhpbmsgc29tZXRoaW5nIHdhcyBqdXN0IHR5cGVkXCIgb3IgXCJwYXN0ZWRcIiAocmVzcC4pLFxuICAgIC8vIHNvIHRoYXQgYXQgYWxsIHN1YnNlcXVlbnQgb3Bwb3J0dW5lIHRpbWVzIChuZXh0IGV2ZW50IG9yIHRpbWVvdXQpLFxuICAgIC8vIHdpbGwgY2hlY2sgZm9yIGV4cGVjdGVkIHR5cGVkIG9yIHBhc3RlZCB0ZXh0LlxuICAgIC8vIE5lZWQgdG8gY2hlY2sgcmVwZWF0ZWRseSBiZWNhdXNlICMxMzU6IGluIFNhZmFyaSA1LjEgKGF0IGxlYXN0KSxcbiAgICAvLyBhZnRlciBzZWxlY3Rpbmcgc29tZXRoaW5nIGFuZCB0aGVuIHR5cGluZywgdGhlIHRleHRhcmVhIGlzXG4gICAgLy8gaW5jb3JyZWN0bHkgcmVwb3J0ZWQgYXMgc2VsZWN0ZWQgZHVyaW5nIHRoZSBpbnB1dCBldmVudCAoYnV0IG5vdFxuICAgIC8vIHN1YnNlcXVlbnRseSkuXG4gICAgdmFyIGNoZWNrVGV4dGFyZWEgPSBub29wLCB0aW1lb3V0SWQ7XG4gICAgZnVuY3Rpb24gY2hlY2tUZXh0YXJlYUZvcihjaGVja2VyKSB7XG4gICAgICBjaGVja1RleHRhcmVhID0gY2hlY2tlcjtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChjaGVja2VyKTtcbiAgICB9XG4gICAgdGFyZ2V0LmJpbmQoJ2tleWRvd24ga2V5cHJlc3MgaW5wdXQga2V5dXAgZm9jdXNvdXQgcGFzdGUnLCBmdW5jdGlvbihlKSB7IGNoZWNrVGV4dGFyZWEoZSk7IH0pO1xuXG5cbiAgICAvLyAtKi0gcHVibGljIG1ldGhvZHMgLSotIC8vXG4gICAgZnVuY3Rpb24gc2VsZWN0KHRleHQpIHtcbiAgICAgIC8vIGNoZWNrIHRleHRhcmVhIGF0IGxlYXN0IG9uY2Uvb25lIGxhc3QgdGltZSBiZWZvcmUgbXVuZ2luZyAoc29cbiAgICAgIC8vIG5vIHJhY2UgY29uZGl0aW9uIGlmIHNlbGVjdGlvbiBoYXBwZW5zIGFmdGVyIGtleXByZXNzL3Bhc3RlIGJ1dFxuICAgICAgLy8gYmVmb3JlIGNoZWNrVGV4dGFyZWEpLCB0aGVuIG5ldmVyIGFnYWluICgnY29zIGl0J3MgYmVlbiBtdW5nZWQpXG4gICAgICBjaGVja1RleHRhcmVhKCk7XG4gICAgICBjaGVja1RleHRhcmVhID0gbm9vcDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICB0ZXh0YXJlYS52YWwodGV4dCk7XG4gICAgICBpZiAodGV4dCAmJiB0ZXh0YXJlYVswXS5zZWxlY3QpIHRleHRhcmVhWzBdLnNlbGVjdCgpO1xuICAgICAgc2hvdWxkQmVTZWxlY3RlZCA9ICEhdGV4dDtcbiAgICB9XG4gICAgdmFyIHNob3VsZEJlU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIC8vIC0qLSBoZWxwZXIgc3Vicm91dGluZXMgLSotIC8vXG5cbiAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGVyZSdzIGEgc2VsZWN0aW9uIGluIHRoZSB0ZXh0YXJlYS5cbiAgICAvLyBUaGlzIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSBpbiBJRSA8IDksIHdoaWNoIGRvbid0IHN1cHBvcnRcbiAgICAvLyBIVE1MVGV4dGFyZWFFbGVtZW50OjpzZWxlY3Rpb257U3RhcnQsRW5kfS5cbiAgICBmdW5jdGlvbiBoYXNTZWxlY3Rpb24oKSB7XG4gICAgICB2YXIgZG9tID0gdGV4dGFyZWFbMF07XG5cbiAgICAgIGlmICghKCdzZWxlY3Rpb25TdGFydCcgaW4gZG9tKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIGRvbS5zZWxlY3Rpb25TdGFydCAhPT0gZG9tLnNlbGVjdGlvbkVuZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVLZXkoKSB7XG4gICAgICBoYW5kbGVycy5rZXlzdHJva2Uoc3RyaW5naWZ5KGtleWRvd24pLCBrZXlkb3duKTtcbiAgICB9XG5cbiAgICAvLyAtKi0gZXZlbnQgaGFuZGxlcnMgLSotIC8vXG4gICAgZnVuY3Rpb24gb25LZXlkb3duKGUpIHtcbiAgICAgIGtleWRvd24gPSBlO1xuICAgICAga2V5cHJlc3MgPSBudWxsO1xuXG4gICAgICBpZiAoc2hvdWxkQmVTZWxlY3RlZCkgY2hlY2tUZXh0YXJlYUZvcihmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghKGUgJiYgZS50eXBlID09PSAnZm9jdXNvdXQnKSAmJiB0ZXh0YXJlYVswXS5zZWxlY3QpIHtcbiAgICAgICAgICB0ZXh0YXJlYVswXS5zZWxlY3QoKTsgLy8gcmUtc2VsZWN0IHRleHRhcmVhIGluIGNhc2UgaXQncyBhbiB1bnJlY29nbml6ZWRcbiAgICAgICAgfVxuICAgICAgICBjaGVja1RleHRhcmVhID0gbm9vcDsgLy8ga2V5IHRoYXQgY2xlYXJzIHRoZSBzZWxlY3Rpb24sIHRoZW4gbmV2ZXJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7IC8vIGFnYWluLCAnY29zIG5leHQgdGhpbmcgbWlnaHQgYmUgYmx1clxuICAgICAgfSk7XG5cbiAgICAgIGhhbmRsZUtleSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uS2V5cHJlc3MoZSkge1xuICAgICAgLy8gY2FsbCB0aGUga2V5IGhhbmRsZXIgZm9yIHJlcGVhdGVkIGtleXByZXNzZXMuXG4gICAgICAvLyBUaGlzIGV4Y2x1ZGVzIGtleXByZXNzZXMgdGhhdCBoYXBwZW4gZGlyZWN0bHlcbiAgICAgIC8vIGFmdGVyIGtleWRvd24uICBJbiB0aGF0IGNhc2UsIHRoZXJlIHdpbGwgYmVcbiAgICAgIC8vIG5vIHByZXZpb3VzIGtleXByZXNzLCBzbyB3ZSBza2lwIGl0IGhlcmVcbiAgICAgIGlmIChrZXlkb3duICYmIGtleXByZXNzKSBoYW5kbGVLZXkoKTtcblxuICAgICAga2V5cHJlc3MgPSBlO1xuXG4gICAgICBjaGVja1RleHRhcmVhRm9yKHR5cGVkVGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR5cGVkVGV4dCgpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2VsZWN0aW9uLCB0aGUgY29udGVudHMgb2YgdGhlIHRleHRhcmVhIGNvdWxkbid0XG4gICAgICAvLyBwb3NzaWJseSBoYXZlIGp1c3QgYmVlbiB0eXBlZCBpbi5cbiAgICAgIC8vIFRoaXMgaGFwcGVucyBpbiBicm93c2VycyBsaWtlIEZpcmVmb3ggYW5kIE9wZXJhIHRoYXQgZmlyZVxuICAgICAgLy8ga2V5cHJlc3MgZm9yIGtleXN0cm9rZXMgdGhhdCBhcmUgbm90IHRleHQgZW50cnkgYW5kIGxlYXZlIHRoZVxuICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSB0ZXh0YXJlYSBhbG9uZSwgc3VjaCBhcyBDdHJsLUMuXG4gICAgICAvLyBOb3RlOiB3ZSBhc3N1bWUgdGhhdCBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaGFzU2VsZWN0aW9uKClcbiAgICAgIC8vIGFsc28gbmV2ZXIgZmlyZSBrZXlwcmVzcyBvbiBrZXlzdHJva2VzIHRoYXQgYXJlIG5vdCB0ZXh0IGVudHJ5LlxuICAgICAgLy8gVGhpcyBzZWVtcyByZWFzb25hYmx5IHNhZmUgYmVjYXVzZTpcbiAgICAgIC8vIC0gYWxsIG1vZGVybiBicm93c2VycyBpbmNsdWRpbmcgSUUgOSsgc3VwcG9ydCBoYXNTZWxlY3Rpb24oKSxcbiAgICAgIC8vICAgbWFraW5nIGl0IGV4dHJlbWVseSB1bmxpa2VseSBhbnkgYnJvd3NlciBiZXNpZGVzIElFIDwgOSB3b24ndFxuICAgICAgLy8gLSBhcyBmYXIgYXMgd2Uga25vdyBJRSA8IDkgbmV2ZXIgZmlyZXMga2V5cHJlc3Mgb24ga2V5c3Ryb2tlc1xuICAgICAgLy8gICB0aGF0IGFyZW4ndCB0ZXh0IGVudHJ5LCB3aGljaCBpcyBvbmx5IGFzIHJlbGlhYmxlIGFzIG91clxuICAgICAgLy8gICB0ZXN0cyBhcmUgY29tcHJlaGVuc2l2ZSwgYnV0IHRoZSBJRSA8IDkgd2F5IHRvIGRvXG4gICAgICAvLyAgIGhhc1NlbGVjdGlvbigpIGlzIHBvb3JseSBkb2N1bWVudGVkIGFuZCBpcyBhbHNvIG9ubHkgYXNcbiAgICAgIC8vICAgcmVsaWFibGUgYXMgb3VyIHRlc3RzIGFyZSBjb21wcmVoZW5zaXZlXG4gICAgICAvLyBJZiBhbnl0aGluZyBsaWtlICM0MCBvciAjNzEgaXMgcmVwb3J0ZWQgaW4gSUUgPCA5LCBzZWVcbiAgICAgIC8vIGIxMzE4ZTUzNDkxNjBiNjY1MDAzZTM2ZDRlZWRkNjQxMDFjZWFjZDhcbiAgICAgIGlmIChoYXNTZWxlY3Rpb24oKSkgcmV0dXJuO1xuXG4gICAgICB2YXIgdGV4dCA9IHRleHRhcmVhLnZhbCgpO1xuICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRleHRhcmVhLnZhbCgnJyk7XG4gICAgICAgIGhhbmRsZXJzLnR5cGVkVGV4dCh0ZXh0KTtcbiAgICAgIH0gLy8gaW4gRmlyZWZveCwga2V5cyB0aGF0IGRvbid0IHR5cGUgdGV4dCwganVzdCBjbGVhciBzZWxuLCBmaXJlIGtleXByZXNzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aHF1aWxsL21hdGhxdWlsbC9pc3N1ZXMvMjkzI2lzc3VlY29tbWVudC00MDk5NzY2OFxuICAgICAgZWxzZSBpZiAodGV4dCAmJiB0ZXh0YXJlYVswXS5zZWxlY3QpIHRleHRhcmVhWzBdLnNlbGVjdCgpOyAvLyByZS1zZWxlY3QgaWYgdGhhdCdzIHdoeSB3ZSdyZSBoZXJlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkgeyBrZXlkb3duID0ga2V5cHJlc3MgPSBudWxsOyB9XG5cbiAgICBmdW5jdGlvbiBvblBhc3RlKGUpIHtcbiAgICAgIC8vIGJyb3dzZXJzIGFyZSBkdW1iLlxuICAgICAgLy9cbiAgICAgIC8vIEluIExpbnV4LCBtaWRkbGUtY2xpY2sgcGFzdGluZyBjYXVzZXMgb25QYXN0ZSB0byBiZSBjYWxsZWQsXG4gICAgICAvLyB3aGVuIHRoZSB0ZXh0YXJlYSBpcyBub3QgbmVjZXNzYXJpbHkgZm9jdXNlZC4gIFdlIGZvY3VzIGl0XG4gICAgICAvLyBoZXJlIHRvIGVuc3VyZSB0aGF0IHRoZSBwYXN0ZWQgdGV4dCBhY3R1YWxseSBlbmRzIHVwIGluIHRoZVxuICAgICAgLy8gdGV4dGFyZWEuXG4gICAgICAvL1xuICAgICAgLy8gSXQncyBwcmV0dHkgbmlmdHkgdGhhdCBieSBjaGFuZ2luZyBmb2N1cyBpbiB0aGlzIGhhbmRsZXIsXG4gICAgICAvLyB3ZSBjYW4gY2hhbmdlIHRoZSB0YXJnZXQgb2YgdGhlIGRlZmF1bHQgYWN0aW9uLiAgKFRoaXMgd29ya3NcbiAgICAgIC8vIG9uIGtleWRvd24gdG9vLCBGV0lXKS5cbiAgICAgIC8vXG4gICAgICAvLyBBbmQgYnkgbmlmdHksIHdlIG1lYW4gZHVtYiAoYnV0IHVzZWZ1bCBzb21ldGltZXMpLlxuICAgICAgdGV4dGFyZWEuZm9jdXMoKTtcblxuICAgICAgY2hlY2tUZXh0YXJlYUZvcihwYXN0ZWRUZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFzdGVkVGV4dCgpIHtcbiAgICAgIHZhciB0ZXh0ID0gdGV4dGFyZWEudmFsKCk7XG4gICAgICB0ZXh0YXJlYS52YWwoJycpO1xuICAgICAgaWYgKHRleHQpIGhhbmRsZXJzLnBhc3RlKHRleHQpO1xuICAgIH1cblxuICAgIC8vIC0qLSBhdHRhY2ggZXZlbnQgaGFuZGxlcnMgLSotIC8vXG4gICAgdGFyZ2V0LmJpbmQoe1xuICAgICAga2V5ZG93bjogb25LZXlkb3duLFxuICAgICAga2V5cHJlc3M6IG9uS2V5cHJlc3MsXG4gICAgICBmb2N1c291dDogb25CbHVyLFxuICAgICAgcGFzdGU6IG9uUGFzdGVcbiAgICB9KTtcblxuICAgIC8vIC0qLSBleHBvcnQgcHVibGljIG1ldGhvZHMgLSotIC8vXG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdDogc2VsZWN0XG4gICAgfTtcbiAgfTtcbn0oKSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEV4cG9ydCBtYXRoIGluIGEgaHVtYW4tcmVhZGFibGUgdGV4dCBmb3JtYXRcbiAqIEFzIHlvdSBjYW4gc2VlLCBvbmx5IGhhbGYtYmFrZWQgc28gZmFyLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbkNvbnRyb2xsZXIub3BlbihmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5leHBvcnRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5mb2xkQ2hpbGRyZW4oJycsIGZ1bmN0aW9uKHRleHQsIGNoaWxkKSB7XG4gICAgICByZXR1cm4gdGV4dCArIGNoaWxkLnRleHQoKTtcbiAgICB9KTtcbiAgfTtcbn0pO1xuQ29udHJvbGxlci5vcGVuKGZ1bmN0aW9uKF8pIHtcbiAgXy5mb2N1c0JsdXJFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3RybHIgPSB0aGlzLCByb290ID0gY3RybHIucm9vdCwgY3Vyc29yID0gY3RybHIuY3Vyc29yO1xuICAgIHZhciBibHVyVGltZW91dDtcbiAgICBjdHJsci50ZXh0YXJlYS5mb2N1cyhmdW5jdGlvbigpIHtcbiAgICAgIGN0cmxyLmJsdXJyZWQgPSBmYWxzZTtcbiAgICAgIGNsZWFyVGltZW91dChibHVyVGltZW91dCk7XG4gICAgICBjdHJsci5jb250YWluZXIuYWRkQ2xhc3MoJ21xLWZvY3VzZWQnKTtcbiAgICAgIGlmICghY3Vyc29yLnBhcmVudClcbiAgICAgICAgY3Vyc29yLmluc0F0UmlnaHRFbmQocm9vdCk7XG4gICAgICBpZiAoY3Vyc29yLnNlbGVjdGlvbikge1xuICAgICAgICBjdXJzb3Iuc2VsZWN0aW9uLmpRLnJlbW92ZUNsYXNzKCdtcS1ibHVyJyk7XG4gICAgICAgIGN0cmxyLnNlbGVjdGlvbkNoYW5nZWQoKTsgLy9yZS1zZWxlY3QgdGV4dGFyZWEgY29udGVudHMgYWZ0ZXIgdGFiYmluZyBhd2F5IGFuZCBiYWNrXG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGN1cnNvci5zaG93KCk7XG4gICAgfSkuYmx1cihmdW5jdGlvbigpIHtcbiAgICAgIGN0cmxyLmJsdXJyZWQgPSB0cnVlO1xuICAgICAgYmx1clRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyAvLyB3YWl0IGZvciBibHVyIG9uIHdpbmRvdzsgaWZcbiAgICAgICAgcm9vdC5wb3N0T3JkZXIoJ2ludGVudGlvbmFsQmx1cicpOyAvLyBub25lLCBpbnRlbnRpb25hbCBibHVyOiAjMjY0XG4gICAgICAgIGN1cnNvci5jbGVhclNlbGVjdGlvbigpLmVuZFNlbGVjdGlvbigpO1xuICAgICAgICBibHVyKCk7XG4gICAgICB9KTtcbiAgICAgICQod2luZG93KS5vbignYmx1cicsIHdpbmRvd0JsdXIpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHdpbmRvd0JsdXIoKSB7IC8vIGJsdXIgZXZlbnQgYWxzbyBmaXJlZCBvbiB3aW5kb3csIGp1c3Qgc3dpdGNoaW5nXG4gICAgICBjbGVhclRpbWVvdXQoYmx1clRpbWVvdXQpOyAvLyB0YWJzL3dpbmRvd3MsIG5vdCBpbnRlbnRpb25hbCBibHVyXG4gICAgICBpZiAoY3Vyc29yLnNlbGVjdGlvbikgY3Vyc29yLnNlbGVjdGlvbi5qUS5hZGRDbGFzcygnbXEtYmx1cicpO1xuICAgICAgYmx1cigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibHVyKCkgeyAvLyBub3QgZGlyZWN0bHkgaW4gdGhlIHRleHRhcmVhIGJsdXIgaGFuZGxlciBzbyBhcyB0byBiZVxuICAgICAgY3Vyc29yLmhpZGUoKS5wYXJlbnQuYmx1cigpOyAvLyBzeW5jaHJvbm91cyB3aXRoL2luIHRoZSBzYW1lIGZyYW1lIGFzXG4gICAgICBjdHJsci5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ21xLWZvY3VzZWQnKTsgLy8gY2xlYXJpbmcvYmx1cnJpbmcgc2VsZWN0aW9uXG4gICAgICAkKHdpbmRvdykub2ZmKCdibHVyJywgd2luZG93Qmx1cik7XG4gICAgfVxuICAgIGN0cmxyLmJsdXJyZWQgPSB0cnVlO1xuICAgIGN1cnNvci5oaWRlKCkucGFyZW50LmJsdXIoKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIFRPRE86IEkgd2FudGVkIHRvIG1vdmUgTWF0aEJsb2NrOjpmb2N1cyBhbmQgYmx1ciBoZXJlLCBpdCB3b3VsZCBjbGVhblxuICogdXAgbG90cyBvZiBzdHVmZiBsaWtlLCBUZXh0QmxvY2s6OmZvY3VzIGlzIHNldCB0byBNYXRoQmxvY2s6OmZvY3VzXG4gKiBhbmQgVGV4dEJsb2NrOjpibHVyIGNhbGxzIE1hdGhCbG9jazo6Ymx1ciwgd2hlbiBpbnN0ZWFkIHRoZXkgY291bGRcbiAqIHVzZSBpbmhlcml0YW5jZSBhbmQgc3VwZXJfLlxuICpcbiAqIFByb2JsZW0gaXMsIHRoZXJlJ3MgbG90cyBvZiBjYWxscyB0byAuZm9jdXMoKS8uYmx1cigpIG9uIG5vZGVzXG4gKiBvdXRzaWRlIENvbnRyb2xsZXI6OmZvY3VzQmx1ckV2ZW50cygpLCBzdWNoIGFzIC5wb3N0T3JkZXIoJ2JsdXInKSBvblxuICogaW5zZXJ0aW9uLCB3aGljaCBpZiBNYXRoQmxvY2s6OmJsdXIgYmVjb21lcyBOb2RlOjpibHVyLCB3b3VsZCBhZGQgdGhlXG4gKiAnYmx1cicgQ1NTIGNsYXNzIHRvIGFsbCBTeW1ib2wncyAoYmVjYXVzZSAuaXNFbXB0eSgpIGlzIHRydWUgZm9yIGFsbFxuICogb2YgdGhlbSkuXG4gKlxuICogSSdtIG5vdCBldmVuIHN1cmUgdGhlcmUgYXJlbid0IG90aGVyIHRyb3VibGVzb21lIGNhbGxzIHRvIC5mb2N1cygpIG9yXG4gKiAuYmx1cigpLCBzbyB0aGlzIGlzIFRPRE8gZm9yIG5vdy5cbiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBEZWFscyB3aXRoIHRoZSBicm93c2VyIERPTSBldmVudHMgZnJvbVxuICogaW50ZXJhY3Rpb24gd2l0aCB0aGUgdHlwaXN0LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbkNvbnRyb2xsZXIub3BlbihmdW5jdGlvbihfKSB7XG4gIF8ua2V5c3Ryb2tlID0gZnVuY3Rpb24oa2V5LCBldnQpIHtcbiAgICB0aGlzLmN1cnNvci5wYXJlbnQua2V5c3Ryb2tlKGtleSwgZXZ0LCB0aGlzKTtcbiAgfTtcbn0pO1xuXG5Ob2RlLm9wZW4oZnVuY3Rpb24oXykge1xuICBfLmtleXN0cm9rZSA9IGZ1bmN0aW9uKGtleSwgZSwgY3RybHIpIHtcbiAgICB2YXIgY3Vyc29yID0gY3RybHIuY3Vyc29yO1xuXG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlICdDdHJsLVNoaWZ0LUJhY2tzcGFjZSc6XG4gICAgY2FzZSAnQ3RybC1CYWNrc3BhY2UnOlxuICAgICAgY3RybHIuY3RybERlbGV0ZURpcihMKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnU2hpZnQtQmFja3NwYWNlJzpcbiAgICBjYXNlICdCYWNrc3BhY2UnOlxuICAgICAgY3RybHIuYmFja3NwYWNlKCk7XG4gICAgICBicmVhaztcblxuICAgIC8vIFRhYiBvciBFc2MgLT4gZ28gb25lIGJsb2NrIHJpZ2h0IGlmIGl0IGV4aXN0cywgZWxzZSBlc2NhcGUgcmlnaHQuXG4gICAgY2FzZSAnRXNjJzpcbiAgICBjYXNlICdUYWInOlxuICAgICAgY3RybHIuZXNjYXBlRGlyKFIsIGtleSwgZSk7XG4gICAgICByZXR1cm47XG5cbiAgICAvLyBTaGlmdC1UYWIgLT4gZ28gb25lIGJsb2NrIGxlZnQgaWYgaXQgZXhpc3RzLCBlbHNlIGVzY2FwZSBsZWZ0LlxuICAgIGNhc2UgJ1NoaWZ0LVRhYic6XG4gICAgY2FzZSAnU2hpZnQtRXNjJzpcbiAgICAgIGN0cmxyLmVzY2FwZURpcihMLCBrZXksIGUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgLy8gRW5kIC0+IG1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBibG9jay5cbiAgICBjYXNlICdFbmQnOlxuICAgICAgY3RybHIubm90aWZ5KCdtb3ZlJykuY3Vyc29yLmluc0F0UmlnaHRFbmQoY3Vyc29yLnBhcmVudCk7XG4gICAgICBicmVhaztcblxuICAgIC8vIEN0cmwtRW5kIC0+IG1vdmUgYWxsIHRoZSB3YXkgdG8gdGhlIGVuZCBvZiB0aGUgcm9vdCBibG9jay5cbiAgICBjYXNlICdDdHJsLUVuZCc6XG4gICAgICBjdHJsci5ub3RpZnkoJ21vdmUnKS5jdXJzb3IuaW5zQXRSaWdodEVuZChjdHJsci5yb290KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gU2hpZnQtRW5kIC0+IHNlbGVjdCB0byB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgIGNhc2UgJ1NoaWZ0LUVuZCc6XG4gICAgICB3aGlsZSAoY3Vyc29yW1JdKSB7XG4gICAgICAgIGN0cmxyLnNlbGVjdFJpZ2h0KCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIC8vIEN0cmwtU2hpZnQtRW5kIC0+IHNlbGVjdCB0byB0aGUgZW5kIG9mIHRoZSByb290IGJsb2NrLlxuICAgIGNhc2UgJ0N0cmwtU2hpZnQtRW5kJzpcbiAgICAgIHdoaWxlIChjdXJzb3JbUl0gfHwgY3Vyc29yLnBhcmVudCAhPT0gY3RybHIucm9vdCkge1xuICAgICAgICBjdHJsci5zZWxlY3RSaWdodCgpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICAvLyBIb21lIC0+IG1vdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSByb290IGJsb2NrIG9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgIGNhc2UgJ0hvbWUnOlxuICAgICAgY3RybHIubm90aWZ5KCdtb3ZlJykuY3Vyc29yLmluc0F0TGVmdEVuZChjdXJzb3IucGFyZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gQ3RybC1Ib21lIC0+IG1vdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgIGNhc2UgJ0N0cmwtSG9tZSc6XG4gICAgICBjdHJsci5ub3RpZnkoJ21vdmUnKS5jdXJzb3IuaW5zQXRMZWZ0RW5kKGN0cmxyLnJvb3QpO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBTaGlmdC1Ib21lIC0+IHNlbGVjdCB0byB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgY2FzZSAnU2hpZnQtSG9tZSc6XG4gICAgICB3aGlsZSAoY3Vyc29yW0xdKSB7XG4gICAgICAgIGN0cmxyLnNlbGVjdExlZnQoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gQ3RybC1TaGlmdC1Ib21lIC0+IG1vdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSByb290IGJsb2NrLlxuICAgIGNhc2UgJ0N0cmwtU2hpZnQtSG9tZSc6XG4gICAgICB3aGlsZSAoY3Vyc29yW0xdIHx8IGN1cnNvci5wYXJlbnQgIT09IGN0cmxyLnJvb3QpIHtcbiAgICAgICAgY3RybHIuc2VsZWN0TGVmdCgpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdMZWZ0JzogY3RybHIubW92ZUxlZnQoKTsgYnJlYWs7XG4gICAgY2FzZSAnU2hpZnQtTGVmdCc6IGN0cmxyLnNlbGVjdExlZnQoKTsgYnJlYWs7XG4gICAgY2FzZSAnQ3RybC1MZWZ0JzogYnJlYWs7XG5cbiAgICBjYXNlICdSaWdodCc6IGN0cmxyLm1vdmVSaWdodCgpOyBicmVhaztcbiAgICBjYXNlICdTaGlmdC1SaWdodCc6IGN0cmxyLnNlbGVjdFJpZ2h0KCk7IGJyZWFrO1xuICAgIGNhc2UgJ0N0cmwtUmlnaHQnOiBicmVhaztcblxuICAgIGNhc2UgJ1VwJzogY3RybHIubW92ZVVwKCk7IGJyZWFrO1xuICAgIGNhc2UgJ0Rvd24nOiBjdHJsci5tb3ZlRG93bigpOyBicmVhaztcblxuICAgIGNhc2UgJ1NoaWZ0LVVwJzpcbiAgICAgIGlmIChjdXJzb3JbTF0pIHtcbiAgICAgICAgd2hpbGUgKGN1cnNvcltMXSkgY3RybHIuc2VsZWN0TGVmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3RybHIuc2VsZWN0TGVmdCgpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnU2hpZnQtRG93bic6XG4gICAgICBpZiAoY3Vyc29yW1JdKSB7XG4gICAgICAgIHdoaWxlIChjdXJzb3JbUl0pIGN0cmxyLnNlbGVjdFJpZ2h0KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3RybHIuc2VsZWN0UmlnaHQoKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ0N0cmwtVXAnOiBicmVhaztcbiAgICBjYXNlICdDdHJsLURvd24nOiBicmVhaztcblxuICAgIGNhc2UgJ0N0cmwtU2hpZnQtRGVsJzpcbiAgICBjYXNlICdDdHJsLURlbCc6XG4gICAgICBjdHJsci5jdHJsRGVsZXRlRGlyKFIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdTaGlmdC1EZWwnOlxuICAgIGNhc2UgJ0RlbCc6XG4gICAgICBjdHJsci5kZWxldGVGb3J3YXJkKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ01ldGEtQSc6XG4gICAgY2FzZSAnQ3RybC1BJzpcbiAgICAgIGN0cmxyLm5vdGlmeSgnbW92ZScpLmN1cnNvci5pbnNBdFJpZ2h0RW5kKGN0cmxyLnJvb3QpO1xuICAgICAgd2hpbGUgKGN1cnNvcltMXSkgY3RybHIuc2VsZWN0TGVmdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY3RybHIuc2Nyb2xsSG9yaXooKTtcbiAgfTtcblxuICBfLm1vdmVPdXRPZiA9IC8vIGNhbGxlZCBieSBDb250cm9sbGVyOjplc2NhcGVEaXIsIG1vdmVEaXJcbiAgXy5tb3ZlVG93YXJkcyA9IC8vIGNhbGxlZCBieSBDb250cm9sbGVyOjptb3ZlRGlyXG4gIF8uZGVsZXRlT3V0T2YgPSAvLyBjYWxsZWQgYnkgQ29udHJvbGxlcjo6ZGVsZXRlRGlyXG4gIF8uZGVsZXRlVG93YXJkcyA9IC8vIGNhbGxlZCBieSBDb250cm9sbGVyOjpkZWxldGVEaXJcbiAgXy51bnNlbGVjdEludG8gPSAvLyBjYWxsZWQgYnkgQ29udHJvbGxlcjo6c2VsZWN0RGlyXG4gIF8uc2VsZWN0T3V0T2YgPSAvLyBjYWxsZWQgYnkgQ29udHJvbGxlcjo6c2VsZWN0RGlyXG4gIF8uc2VsZWN0VG93YXJkcyA9IC8vIGNhbGxlZCBieSBDb250cm9sbGVyOjpzZWxlY3REaXJcbiAgICBmdW5jdGlvbigpIHsgcHJheSgnb3ZlcnJpZGRlbiBvciBuZXZlciBjYWxsZWQgb24gdGhpcyBub2RlJyk7IH07XG59KTtcblxuQ29udHJvbGxlci5vcGVuKGZ1bmN0aW9uKF8pIHtcbiAgdGhpcy5vbk5vdGlmeShmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUgPT09ICdtb3ZlJyB8fCBlID09PSAndXBEb3duJykgdGhpcy5zaG93KCkuY2xlYXJTZWxlY3Rpb24oKTtcbiAgfSk7XG4gIF8uZXNjYXBlRGlyID0gZnVuY3Rpb24oZGlyLCBrZXksIGUpIHtcbiAgICBwcmF5RGlyZWN0aW9uKGRpcik7XG4gICAgdmFyIGN1cnNvciA9IHRoaXMuY3Vyc29yO1xuXG4gICAgLy8gb25seSBwcmV2ZW50IGRlZmF1bHQgb2YgVGFiIGlmIG5vdCBpbiB0aGUgcm9vdCBlZGl0YWJsZVxuICAgIGlmIChjdXJzb3IucGFyZW50ICE9PSB0aGlzLnJvb3QpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIHdhbnQgdG8gYmUgYSBub29wIGlmIGluIHRoZSByb290IGVkaXRhYmxlIChpbiBmYWN0LCBUYWIgaGFzIGFuIHVucmVsYXRlZFxuICAgIC8vIGRlZmF1bHQgYnJvd3NlciBhY3Rpb24gaWYgc28pXG4gICAgaWYgKGN1cnNvci5wYXJlbnQgPT09IHRoaXMucm9vdCkgcmV0dXJuO1xuXG4gICAgY3Vyc29yLnBhcmVudC5tb3ZlT3V0T2YoZGlyLCBjdXJzb3IpO1xuICAgIHJldHVybiB0aGlzLm5vdGlmeSgnbW92ZScpO1xuICB9O1xuXG4gIG9wdGlvblByb2Nlc3NvcnMubGVmdFJpZ2h0SW50b0NtZEdvZXMgPSBmdW5jdGlvbih1cGRvd24pIHtcbiAgICBpZiAodXBkb3duICYmIHVwZG93biAhPT0gJ3VwJyAmJiB1cGRvd24gIT09ICdkb3duJykge1xuICAgICAgdGhyb3cgJ1widXBcIiBvciBcImRvd25cIiByZXF1aXJlZCBmb3IgbGVmdFJpZ2h0SW50b0NtZEdvZXMgb3B0aW9uLCAnXG4gICAgICAgICAgICArICdnb3QgXCInK3VwZG93bisnXCInO1xuICAgIH1cbiAgICByZXR1cm4gdXBkb3duO1xuICB9O1xuICBfLm1vdmVEaXIgPSBmdW5jdGlvbihkaXIpIHtcbiAgICBwcmF5RGlyZWN0aW9uKGRpcik7XG4gICAgdmFyIGN1cnNvciA9IHRoaXMuY3Vyc29yLCB1cGRvd24gPSBjdXJzb3Iub3B0aW9ucy5sZWZ0UmlnaHRJbnRvQ21kR29lcztcblxuICAgIGlmIChjdXJzb3Iuc2VsZWN0aW9uKSB7XG4gICAgICBjdXJzb3IuaW5zRGlyT2YoZGlyLCBjdXJzb3Iuc2VsZWN0aW9uLmVuZHNbZGlyXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnNvcltkaXJdKSBjdXJzb3JbZGlyXS5tb3ZlVG93YXJkcyhkaXIsIGN1cnNvciwgdXBkb3duKTtcbiAgICBlbHNlIGN1cnNvci5wYXJlbnQubW92ZU91dE9mKGRpciwgY3Vyc29yLCB1cGRvd24pO1xuXG4gICAgcmV0dXJuIHRoaXMubm90aWZ5KCdtb3ZlJyk7XG4gIH07XG4gIF8ubW92ZUxlZnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubW92ZURpcihMKTsgfTtcbiAgXy5tb3ZlUmlnaHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubW92ZURpcihSKTsgfTtcblxuICAvKipcbiAgICogbW92ZVVwIGFuZCBtb3ZlRG93biBoYXZlIGFsbW9zdCBpZGVudGljYWwgYWxnb3JpdGhtczpcbiAgICogLSBmaXJzdCBjaGVjayBsZWZ0IGFuZCByaWdodCwgaWYgc28gaW5zQXRMZWZ0L1JpZ2h0RW5kIG9mIHRoZW1cbiAgICogLSBlbHNlIGNoZWNrIHRoZSBwYXJlbnQncyAndXBPdXRPZicvJ2Rvd25PdXRPZicgcHJvcGVydHk6XG4gICAqICAgKyBpZiBpdCdzIGEgZnVuY3Rpb24sIGNhbGwgaXQgd2l0aCB0aGUgY3Vyc29yIGFzIHRoZSBzb2xlIGFyZ3VtZW50IGFuZFxuICAgKiAgICAgdXNlIHRoZSByZXR1cm4gdmFsdWUgYXMgaWYgaXQgd2VyZSB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAqICAgKyBpZiBpdCdzIGEgTm9kZSwganVtcCB1cCBvciBkb3duIGludG8gaXQ6XG4gICAqICAgICAtIGlmIHRoZXJlIGlzIGEgY2FjaGVkIFBvaW50IGluIHRoZSBibG9jaywgaW5zZXJ0IHRoZXJlXG4gICAqICAgICAtIGVsc2UsIHNlZWtIb3JpeiB3aXRoaW4gdGhlIGJsb2NrIHRvIHRoZSBjdXJyZW50IHgtY29vcmRpbmF0ZSAodG8gYmVcbiAgICogICAgICAgYXMgY2xvc2UgdG8gZGlyZWN0bHkgYWJvdmUvYmVsb3cgdGhlIGN1cnJlbnQgcG9zaXRpb24gYXMgcG9zc2libGUpXG4gICAqICAgKyB1bmxlc3MgaXQncyBleGFjdGx5IGB0cnVlYCwgc3RvcCBidWJibGluZ1xuICAgKi9cbiAgXy5tb3ZlVXAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG1vdmVVcERvd24odGhpcywgJ3VwJyk7IH07XG4gIF8ubW92ZURvd24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG1vdmVVcERvd24odGhpcywgJ2Rvd24nKTsgfTtcbiAgZnVuY3Rpb24gbW92ZVVwRG93bihzZWxmLCBkaXIpIHtcbiAgICB2YXIgY3Vyc29yID0gc2VsZi5ub3RpZnkoJ3VwRG93bicpLmN1cnNvcjtcbiAgICB2YXIgZGlySW50byA9IGRpcisnSW50bycsIGRpck91dE9mID0gZGlyKydPdXRPZic7XG4gICAgaWYgKGN1cnNvcltSXVtkaXJJbnRvXSkgY3Vyc29yLmluc0F0TGVmdEVuZChjdXJzb3JbUl1bZGlySW50b10pO1xuICAgIGVsc2UgaWYgKGN1cnNvcltMXVtkaXJJbnRvXSkgY3Vyc29yLmluc0F0UmlnaHRFbmQoY3Vyc29yW0xdW2RpckludG9dKTtcbiAgICBlbHNlIHtcbiAgICAgIGN1cnNvci5wYXJlbnQuYnViYmxlKGZ1bmN0aW9uKGFuY2VzdG9yKSB7XG4gICAgICAgIHZhciBwcm9wID0gYW5jZXN0b3JbZGlyT3V0T2ZdO1xuICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykgcHJvcCA9IGFuY2VzdG9yW2Rpck91dE9mXShjdXJzb3IpO1xuICAgICAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgTm9kZSkgY3Vyc29yLmp1bXBVcERvd24oYW5jZXN0b3IsIHByb3ApO1xuICAgICAgICAgIGlmIChwcm9wICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICB0aGlzLm9uTm90aWZ5KGZ1bmN0aW9uKGUpIHsgaWYgKGUgIT09ICd1cERvd24nKSB0aGlzLnVwRG93bkNhY2hlID0ge307IH0pO1xuXG4gIHRoaXMub25Ob3RpZnkoZnVuY3Rpb24oZSkgeyBpZiAoZSA9PT0gJ2VkaXQnKSB0aGlzLnNob3coKS5kZWxldGVTZWxlY3Rpb24oKTsgfSk7XG4gIF8uZGVsZXRlRGlyID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgcHJheURpcmVjdGlvbihkaXIpO1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLmN1cnNvcjtcblxuICAgIHZhciBoYWRTZWxlY3Rpb24gPSBjdXJzb3Iuc2VsZWN0aW9uO1xuICAgIHRoaXMubm90aWZ5KCdlZGl0Jyk7IC8vIGRlbGV0ZXMgc2VsZWN0aW9uIGlmIHByZXNlbnRcbiAgICBpZiAoIWhhZFNlbGVjdGlvbikge1xuICAgICAgaWYgKGN1cnNvcltkaXJdKSBjdXJzb3JbZGlyXS5kZWxldGVUb3dhcmRzKGRpciwgY3Vyc29yKTtcbiAgICAgIGVsc2UgY3Vyc29yLnBhcmVudC5kZWxldGVPdXRPZihkaXIsIGN1cnNvcik7XG4gICAgfVxuXG4gICAgaWYgKGN1cnNvcltMXS5zaWJsaW5nRGVsZXRlZCkgY3Vyc29yW0xdLnNpYmxpbmdEZWxldGVkKGN1cnNvci5vcHRpb25zLCBSKTtcbiAgICBpZiAoY3Vyc29yW1JdLnNpYmxpbmdEZWxldGVkKSBjdXJzb3JbUl0uc2libGluZ0RlbGV0ZWQoY3Vyc29yLm9wdGlvbnMsIEwpO1xuICAgIGN1cnNvci5wYXJlbnQuYnViYmxlKCdyZWZsb3cnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfLmN0cmxEZWxldGVEaXIgPSBmdW5jdGlvbihkaXIpIHtcbiAgICBwcmF5RGlyZWN0aW9uKGRpcik7XG4gICAgdmFyIGN1cnNvciA9IHRoaXMuY3Vyc29yO1xuICAgIGlmICghY3Vyc29yW0xdIHx8IGN1cnNvci5zZWxlY3Rpb24pIHJldHVybiBjdHJsci5kZWxldGVEaXIoKTtcblxuICAgIHRoaXMubm90aWZ5KCdlZGl0Jyk7XG4gICAgRnJhZ21lbnQoY3Vyc29yLnBhcmVudC5lbmRzW0xdLCBjdXJzb3JbTF0pLnJlbW92ZSgpO1xuICAgIGN1cnNvci5pbnNBdERpckVuZChMLCBjdXJzb3IucGFyZW50KTtcblxuICAgIGlmIChjdXJzb3JbTF0uc2libGluZ0RlbGV0ZWQpIGN1cnNvcltMXS5zaWJsaW5nRGVsZXRlZChjdXJzb3Iub3B0aW9ucywgUik7XG4gICAgaWYgKGN1cnNvcltSXS5zaWJsaW5nRGVsZXRlZCkgY3Vyc29yW1JdLnNpYmxpbmdEZWxldGVkKGN1cnNvci5vcHRpb25zLCBMKTtcbiAgICBjdXJzb3IucGFyZW50LmJ1YmJsZSgncmVmbG93Jyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgXy5iYWNrc3BhY2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGVsZXRlRGlyKEwpOyB9O1xuICBfLmRlbGV0ZUZvcndhcmQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGVsZXRlRGlyKFIpOyB9O1xuXG4gIHRoaXMub25Ob3RpZnkoZnVuY3Rpb24oZSkgeyBpZiAoZSAhPT0gJ3NlbGVjdCcpIHRoaXMuZW5kU2VsZWN0aW9uKCk7IH0pO1xuICBfLnNlbGVjdERpciA9IGZ1bmN0aW9uKGRpcikge1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLm5vdGlmeSgnc2VsZWN0JykuY3Vyc29yLCBzZWxuID0gY3Vyc29yLnNlbGVjdGlvbjtcbiAgICBwcmF5RGlyZWN0aW9uKGRpcik7XG5cbiAgICBpZiAoIWN1cnNvci5hbnRpY3Vyc29yKSBjdXJzb3Iuc3RhcnRTZWxlY3Rpb24oKTtcblxuICAgIHZhciBub2RlID0gY3Vyc29yW2Rpcl07XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIC8vIFwiaWYgbm9kZSB3ZSdyZSBzZWxlY3RpbmcgdG93YXJkcyBpcyBpbnNpZGUgc2VsZWN0aW9uIChoZW5jZSByZXRyYWN0aW5nKVxuICAgICAgLy8gYW5kIGlzIG9uIHRoZSAqZmFyIHNpZGUqIG9mIHRoZSBzZWxlY3Rpb24gKGhlbmNlIGlzIG9ubHkgbm9kZSBzZWxlY3RlZClcbiAgICAgIC8vIGFuZCB0aGUgYW50aWN1cnNvciBpcyAqaW5zaWRlKiB0aGF0IG5vZGUsIG5vdCBqdXN0IG9uIHRoZSBvdGhlciBzaWRlXCJcbiAgICAgIGlmIChzZWxuICYmIHNlbG4uZW5kc1tkaXJdID09PSBub2RlICYmIGN1cnNvci5hbnRpY3Vyc29yWy1kaXJdICE9PSBub2RlKSB7XG4gICAgICAgIG5vZGUudW5zZWxlY3RJbnRvKGRpciwgY3Vyc29yKTtcbiAgICAgIH1cbiAgICAgIGVsc2Ugbm9kZS5zZWxlY3RUb3dhcmRzKGRpciwgY3Vyc29yKTtcbiAgICB9XG4gICAgZWxzZSBjdXJzb3IucGFyZW50LnNlbGVjdE91dE9mKGRpciwgY3Vyc29yKTtcblxuICAgIGN1cnNvci5jbGVhclNlbGVjdGlvbigpO1xuICAgIGN1cnNvci5zZWxlY3QoKSB8fCBjdXJzb3Iuc2hvdygpO1xuICB9O1xuICBfLnNlbGVjdExlZnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VsZWN0RGlyKEwpOyB9O1xuICBfLnNlbGVjdFJpZ2h0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbGVjdERpcihSKTsgfTtcbn0pO1xuLy8gUGFyc2VyIE1hdGhDb21tYW5kXG52YXIgbGF0ZXhNYXRoUGFyc2VyID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBjb21tYW5kVG9CbG9jayhjbWQpIHtcbiAgICB2YXIgYmxvY2sgPSBNYXRoQmxvY2soKTtcbiAgICBjbWQuYWRvcHQoYmxvY2ssIDAsIDApO1xuICAgIHJldHVybiBibG9jaztcbiAgfVxuICBmdW5jdGlvbiBqb2luQmxvY2tzKGJsb2Nrcykge1xuICAgIHZhciBmaXJzdEJsb2NrID0gYmxvY2tzWzBdIHx8IE1hdGhCbG9jaygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBibG9ja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGJsb2Nrc1tpXS5jaGlsZHJlbigpLmFkb3B0KGZpcnN0QmxvY2ssIGZpcnN0QmxvY2suZW5kc1tSXSwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0QmxvY2s7XG4gIH1cblxuICB2YXIgc3RyaW5nID0gUGFyc2VyLnN0cmluZztcbiAgdmFyIHJlZ2V4ID0gUGFyc2VyLnJlZ2V4O1xuICB2YXIgbGV0dGVyID0gUGFyc2VyLmxldHRlcjtcbiAgdmFyIGFueSA9IFBhcnNlci5hbnk7XG4gIHZhciBvcHRXaGl0ZXNwYWNlID0gUGFyc2VyLm9wdFdoaXRlc3BhY2U7XG4gIHZhciBzdWNjZWVkID0gUGFyc2VyLnN1Y2NlZWQ7XG4gIHZhciBmYWlsID0gUGFyc2VyLmZhaWw7XG5cbiAgLy8gUGFyc2VycyB5aWVsZGluZyBlaXRoZXIgTWF0aENvbW1hbmRzLCBvciBGcmFnbWVudHMgb2YgTWF0aENvbW1hbmRzXG4gIC8vICAgKGVpdGhlciB3YXksIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBhZG9wdGVkIGJ5IGEgTWF0aEJsb2NrKVxuICB2YXIgdmFyaWFibGUgPSBsZXR0ZXIubWFwKGZ1bmN0aW9uKGMpIHsgcmV0dXJuIExldHRlcihjKTsgfSk7XG4gIHZhciBzeW1ib2wgPSByZWdleCgvXlteJHt9XFxcXF9eXS8pLm1hcChmdW5jdGlvbihjKSB7IHJldHVybiBWYW5pbGxhU3ltYm9sKGMpOyB9KTtcblxuICB2YXIgY29udHJvbFNlcXVlbmNlID1cbiAgICByZWdleCgvXlteXFxcXGEtZWctekEtWl0vKSAvLyBob3RmaXggIzE2NDsgbWF0Y2ggTWF0aEJsb2NrOjp3cml0ZVxuICAgIC5vcihzdHJpbmcoJ1xcXFwnKS50aGVuKFxuICAgICAgcmVnZXgoL15bYS16XSsvaSlcbiAgICAgIC5vcihyZWdleCgvXlxccysvKS5yZXN1bHQoJyAnKSlcbiAgICAgIC5vcihhbnkpXG4gICAgKSkudGhlbihmdW5jdGlvbihjdHJsU2VxKSB7XG4gICAgICB2YXIgY21kS2xhc3MgPSBMYXRleENtZHNbY3RybFNlcV07XG5cbiAgICAgIGlmIChjbWRLbGFzcykge1xuICAgICAgICByZXR1cm4gY21kS2xhc3MoY3RybFNlcSkucGFyc2VyKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoJ3Vua25vd24gY29tbWFuZDogXFxcXCcrY3RybFNlcSk7XG4gICAgICB9XG4gICAgfSlcbiAgO1xuXG4gIHZhciBjb21tYW5kID1cbiAgICBjb250cm9sU2VxdWVuY2VcbiAgICAub3IodmFyaWFibGUpXG4gICAgLm9yKHN5bWJvbClcbiAgO1xuXG4gIC8vIFBhcnNlcnMgeWllbGRpbmcgTWF0aEJsb2Nrc1xuICB2YXIgbWF0aEdyb3VwID0gc3RyaW5nKCd7JykudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIG1hdGhTZXF1ZW5jZTsgfSkuc2tpcChzdHJpbmcoJ30nKSk7XG4gIHZhciBtYXRoQmxvY2sgPSBvcHRXaGl0ZXNwYWNlLnRoZW4obWF0aEdyb3VwLm9yKGNvbW1hbmQubWFwKGNvbW1hbmRUb0Jsb2NrKSkpO1xuICB2YXIgbWF0aFNlcXVlbmNlID0gbWF0aEJsb2NrLm1hbnkoKS5tYXAoam9pbkJsb2Nrcykuc2tpcChvcHRXaGl0ZXNwYWNlKTtcblxuICB2YXIgb3B0TWF0aEJsb2NrID1cbiAgICBzdHJpbmcoJ1snKS50aGVuKFxuICAgICAgbWF0aEJsb2NrLnRoZW4oZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrLmpvaW4oJ2xhdGV4JykgIT09ICddJyA/IHN1Y2NlZWQoYmxvY2spIDogZmFpbCgpO1xuICAgICAgfSlcbiAgICAgIC5tYW55KCkubWFwKGpvaW5CbG9ja3MpLnNraXAob3B0V2hpdGVzcGFjZSlcbiAgICApLnNraXAoc3RyaW5nKCddJykpXG4gIDtcblxuICB2YXIgbGF0ZXhNYXRoID0gbWF0aFNlcXVlbmNlO1xuXG4gIGxhdGV4TWF0aC5ibG9jayA9IG1hdGhCbG9jaztcbiAgbGF0ZXhNYXRoLm9wdEJsb2NrID0gb3B0TWF0aEJsb2NrO1xuICByZXR1cm4gbGF0ZXhNYXRoO1xufSkoKTtcblxuQ29udHJvbGxlci5vcGVuKGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmV4cG9ydExhdGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5sYXRleCgpLnJlcGxhY2UoLyhcXFxcW2Etel0rKSAoPyFbYS16XSkvaWcsJyQxJyk7XG4gIH07XG4gIF8ud3JpdGVMYXRleCA9IGZ1bmN0aW9uKGxhdGV4KSB7XG4gICAgdmFyIGN1cnNvciA9IHRoaXMubm90aWZ5KCdlZGl0JykuY3Vyc29yO1xuXG4gICAgdmFyIGFsbCA9IFBhcnNlci5hbGw7XG4gICAgdmFyIGVvZiA9IFBhcnNlci5lb2Y7XG5cbiAgICB2YXIgYmxvY2sgPSBsYXRleE1hdGhQYXJzZXIuc2tpcChlb2YpLm9yKGFsbC5yZXN1bHQoZmFsc2UpKS5wYXJzZShsYXRleCk7XG5cbiAgICBpZiAoYmxvY2sgJiYgIWJsb2NrLmlzRW1wdHkoKSkge1xuICAgICAgYmxvY2suY2hpbGRyZW4oKS5hZG9wdChjdXJzb3IucGFyZW50LCBjdXJzb3JbTF0sIGN1cnNvcltSXSk7XG4gICAgICB2YXIgalEgPSBibG9jay5qUWl6ZSgpO1xuICAgICAgalEuaW5zZXJ0QmVmb3JlKGN1cnNvci5qUSk7XG4gICAgICBjdXJzb3JbTF0gPSBibG9jay5lbmRzW1JdO1xuICAgICAgYmxvY2suZmluYWxpemVJbnNlcnQoY3Vyc29yLm9wdGlvbnMsIGN1cnNvcik7XG4gICAgICBpZiAoYmxvY2suZW5kc1tSXVtSXS5zaWJsaW5nQ3JlYXRlZCkgYmxvY2suZW5kc1tSXVtSXS5zaWJsaW5nQ3JlYXRlZChjdXJzb3Iub3B0aW9ucywgTCk7XG4gICAgICBpZiAoYmxvY2suZW5kc1tMXVtMXS5zaWJsaW5nQ3JlYXRlZCkgYmxvY2suZW5kc1tMXVtMXS5zaWJsaW5nQ3JlYXRlZChjdXJzb3Iub3B0aW9ucywgUik7XG4gICAgICBjdXJzb3IucGFyZW50LmJ1YmJsZSgncmVmbG93Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF8ucmVuZGVyTGF0ZXhNYXRoID0gZnVuY3Rpb24obGF0ZXgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdCwgY3Vyc29yID0gdGhpcy5jdXJzb3I7XG5cbiAgICB2YXIgYWxsID0gUGFyc2VyLmFsbDtcbiAgICB2YXIgZW9mID0gUGFyc2VyLmVvZjtcblxuICAgIHZhciBibG9jayA9IGxhdGV4TWF0aFBhcnNlci5za2lwKGVvZikub3IoYWxsLnJlc3VsdChmYWxzZSkpLnBhcnNlKGxhdGV4KTtcblxuICAgIHJvb3QuZWFjaENoaWxkKCdwb3N0T3JkZXInLCAnZGlzcG9zZScpO1xuICAgIHJvb3QuZW5kc1tMXSA9IHJvb3QuZW5kc1tSXSA9IDA7XG5cbiAgICBpZiAoYmxvY2spIHtcbiAgICAgIGJsb2NrLmNoaWxkcmVuKCkuYWRvcHQocm9vdCwgMCwgMCk7XG4gICAgfVxuXG4gICAgdmFyIGpRID0gcm9vdC5qUTtcblxuICAgIGlmIChibG9jaykge1xuICAgICAgdmFyIGh0bWwgPSBibG9jay5qb2luKCdodG1sJyk7XG4gICAgICBqUS5odG1sKGh0bWwpO1xuICAgICAgcm9vdC5qUWl6ZShqUS5jaGlsZHJlbigpKTtcbiAgICAgIHJvb3QuZmluYWxpemVJbnNlcnQoY3Vyc29yLm9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGpRLmVtcHR5KCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGN1cnNvci5zZWxlY3Rpb247XG4gICAgY3Vyc29yLmluc0F0UmlnaHRFbmQocm9vdCk7XG4gIH07XG4gIF8ucmVuZGVyTGF0ZXhUZXh0ID0gZnVuY3Rpb24obGF0ZXgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdCwgY3Vyc29yID0gdGhpcy5jdXJzb3I7XG5cbiAgICByb290LmpRLmNoaWxkcmVuKCkuc2xpY2UoMSkucmVtb3ZlKCk7XG4gICAgcm9vdC5lYWNoQ2hpbGQoJ3Bvc3RPcmRlcicsICdkaXNwb3NlJyk7XG4gICAgcm9vdC5lbmRzW0xdID0gcm9vdC5lbmRzW1JdID0gMDtcbiAgICBkZWxldGUgY3Vyc29yLnNlbGVjdGlvbjtcbiAgICBjdXJzb3Iuc2hvdygpLmluc0F0UmlnaHRFbmQocm9vdCk7XG5cbiAgICB2YXIgcmVnZXggPSBQYXJzZXIucmVnZXg7XG4gICAgdmFyIHN0cmluZyA9IFBhcnNlci5zdHJpbmc7XG4gICAgdmFyIGVvZiA9IFBhcnNlci5lb2Y7XG4gICAgdmFyIGFsbCA9IFBhcnNlci5hbGw7XG5cbiAgICAvLyBQYXJzZXIgUm9vdE1hdGhDb21tYW5kXG4gICAgdmFyIG1hdGhNb2RlID0gc3RyaW5nKCckJykudGhlbihsYXRleE1hdGhQYXJzZXIpXG4gICAgICAvLyBiZWNhdXNlIFRlWCBpcyBpbnNhbmUsIG1hdGggbW9kZSBkb2Vzbid0IG5lY2Vzc2FyaWx5XG4gICAgICAvLyBoYXZlIHRvIGVuZC4gIFNvIHdlIGFsbG93IGZvciB0aGUgY2FzZSB0aGF0IG1hdGggbW9kZVxuICAgICAgLy8gY29udGludWVzIHRvIHRoZSBlbmQgb2YgdGhlIHN0cmVhbS5cbiAgICAgIC5za2lwKHN0cmluZygnJCcpLm9yKGVvZikpXG4gICAgICAubWFwKGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICAgIC8vIEhBQ0sgRklYTUU6IHRoaXMgc2hvdWxkbid0IGhhdmUgdG8gaGF2ZSBhY2Nlc3MgdG8gY3Vyc29yXG4gICAgICAgIHZhciByb290TWF0aENvbW1hbmQgPSBSb290TWF0aENvbW1hbmQoY3Vyc29yKTtcblxuICAgICAgICByb290TWF0aENvbW1hbmQuY3JlYXRlQmxvY2tzKCk7XG4gICAgICAgIHZhciByb290TWF0aEJsb2NrID0gcm9vdE1hdGhDb21tYW5kLmVuZHNbTF07XG4gICAgICAgIGJsb2NrLmNoaWxkcmVuKCkuYWRvcHQocm9vdE1hdGhCbG9jaywgMCwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHJvb3RNYXRoQ29tbWFuZDtcbiAgICAgIH0pXG4gICAgO1xuXG4gICAgdmFyIGVzY2FwZWREb2xsYXIgPSBzdHJpbmcoJ1xcXFwkJykucmVzdWx0KCckJyk7XG4gICAgdmFyIHRleHRDaGFyID0gZXNjYXBlZERvbGxhci5vcihyZWdleCgvXlteJF0vKSkubWFwKFZhbmlsbGFTeW1ib2wpO1xuICAgIHZhciBsYXRleFRleHQgPSBtYXRoTW9kZS5vcih0ZXh0Q2hhcikubWFueSgpO1xuICAgIHZhciBjb21tYW5kcyA9IGxhdGV4VGV4dC5za2lwKGVvZikub3IoYWxsLnJlc3VsdChmYWxzZSkpLnBhcnNlKGxhdGV4KTtcblxuICAgIGlmIChjb21tYW5kcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb21tYW5kc1tpXS5hZG9wdChyb290LCByb290LmVuZHNbUl0sIDApO1xuICAgICAgfVxuXG4gICAgICByb290LmpRaXplKCkuYXBwZW5kVG8ocm9vdC5qUSk7XG5cbiAgICAgIHJvb3QuZmluYWxpemVJbnNlcnQoY3Vyc29yLm9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbn0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBEZWFscyB3aXRoIG1vdXNlIGV2ZW50cyBmb3IgY2xpY2tpbmcsIGRyYWctdG8tc2VsZWN0XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuQ29udHJvbGxlci5vcGVuKGZ1bmN0aW9uKF8pIHtcbiAgXy5kZWxlZ2F0ZU1vdXNlRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVsdGltYXRlUm9vdGpRID0gdGhpcy5yb290LmpRO1xuICAgIC8vZHJhZy10by1zZWxlY3QgZXZlbnQgaGFuZGxpbmdcbiAgICB0aGlzLmNvbnRhaW5lci5iaW5kKCdtb3VzZWRvd24ubWF0aHF1aWxsJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHJvb3RqUSA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5tcS1yb290LWJsb2NrJyk7XG4gICAgICB2YXIgcm9vdCA9IE5vZGUuYnlJZFtyb290alEuYXR0cihtcUJsb2NrSWQpIHx8IHVsdGltYXRlUm9vdGpRLmF0dHIobXFCbG9ja0lkKV07XG4gICAgICB2YXIgY3RybHIgPSByb290LmNvbnRyb2xsZXIsIGN1cnNvciA9IGN0cmxyLmN1cnNvciwgYmxpbmsgPSBjdXJzb3IuYmxpbms7XG4gICAgICB2YXIgdGV4dGFyZWFTcGFuID0gY3RybHIudGV4dGFyZWFTcGFuLCB0ZXh0YXJlYSA9IGN0cmxyLnRleHRhcmVhO1xuXG4gICAgICB2YXIgdGFyZ2V0O1xuICAgICAgZnVuY3Rpb24gbW91c2Vtb3ZlKGUpIHsgdGFyZ2V0ID0gJChlLnRhcmdldCk7IH1cbiAgICAgIGZ1bmN0aW9uIGRvY21vdXNlbW92ZShlKSB7XG4gICAgICAgIGlmICghY3Vyc29yLmFudGljdXJzb3IpIGN1cnNvci5zdGFydFNlbGVjdGlvbigpO1xuICAgICAgICBjdHJsci5zZWVrKHRhcmdldCwgZS5wYWdlWCwgZS5wYWdlWSkuY3Vyc29yLnNlbGVjdCgpO1xuICAgICAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICAvLyBvdXRzaWRlIHJvb3RqUSwgdGhlIE1hdGhRdWlsbCBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRhcmdldCAoaWYgYW55KVxuICAgICAgLy8gd29uJ3QgYmUgaW5zaWRlIHRoaXMgcm9vdCwgc28gZG9uJ3QgbWlzbGVhZCBDb250cm9sbGVyOjpzZWVrIHdpdGggaXRcblxuICAgICAgZnVuY3Rpb24gbW91c2V1cChlKSB7XG4gICAgICAgIGN1cnNvci5ibGluayA9IGJsaW5rO1xuICAgICAgICBpZiAoIWN1cnNvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY3RybHIuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGN1cnNvci5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGV4dGFyZWFTcGFuLmRldGFjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlbGV0ZSB0aGUgbW91c2UgaGFuZGxlcnMgbm93IHRoYXQgd2UncmUgbm90IGRyYWdnaW5nIGFueW1vcmVcbiAgICAgICAgcm9vdGpRLnVuYmluZCgnbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICAgICAgJChlLnRhcmdldC5vd25lckRvY3VtZW50KS51bmJpbmQoJ21vdXNlbW92ZScsIGRvY21vdXNlbW92ZSkudW5iaW5kKCdtb3VzZXVwJywgbW91c2V1cCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdHJsci5ibHVycmVkKSB7XG4gICAgICAgIGlmICghY3RybHIuZWRpdGFibGUpIHJvb3RqUS5wcmVwZW5kKHRleHRhcmVhU3Bhbik7XG4gICAgICAgIHRleHRhcmVhLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIGRvZXNuJ3Qgd29yayBpbiBJRVxcdTIyNjQ4LCBidXQgaXQncyBhIG9uZS1saW5lIGZpeDpcbiAgICAgIGUudGFyZ2V0LnVuc2VsZWN0YWJsZSA9IHRydWU7IC8vIGh0dHA6Ly9qc2Jpbi5jb20veWFnZWtpamkvMVxuXG4gICAgICBjdXJzb3IuYmxpbmsgPSBub29wO1xuICAgICAgY3RybHIuc2VlaygkKGUudGFyZ2V0KSwgZS5wYWdlWCwgZS5wYWdlWSkuY3Vyc29yLnN0YXJ0U2VsZWN0aW9uKCk7XG5cbiAgICAgIHJvb3RqUS5tb3VzZW1vdmUobW91c2Vtb3ZlKTtcbiAgICAgICQoZS50YXJnZXQub3duZXJEb2N1bWVudCkubW91c2Vtb3ZlKGRvY21vdXNlbW92ZSkubW91c2V1cChtb3VzZXVwKTtcbiAgICAgIC8vIGxpc3RlbiBvbiBkb2N1bWVudCBub3QganVzdCBib2R5IHRvIG5vdCBvbmx5IGhlYXIgYWJvdXQgbW91c2Vtb3ZlIGFuZFxuICAgICAgLy8gbW91c2V1cCBvbiBwYWdlIG91dHNpZGUgZmllbGQsIGJ1dCBldmVuIG91dHNpZGUgcGFnZSwgZXhjZXB0IGlmcmFtZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRocXVpbGwvbWF0aHF1aWxsL2NvbW1pdC84YzUwMDI4YWZjZmZjYWNlNjU1ZDhhZTIwNDlmNmUwMjQ4MjM0NmM1I2NvbW1pdGNvbW1lbnQtNjE3NTgwMFxuICAgIH0pO1xuICB9XG59KTtcblxuQ29udHJvbGxlci5vcGVuKGZ1bmN0aW9uKF8pIHtcbiAgXy5zZWVrID0gZnVuY3Rpb24odGFyZ2V0LCBwYWdlWCwgcGFnZVkpIHtcbiAgICB2YXIgY3Vyc29yID0gdGhpcy5ub3RpZnkoJ3NlbGVjdCcpLmN1cnNvcjtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHZhciBub2RlSWQgPSB0YXJnZXQuYXR0cihtcUJsb2NrSWQpIHx8IHRhcmdldC5hdHRyKG1xQ21kSWQpO1xuICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgdmFyIHRhcmdldFBhcmVudCA9IHRhcmdldC5wYXJlbnQoKTtcbiAgICAgICAgbm9kZUlkID0gdGFyZ2V0UGFyZW50LmF0dHIobXFCbG9ja0lkKSB8fCB0YXJnZXRQYXJlbnQuYXR0cihtcUNtZElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5vZGUgPSBub2RlSWQgPyBOb2RlLmJ5SWRbbm9kZUlkXSA6IHRoaXMucm9vdDtcbiAgICBwcmF5KCdub2RlSWQgaXMgdGhlIGlkIG9mIHNvbWUgTm9kZSB0aGF0IGV4aXN0cycsIG5vZGUpO1xuXG4gICAgLy8gZG9uJ3QgY2xlYXIgc2VsZWN0aW9uIHVudGlsIGFmdGVyIGdldHRpbmcgbm9kZSBmcm9tIHRhcmdldCwgaW4gY2FzZVxuICAgIC8vIHRhcmdldCB3YXMgc2VsZWN0aW9uIHNwYW4sIG90aGVyd2lzZSB0YXJnZXQgd2lsbCBoYXZlIG5vIHBhcmVudCBhbmQgd2lsbFxuICAgIC8vIHNlZWsgZnJvbSByb290LCB3aGljaCBpcyBsZXNzIGFjY3VyYXRlIChlLmcuIGZyYWN0aW9uKVxuICAgIGN1cnNvci5jbGVhclNlbGVjdGlvbigpLnNob3coKTtcblxuICAgIG5vZGUuc2VlayhwYWdlWCwgY3Vyc29yKTtcbiAgICB0aGlzLnNjcm9sbEhvcml6KCk7IC8vIGJlZm9yZSAuc2VsZWN0RnJvbSB3aGVuIG1vdXNlLXNlbGVjdGluZywgc29cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBoaXRzIG5vLXNlbGVjdGlvbiBjYXNlIGluIHNjcm9sbEhvcml6IGFuZCBzY3JvbGxzIHNsb3dlclxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEhvcml6b250YWwgcGFubmluZyBmb3IgZWRpdGFibGUgZmllbGRzIHRoYXRcbiAqIG92ZXJmbG93IHRoZWlyIHdpZHRoXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuQ29udHJvbGxlci5vcGVuKGZ1bmN0aW9uKF8pIHtcbiAgXy5zY3JvbGxIb3JpeiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLmN1cnNvciwgc2VsbiA9IGN1cnNvci5zZWxlY3Rpb247XG4gICAgdmFyIHJvb3RSZWN0ID0gdGhpcy5yb290LmpRWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghc2Vsbikge1xuICAgICAgdmFyIHggPSBjdXJzb3IualFbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgIGlmICh4ID4gcm9vdFJlY3QucmlnaHQgLSAyMCkgdmFyIHNjcm9sbEJ5ID0geCAtIChyb290UmVjdC5yaWdodCAtIDIwKTtcbiAgICAgIGVsc2UgaWYgKHggPCByb290UmVjdC5sZWZ0ICsgMjApIHZhciBzY3JvbGxCeSA9IHggLSAocm9vdFJlY3QubGVmdCArIDIwKTtcbiAgICAgIGVsc2UgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciByZWN0ID0gc2Vsbi5qUVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBvdmVyTGVmdCA9IHJlY3QubGVmdCAtIChyb290UmVjdC5sZWZ0ICsgMjApO1xuICAgICAgdmFyIG92ZXJSaWdodCA9IHJlY3QucmlnaHQgLSAocm9vdFJlY3QucmlnaHQgLSAyMCk7XG4gICAgICBpZiAoc2Vsbi5lbmRzW0xdID09PSBjdXJzb3JbUl0pIHtcbiAgICAgICAgaWYgKG92ZXJMZWZ0IDwgMCkgdmFyIHNjcm9sbEJ5ID0gb3ZlckxlZnQ7XG4gICAgICAgIGVsc2UgaWYgKG92ZXJSaWdodCA+IDApIHtcbiAgICAgICAgICBpZiAocmVjdC5sZWZ0IC0gb3ZlclJpZ2h0IDwgcm9vdFJlY3QubGVmdCArIDIwKSB2YXIgc2Nyb2xsQnkgPSBvdmVyTGVmdDtcbiAgICAgICAgICBlbHNlIHZhciBzY3JvbGxCeSA9IG92ZXJSaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAob3ZlclJpZ2h0ID4gMCkgdmFyIHNjcm9sbEJ5ID0gb3ZlclJpZ2h0O1xuICAgICAgICBlbHNlIGlmIChvdmVyTGVmdCA8IDApIHtcbiAgICAgICAgICBpZiAocmVjdC5yaWdodCAtIG92ZXJMZWZ0ID4gcm9vdFJlY3QucmlnaHQgLSAyMCkgdmFyIHNjcm9sbEJ5ID0gb3ZlclJpZ2h0O1xuICAgICAgICAgIGVsc2UgdmFyIHNjcm9sbEJ5ID0gb3ZlckxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucm9vdC5qUS5zdG9wKCkuYW5pbWF0ZSh7IHNjcm9sbExlZnQ6ICcrPScgKyBzY3JvbGxCeX0sIDEwMCk7XG4gIH07XG59KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1hbmFnZSB0aGUgTWF0aFF1aWxsIGluc3RhbmNlJ3MgdGV4dGFyZWFcbiAqIChhcyBvd25lZCBieSB0aGUgQ29udHJvbGxlcilcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuQ29udHJvbGxlci5vcGVuKGZ1bmN0aW9uKF8pIHtcbiAgT3B0aW9ucy5wLnN1YnN0aXR1dGVUZXh0YXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAkKCc8dGV4dGFyZWEgYXV0b2NhcGl0YWxpemU9b2ZmIGF1dG9jb21wbGV0ZT1vZmYgYXV0b2NvcnJlY3Q9b2ZmICcgK1xuICAgICAgICAgICAgICAgJ3NwZWxsY2hlY2s9ZmFsc2UgeC1wYWxtLWRpc2FibGUtc3RlLWFsbD10cnVlIC8+JylbMF07XG4gIH07XG4gIF8uY3JlYXRlVGV4dGFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGV4dGFyZWFTcGFuID0gdGhpcy50ZXh0YXJlYVNwYW4gPSAkKCc8c3BhbiBjbGFzcz1cIm1xLXRleHRhcmVhXCI+PC9zcGFuPicpLFxuICAgICAgdGV4dGFyZWEgPSB0aGlzLm9wdGlvbnMuc3Vic3RpdHV0ZVRleHRhcmVhKCk7XG4gICAgaWYgKCF0ZXh0YXJlYS5ub2RlVHlwZSkge1xuICAgICAgdGhyb3cgJ3N1YnN0aXR1dGVUZXh0YXJlYSgpIG11c3QgcmV0dXJuIGEgRE9NIGVsZW1lbnQsIGdvdCAnICsgdGV4dGFyZWE7XG4gICAgfVxuICAgIHRleHRhcmVhID0gdGhpcy50ZXh0YXJlYSA9ICQodGV4dGFyZWEpLmFwcGVuZFRvKHRleHRhcmVhU3Bhbik7XG5cbiAgICB2YXIgY3RybHIgPSB0aGlzO1xuICAgIGN0cmxyLmN1cnNvci5zZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24oKSB7IGN0cmxyLnNlbGVjdGlvbkNoYW5nZWQoKTsgfTtcbiAgICBjdHJsci5jb250YWluZXIuYmluZCgnY29weScsIGZ1bmN0aW9uKCkgeyBjdHJsci5zZXRUZXh0YXJlYVNlbGVjdGlvbigpOyB9KTtcbiAgfTtcbiAgXy5zZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0cmxyID0gdGhpcztcbiAgICBmb3JjZUlFUmVkcmF3KGN0cmxyLmNvbnRhaW5lclswXSk7XG5cbiAgICAvLyB0aHJvdHRsZSBjYWxscyB0byBzZXRUZXh0YXJlYVNlbGVjdGlvbigpLCBiZWNhdXNlIHNldHRpbmcgdGV4dGFyZWEudmFsdWVcbiAgICAvLyBhbmQvb3IgY2FsbGluZyB0ZXh0YXJlYS5zZWxlY3QoKSBjYW4gaGF2ZSBhbm9tYWxvdXNseSBiYWQgcGVyZm9ybWFuY2U6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhxdWlsbC9tYXRocXVpbGwvaXNzdWVzLzQzI2lzc3VlY29tbWVudC0xMzk5MDgwXG4gICAgaWYgKGN0cmxyLnRleHRhcmVhU2VsZWN0aW9uVGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHJsci50ZXh0YXJlYVNlbGVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBjdHJsci5zZXRUZXh0YXJlYVNlbGVjdGlvbigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfLnNldFRleHRhcmVhU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0YXJlYVNlbGVjdGlvblRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGxhdGV4ID0gJyc7XG4gICAgaWYgKHRoaXMuY3Vyc29yLnNlbGVjdGlvbikge1xuICAgICAgbGF0ZXggPSB0aGlzLmN1cnNvci5zZWxlY3Rpb24uam9pbignbGF0ZXgnKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhdGVsZXNzQ2xpcGJvYXJkKSB7XG4gICAgICAgIC8vIEZJWE1FOiBsaWtlIHBhc3RlLCBvbmx5IHRoaXMgd29ya3MgZm9yIG1hdGggZmllbGRzOyBzaG91bGQgYXNrIHBhcmVudFxuICAgICAgICBsYXRleCA9ICckJyArIGxhdGV4ICsgJyQnO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNlbGVjdEZuKGxhdGV4KTtcbiAgfTtcbiAgXy5zdGF0aWNNYXRoVGV4dGFyZWFFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3RybHIgPSB0aGlzLCByb290ID0gY3RybHIucm9vdCwgY3Vyc29yID0gY3RybHIuY3Vyc29yLFxuICAgICAgdGV4dGFyZWEgPSBjdHJsci50ZXh0YXJlYSwgdGV4dGFyZWFTcGFuID0gY3RybHIudGV4dGFyZWFTcGFuO1xuXG4gICAgdGhpcy5jb250YWluZXIucHJlcGVuZCgnPHNwYW4gY2xhc3M9XCJtcS1zZWxlY3RhYmxlXCI+JCcrY3RybHIuZXhwb3J0TGF0ZXgoKSsnJDwvc3Bhbj4nKTtcbiAgICBjdHJsci5ibHVycmVkID0gdHJ1ZTtcbiAgICB0ZXh0YXJlYS5iaW5kKCdjdXQgcGFzdGUnLCBmYWxzZSlcbiAgICAuZm9jdXMoZnVuY3Rpb24oKSB7IGN0cmxyLmJsdXJyZWQgPSBmYWxzZTsgfSkuYmx1cihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjdXJzb3Iuc2VsZWN0aW9uKSBjdXJzb3Iuc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBzZXRUaW1lb3V0KGRldGFjaCk7IC8vZGV0YWNoaW5nIGR1cmluZyBibHVyIGV4cGxvZGVzIGluIFdlYktpdFxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIHRleHRhcmVhU3Bhbi5kZXRhY2goKTtcbiAgICAgIGN0cmxyLmJsdXJyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGN0cmxyLnNlbGVjdEZuID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgdGV4dGFyZWEudmFsKHRleHQpO1xuICAgICAgaWYgKHRleHQpIHRleHRhcmVhLnNlbGVjdCgpO1xuICAgIH07XG4gIH07XG4gIF8uZWRpdGFibGVzVGV4dGFyZWFFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3RybHIgPSB0aGlzLCByb290ID0gY3RybHIucm9vdCwgY3Vyc29yID0gY3RybHIuY3Vyc29yLFxuICAgICAgdGV4dGFyZWEgPSBjdHJsci50ZXh0YXJlYSwgdGV4dGFyZWFTcGFuID0gY3RybHIudGV4dGFyZWFTcGFuO1xuXG4gICAgdmFyIGtleWJvYXJkRXZlbnRzU2hpbSA9IHNhbmVLZXlib2FyZEV2ZW50cyh0ZXh0YXJlYSwgdGhpcyk7XG4gICAgdGhpcy5zZWxlY3RGbiA9IGZ1bmN0aW9uKHRleHQpIHsga2V5Ym9hcmRFdmVudHNTaGltLnNlbGVjdCh0ZXh0KTsgfTtcblxuICAgIHRoaXMuY29udGFpbmVyLnByZXBlbmQodGV4dGFyZWFTcGFuKVxuICAgIC5vbignY3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGN1cnNvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjdHJsci5ub3RpZnkoJ2VkaXQnKTsgLy8gZGVsZXRlcyBzZWxlY3Rpb24gaWYgcHJlc2VudFxuICAgICAgICAgIGN1cnNvci5wYXJlbnQuYnViYmxlKCdyZWZsb3cnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmZvY3VzQmx1ckV2ZW50cygpO1xuICB9O1xuICBfLnR5cGVkVGV4dCA9IGZ1bmN0aW9uKGNoKSB7XG4gICAgaWYgKGNoID09PSAnXFxuJykgcmV0dXJuIHRoaXMuaGFuZGxlKCdlbnRlcicpO1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLm5vdGlmeSgpLmN1cnNvcjtcbiAgICBjdXJzb3IucGFyZW50LndyaXRlKGN1cnNvciwgY2gpO1xuICAgIHRoaXMuc2Nyb2xsSG9yaXooKTtcbiAgfTtcbiAgXy5wYXN0ZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAvLyBUT0RPOiBkb2N1bWVudCBgc3RhdGVsZXNzQ2xpcGJvYXJkYCBjb25maWcgb3B0aW9uIGluIFJFQURNRSwgYWZ0ZXJcbiAgICAvLyBtYWtpbmcgaXQgd29yayBsaWtlIGl0IHNob3VsZCwgdGhhdCBpcywgaW4gYm90aCB0ZXh0IGFuZCBtYXRoIG1vZGVcbiAgICAvLyAoY3VycmVudGx5IG9ubHkgd29ya3MgaW4gbWF0aCBmaWVsZHMsIHNvIHdvcnNlIHRoYW4gcG9pbnRsZXNzLCBpdFxuICAgIC8vICBvbmx5IGdldHMgaW4gdGhlIHdheSBieSBcXHRleHR7fS1pZnlpbmcgcGFzdGVkIHN0dWZmIGFuZCAkLWlmeWluZ1xuICAgIC8vICBjdXQvY29waWVkIExhVGVYKVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhdGVsZXNzQ2xpcGJvYXJkKSB7XG4gICAgICBpZiAodGV4dC5zbGljZSgwLDEpID09PSAnJCcgJiYgdGV4dC5zbGljZSgtMSkgPT09ICckJykge1xuICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxLCAtMSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGV4dCA9ICdcXFxcdGV4dHsnK3RleHQrJ30nO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBGSVhNRTogdGhpcyBhbHdheXMgaW5zZXJ0cyBtYXRoIG9yIGEgVGV4dEJsb2NrLCBldmVuIGluIGEgUm9vdFRleHRCbG9ja1xuICAgIHRoaXMud3JpdGVMYXRleCh0ZXh0KS5jdXJzb3Iuc2hvdygpO1xuICB9O1xufSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQWJzdHJhY3QgY2xhc3NlcyBvZiBtYXRoIGJsb2NrcyBhbmQgY29tbWFuZHMuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIE1hdGggdHJlZSBub2RlIGJhc2UgY2xhc3MuXG4gKiBTb21lIG1hdGgtdHJlZS1zcGVjaWZpYyBleHRlbnNpb25zIHRvIE5vZGUuXG4gKiBCb3RoIE1hdGhCbG9jaydzIGFuZCBNYXRoQ29tbWFuZCdzIGRlc2NlbmQgZnJvbSBpdC5cbiAqL1xudmFyIE1hdGhFbGVtZW50ID0gUChOb2RlLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5maW5hbGl6ZUluc2VydCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGN1cnNvcikgeyAvLyBgY3Vyc29yYCBwYXJhbSBpcyBvbmx5IGZvclxuICAgICAgLy8gU3VwU3ViOjpjb250YWN0V2VsZCwgYW5kIGlzIGRlbGliZXJhdGVseSBvbmx5IHBhc3NlZCBpbiBieSB3cml0ZUxhdGV4LFxuICAgICAgLy8gc2VlIGVhNzMwN2ViNGZhYzc3YzE0OWExMWZmZGY5YTgzMWRmODUyNDc2OTNcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5wb3N0T3JkZXIoJ2ZpbmFsaXplVHJlZScsIG9wdGlvbnMpO1xuICAgIHNlbGYucG9zdE9yZGVyKCdjb250YWN0V2VsZCcsIGN1cnNvcik7XG5cbiAgICAvLyBub3RlOiB0aGlzIG9yZGVyIGlzIGltcG9ydGFudC5cbiAgICAvLyBlbXB0eSBlbGVtZW50cyBuZWVkIHRoZSBlbXB0eSBib3ggcHJvdmlkZWQgYnkgYmx1ciB0b1xuICAgIC8vIGJlIHByZXNlbnQgaW4gb3JkZXIgZm9yIHRoZWlyIGRpbWVuc2lvbnMgdG8gYmUgbWVhc3VyZWRcbiAgICAvLyBjb3JyZWN0bHkgYnkgJ3JlZmxvdycgaGFuZGxlcnMuXG4gICAgc2VsZi5wb3N0T3JkZXIoJ2JsdXInKTtcblxuICAgIHNlbGYucG9zdE9yZGVyKCdyZWZsb3cnKTtcbiAgICBpZiAoc2VsZltSXS5zaWJsaW5nQ3JlYXRlZCkgc2VsZltSXS5zaWJsaW5nQ3JlYXRlZChvcHRpb25zLCBMKTtcbiAgICBpZiAoc2VsZltMXS5zaWJsaW5nQ3JlYXRlZCkgc2VsZltMXS5zaWJsaW5nQ3JlYXRlZChvcHRpb25zLCBSKTtcbiAgICBzZWxmLmJ1YmJsZSgncmVmbG93Jyk7XG4gIH07XG59KTtcblxuLyoqXG4gKiBDb21tYW5kcyBhbmQgb3BlcmF0b3JzLCBsaWtlIHN1YnNjcmlwdHMsIGV4cG9uZW50cywgb3IgZnJhY3Rpb25zLlxuICogRGVzY2VuZGFudCBjb21tYW5kcyBhcmUgb3JnYW5pemVkIGludG8gYmxvY2tzLlxuICovXG52YXIgTWF0aENvbW1hbmQgPSBQKE1hdGhFbGVtZW50LCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24oY3RybFNlcSwgaHRtbFRlbXBsYXRlLCB0ZXh0VGVtcGxhdGUpIHtcbiAgICB2YXIgY21kID0gdGhpcztcbiAgICBzdXBlcl8uaW5pdC5jYWxsKGNtZCk7XG5cbiAgICBpZiAoIWNtZC5jdHJsU2VxKSBjbWQuY3RybFNlcSA9IGN0cmxTZXE7XG4gICAgaWYgKGh0bWxUZW1wbGF0ZSkgY21kLmh0bWxUZW1wbGF0ZSA9IGh0bWxUZW1wbGF0ZTtcbiAgICBpZiAodGV4dFRlbXBsYXRlKSBjbWQudGV4dFRlbXBsYXRlID0gdGV4dFRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIG9idmlvdXMgbWV0aG9kc1xuICBfLnJlcGxhY2VzID0gZnVuY3Rpb24ocmVwbGFjZWRGcmFnbWVudCkge1xuICAgIHJlcGxhY2VkRnJhZ21lbnQuZGlzb3duKCk7XG4gICAgdGhpcy5yZXBsYWNlZEZyYWdtZW50ID0gcmVwbGFjZWRGcmFnbWVudDtcbiAgfTtcbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9sZENoaWxkcmVuKHRydWUsIGZ1bmN0aW9uKGlzRW1wdHksIGNoaWxkKSB7XG4gICAgICByZXR1cm4gaXNFbXB0eSAmJiBjaGlsZC5pc0VtcHR5KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgXy5wYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYmxvY2sgPSBsYXRleE1hdGhQYXJzZXIuYmxvY2s7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGJsb2NrLnRpbWVzKHNlbGYubnVtQmxvY2tzKCkpLm1hcChmdW5jdGlvbihibG9ja3MpIHtcbiAgICAgIHNlbGYuYmxvY2tzID0gYmxvY2tzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBibG9ja3NbaV0uYWRvcHQoc2VsZiwgc2VsZi5lbmRzW1JdLCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gY3JlYXRlTGVmdE9mKGN1cnNvcikgYW5kIHRoZSBtZXRob2RzIGl0IGNhbGxzXG4gIF8uY3JlYXRlTGVmdE9mID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgdmFyIGNtZCA9IHRoaXM7XG4gICAgdmFyIHJlcGxhY2VkRnJhZ21lbnQgPSBjbWQucmVwbGFjZWRGcmFnbWVudDtcblxuICAgIGNtZC5jcmVhdGVCbG9ja3MoKTtcbiAgICBzdXBlcl8uY3JlYXRlTGVmdE9mLmNhbGwoY21kLCBjdXJzb3IpO1xuICAgIGlmIChyZXBsYWNlZEZyYWdtZW50KSB7XG4gICAgICByZXBsYWNlZEZyYWdtZW50LmFkb3B0KGNtZC5lbmRzW0xdLCAwLCAwKTtcbiAgICAgIHJlcGxhY2VkRnJhZ21lbnQualEuYXBwZW5kVG8oY21kLmVuZHNbTF0ualEpO1xuICAgIH1cbiAgICBjbWQuZmluYWxpemVJbnNlcnQoY3Vyc29yLm9wdGlvbnMpO1xuICAgIGNtZC5wbGFjZUN1cnNvcihjdXJzb3IpO1xuICB9O1xuICBfLmNyZWF0ZUJsb2NrcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjbWQgPSB0aGlzLFxuICAgICAgbnVtQmxvY2tzID0gY21kLm51bUJsb2NrcygpLFxuICAgICAgYmxvY2tzID0gY21kLmJsb2NrcyA9IEFycmF5KG51bUJsb2Nrcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUJsb2NrczsgaSArPSAxKSB7XG4gICAgICB2YXIgbmV3QmxvY2sgPSBibG9ja3NbaV0gPSBNYXRoQmxvY2soKTtcbiAgICAgIG5ld0Jsb2NrLmFkb3B0KGNtZCwgY21kLmVuZHNbUl0sIDApO1xuICAgIH1cbiAgfTtcbiAgXy5wbGFjZUN1cnNvciA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIC8vaW5zZXJ0IHRoZSBjdXJzb3IgYXQgdGhlIHJpZ2h0IGVuZCBvZiB0aGUgZmlyc3QgZW1wdHkgY2hpbGQsIHNlYXJjaGluZ1xuICAgIC8vbGVmdC10by1yaWdodCwgb3IgaWYgbm9uZSBlbXB0eSwgdGhlIHJpZ2h0IGVuZCBjaGlsZFxuICAgIGN1cnNvci5pbnNBdFJpZ2h0RW5kKHRoaXMuZm9sZENoaWxkcmVuKHRoaXMuZW5kc1tMXSwgZnVuY3Rpb24obGVmdHdhcmQsIGNoaWxkKSB7XG4gICAgICByZXR1cm4gbGVmdHdhcmQuaXNFbXB0eSgpID8gbGVmdHdhcmQgOiBjaGlsZDtcbiAgICB9KSk7XG4gIH07XG5cbiAgLy8gZWRpdGFiaWxpdHkgbWV0aG9kczogY2FsbGVkIGJ5IHRoZSBjdXJzb3IgZm9yIGVkaXRpbmcsIGN1cnNvciBtb3ZlbWVudHMsXG4gIC8vIGFuZCBzZWxlY3Rpb24gb2YgdGhlIE1hdGhRdWlsbCB0cmVlLCB0aGVzZSBhbGwgdGFrZSBpbiBhIGRpcmVjdGlvbiBhbmRcbiAgLy8gdGhlIGN1cnNvclxuICBfLm1vdmVUb3dhcmRzID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IsIHVwZG93bikge1xuICAgIHZhciB1cGRvd25JbnRvID0gdXBkb3duICYmIHRoaXNbdXBkb3duKydJbnRvJ107XG4gICAgY3Vyc29yLmluc0F0RGlyRW5kKC1kaXIsIHVwZG93bkludG8gfHwgdGhpcy5lbmRzWy1kaXJdKTtcbiAgfTtcbiAgXy5kZWxldGVUb3dhcmRzID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIGN1cnNvcltkaXJdID0gdGhpcy5yZW1vdmUoKVtkaXJdO1xuICAgIGVsc2UgdGhpcy5tb3ZlVG93YXJkcyhkaXIsIGN1cnNvciwgbnVsbCk7XG4gIH07XG4gIF8uc2VsZWN0VG93YXJkcyA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgY3Vyc29yWy1kaXJdID0gdGhpcztcbiAgICBjdXJzb3JbZGlyXSA9IHRoaXNbZGlyXTtcbiAgfTtcbiAgXy5zZWxlY3RDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTZWxlY3Rpb24odGhpcywgdGhpcyk7XG4gIH07XG4gIF8udW5zZWxlY3RJbnRvID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBjdXJzb3IuaW5zQXREaXJFbmQoLWRpciwgY3Vyc29yLmFudGljdXJzb3IuYW5jZXN0b3JzW3RoaXMuaWRdKTtcbiAgfTtcbiAgXy5zZWVrID0gZnVuY3Rpb24ocGFnZVgsIGN1cnNvcikge1xuICAgIGZ1bmN0aW9uIGdldEJvdW5kcyhub2RlKSB7XG4gICAgICB2YXIgYm91bmRzID0ge31cbiAgICAgIGJvdW5kc1tMXSA9IG5vZGUualEub2Zmc2V0KCkubGVmdDtcbiAgICAgIGJvdW5kc1tSXSA9IGJvdW5kc1tMXSArIG5vZGUualEub3V0ZXJXaWR0aCgpO1xuICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9XG5cbiAgICB2YXIgY21kID0gdGhpcztcbiAgICB2YXIgY21kQm91bmRzID0gZ2V0Qm91bmRzKGNtZCk7XG5cbiAgICBpZiAocGFnZVggPCBjbWRCb3VuZHNbTF0pIHJldHVybiBjdXJzb3IuaW5zTGVmdE9mKGNtZCk7XG4gICAgaWYgKHBhZ2VYID4gY21kQm91bmRzW1JdKSByZXR1cm4gY3Vyc29yLmluc1JpZ2h0T2YoY21kKTtcblxuICAgIHZhciBsZWZ0TGVmdEJvdW5kID0gY21kQm91bmRzW0xdO1xuICAgIGNtZC5lYWNoQ2hpbGQoZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgIHZhciBibG9ja0JvdW5kcyA9IGdldEJvdW5kcyhibG9jayk7XG4gICAgICBpZiAocGFnZVggPCBibG9ja0JvdW5kc1tMXSkge1xuICAgICAgICAvLyBjbG9zZXIgdG8gdGhpcyBibG9jaydzIGxlZnQgYm91bmQsIG9yIHRoZSBib3VuZCBsZWZ0IG9mIHRoYXQ/XG4gICAgICAgIGlmIChwYWdlWCAtIGxlZnRMZWZ0Qm91bmQgPCBibG9ja0JvdW5kc1tMXSAtIHBhZ2VYKSB7XG4gICAgICAgICAgaWYgKGJsb2NrW0xdKSBjdXJzb3IuaW5zQXRSaWdodEVuZChibG9ja1tMXSk7XG4gICAgICAgICAgZWxzZSBjdXJzb3IuaW5zTGVmdE9mKGNtZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBjdXJzb3IuaW5zQXRMZWZ0RW5kKGJsb2NrKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocGFnZVggPiBibG9ja0JvdW5kc1tSXSkge1xuICAgICAgICBpZiAoYmxvY2tbUl0pIGxlZnRMZWZ0Qm91bmQgPSBibG9ja0JvdW5kc1tSXTsgLy8gY29udGludWUgdG8gbmV4dCBibG9ja1xuICAgICAgICBlbHNlIHsgLy8gbGFzdCAocmlnaHRtb3N0KSBibG9ja1xuICAgICAgICAgIC8vIGNsb3NlciB0byB0aGlzIGJsb2NrJ3MgcmlnaHQgYm91bmQsIG9yIHRoZSBjbWQncyByaWdodCBib3VuZD9cbiAgICAgICAgICBpZiAoY21kQm91bmRzW1JdIC0gcGFnZVggPCBwYWdlWCAtIGJsb2NrQm91bmRzW1JdKSB7XG4gICAgICAgICAgICBjdXJzb3IuaW5zUmlnaHRPZihjbWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGN1cnNvci5pbnNBdFJpZ2h0RW5kKGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJsb2NrLnNlZWsocGFnZVgsIGN1cnNvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIG1ldGhvZHMgaW52b2x2ZWQgaW4gY3JlYXRpbmcgYW5kIGNyb3NzLWxpbmtpbmcgd2l0aCBIVE1MIERPTSBub2Rlc1xuICAvKlxuICAgIFRoZXkgYWxsIGV4cGVjdCBhbiAuaHRtbFRlbXBsYXRlIGxpa2VcbiAgICAgICc8c3Bhbj4mMDwvc3Bhbj4nXG4gICAgb3JcbiAgICAgICc8c3Bhbj48c3Bhbj4mMDwvc3Bhbj48c3Bhbj4mMTwvc3Bhbj48L3NwYW4+J1xuXG4gICAgU2VlIGh0bWwudGVzdC5qcyBmb3IgbW9yZSBleGFtcGxlcy5cblxuICAgIFJlcXVpcmVtZW50czpcbiAgICAtIEZvciBlYWNoIGJsb2NrIG9mIHRoZSBjb21tYW5kLCB0aGVyZSBtdXN0IGJlIGV4YWN0bHkgb25lIFwiYmxvY2sgY29udGVudFxuICAgICAgbWFya2VyXCIgb2YgdGhlIGZvcm0gJyY8bnVtYmVyPicgd2hlcmUgPG51bWJlcj4gaXMgdGhlIDAtYmFzZWQgaW5kZXggb2YgdGhlXG4gICAgICBibG9jay4gKExpa2UgdGhlIExhVGVYIFxcbmV3Y29tbWFuZCBzeW50YXgsIGJ1dCB3aXRoIGEgMC1iYXNlZCByYXRoZXIgdGhhblxuICAgICAgMS1iYXNlZCBpbmRleCwgYmVjYXVzZSBKYXZhU2NyaXB0IGJlY2F1c2UgQyBiZWNhdXNlIERpamtzdHJhLilcbiAgICAtIFRoZSBibG9jayBjb250ZW50IG1hcmtlciBtdXN0IGJlIHRoZSBzb2xlIGNvbnRlbnRzIG9mIHRoZSBjb250YWluaW5nXG4gICAgICBlbGVtZW50LCB0aGVyZSBjYW4ndCBldmVuIGJlIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2UsIG9yIGVsc2Ugd2UgY2FuJ3RcbiAgICAgIGd1YXJhbnRlZSBzdGlja2luZyB0byB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgYmxvY2sgY29udGVudCBtYXJrZXIgd2hlblxuICAgICAgbXVja2luZyB3aXRoIHRoZSBIVE1MIERPTS5cbiAgICAtIFRoZSBIVE1MIG5vdCBvbmx5IG11c3QgYmUgd2VsbC1mb3JtZWQgSFRNTCAob2YgY291cnNlKSwgYnV0IGFsc28gbXVzdFxuICAgICAgY29uZm9ybSB0byB0aGUgWEhUTUwgcmVxdWlyZW1lbnRzIG9uIHRhZ3MsIHNwZWNpZmljYWxseSBhbGwgdGFncyBtdXN0XG4gICAgICBlaXRoZXIgYmUgc2VsZi1jbG9zaW5nIChsaWtlICc8YnIvPicpIG9yIGNvbWUgaW4gbWF0Y2hpbmcgcGFpcnMuXG4gICAgICBDbG9zZSB0YWdzIGFyZSBuZXZlciBvcHRpb25hbC5cblxuICAgIE5vdGUgdGhhdCAmPG51bWJlcj4gaXNuJ3Qgd2VsbC1mb3JtZWQgSFRNTDsgaWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgJyYxMjMnLFxuICAgIHlvdXIgSFRNTCB0ZW1wbGF0ZSB3b3VsZCBoYXZlIHRvIGhhdmUgJyZhbXA7MTIzJy5cbiAgKi9cbiAgXy5udW1CbG9ja3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHRoaXMuaHRtbFRlbXBsYXRlLm1hdGNoKC8mXFxkKy9nKTtcbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXMubGVuZ3RoIDogMDtcbiAgfTtcbiAgXy5odG1sID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gUmVuZGVyIHRoZSBlbnRpcmUgbWF0aCBzdWJ0cmVlIHJvb3RlZCBhdCB0aGlzIGNvbW1hbmQsIGFzIEhUTUwuXG4gICAgLy8gRXhwZWN0cyAuY3JlYXRlQmxvY2tzKCkgdG8gaGF2ZSBiZWVuIGNhbGxlZCBhbHJlYWR5LCBzaW5jZSBpdCB1c2VzIHRoZVxuICAgIC8vIC5ibG9ja3MgYXJyYXkgb2YgY2hpbGQgYmxvY2tzLlxuICAgIC8vXG4gICAgLy8gU2VlIGh0bWwudGVzdC5qcyBmb3IgZXhhbXBsZSB0ZW1wbGF0ZXMgYW5kIGludGVuZGVkIG91dHB1dHMuXG4gICAgLy9cbiAgICAvLyBHaXZlbiBhbiAuaHRtbFRlbXBsYXRlIGFzIGRlc2NyaWJlZCBhYm92ZSxcbiAgICAvLyAtIGluc2VydCB0aGUgbWF0aHF1aWxsLWNvbW1hbmQtaWQgYXR0cmlidXRlIGludG8gYWxsIHRvcC1sZXZlbCB0YWdzLFxuICAgIC8vICAgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNldCB0aGlzLmpRIGluIC5qUWl6ZSgpLlxuICAgIC8vICAgVGhpcyBpcyBzdHJhaWdodGZvcndhcmQ6XG4gICAgLy8gICAgICogdG9rZW5pemUgaW50byB0YWdzIGFuZCBub24tdGFnc1xuICAgIC8vICAgICAqIGxvb3AgdGhyb3VnaCB0b3AtbGV2ZWwgdG9rZW5zOlxuICAgIC8vICAgICAgICAgKiBhZGQgI2NtZElkIGF0dHJpYnV0ZSBtYWNybyB0byB0b3AtbGV2ZWwgc2VsZi1jbG9zaW5nIHRhZ3NcbiAgICAvLyAgICAgICAgICogZWxzZSBhZGQgI2NtZElkIGF0dHJpYnV0ZSBtYWNybyB0byB0b3AtbGV2ZWwgb3BlbiB0YWdzXG4gICAgLy8gICAgICAgICAgICAgKiBza2lwIHRoZSBtYXRjaGluZyB0b3AtbGV2ZWwgY2xvc2UgdGFnIGFuZCBhbGwgdGFnIHBhaXJzXG4gICAgLy8gICAgICAgICAgICAgICBpbiBiZXR3ZWVuXG4gICAgLy8gLSBmb3IgZWFjaCBibG9jayBjb250ZW50IG1hcmtlcixcbiAgICAvLyAgICAgKyByZXBsYWNlIGl0IHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBjb3JyZXNwb25kaW5nIGJsb2NrLFxuICAgIC8vICAgICAgIHJlbmRlcmVkIGFzIEhUTUxcbiAgICAvLyAgICAgKyBpbnNlcnQgdGhlIG1hdGhxdWlsbC1ibG9jay1pZCBhdHRyaWJ1dGUgaW50byB0aGUgY29udGFpbmluZyB0YWdcbiAgICAvLyAgIFRoaXMgaXMgZXZlbiBlYXNpZXIsIGEgcXVpY2sgcmVnZXggcmVwbGFjZSwgc2luY2UgYmxvY2sgdGFncyBjYW5ub3RcbiAgICAvLyAgIGNvbnRhaW4gYW55dGhpbmcgYmVzaWRlcyB0aGUgYmxvY2sgY29udGVudCBtYXJrZXIuXG4gICAgLy9cbiAgICAvLyBUd28gbm90ZXM6XG4gICAgLy8gLSBUaGUgb3V0ZXJtb3N0IGxvb3AgdGhyb3VnaCB0b3AtbGV2ZWwgdG9rZW5zIHNob3VsZCBuZXZlciBlbmNvdW50ZXIgYW55XG4gICAgLy8gICB0b3AtbGV2ZWwgY2xvc2UgdGFncywgYmVjYXVzZSB3ZSBzaG91bGQgaGF2ZSBmaXJzdCBlbmNvdW50ZXJlZCBhXG4gICAgLy8gICBtYXRjaGluZyB0b3AtbGV2ZWwgb3BlbiB0YWcsIGFsbCBpbm5lciB0YWdzIHNob3VsZCBoYXZlIGFwcGVhcmVkIGluXG4gICAgLy8gICBtYXRjaGluZyBwYWlycyBhbmQgYmVlbiBza2lwcGVkLCBhbmQgdGhlbiB3ZSBzaG91bGQgaGF2ZSBza2lwcGVkIHRoZVxuICAgIC8vICAgY2xvc2UgdGFnIGluIHF1ZXN0aW9uLlxuICAgIC8vIC0gQWxsIG9wZW4gdGFncyBzaG91bGQgaGF2ZSBtYXRjaGluZyBjbG9zZSB0YWdzLCB3aGljaCBtZWFucyBvdXIgaW5uZXJcbiAgICAvLyAgIGxvb3Agc2hvdWxkIGFsd2F5cyBlbmNvdW50ZXIgYSBjbG9zZSB0YWcgYW5kIGRyb3AgbmVzdGluZyB0byAwLiBJZlxuICAgIC8vICAgYSBjbG9zZSB0YWcgaXMgbWlzc2luZywgdGhlIGxvb3Agd2lsbCBjb250aW51ZSB1bnRpbCBpID49IHRva2Vucy5sZW5ndGhcbiAgICAvLyAgIGFuZCB0b2tlbiBiZWNvbWVzIHVuZGVmaW5lZC4gVGhpcyB3aWxsIG5vdCBpbmZpbml0ZSBsb29wLCBldmVuIGluXG4gICAgLy8gICBwcm9kdWN0aW9uIHdpdGhvdXQgcHJheSgpLCBiZWNhdXNlIGl0IHdpbGwgdGhlbiBUeXBlRXJyb3Igb24gLnNsaWNlKCkuXG5cbiAgICB2YXIgY21kID0gdGhpcztcbiAgICB2YXIgYmxvY2tzID0gY21kLmJsb2NrcztcbiAgICB2YXIgY21kSWQgPSAnIG1hdGhxdWlsbC1jb21tYW5kLWlkPScgKyBjbWQuaWQ7XG4gICAgdmFyIHRva2VucyA9IGNtZC5odG1sVGVtcGxhdGUubWF0Y2goLzxbXjw+XSs+fFtePD5dKy9nKTtcblxuICAgIHByYXkoJ25vIHVubWF0Y2hlZCBhbmdsZSBicmFja2V0cycsIHRva2Vucy5qb2luKCcnKSA9PT0gdGhpcy5odG1sVGVtcGxhdGUpO1xuXG4gICAgLy8gYWRkIGNtZElkIHRvIGFsbCB0b3AtbGV2ZWwgdGFnc1xuICAgIGZvciAodmFyIGkgPSAwLCB0b2tlbiA9IHRva2Vuc1swXTsgdG9rZW47IGkgKz0gMSwgdG9rZW4gPSB0b2tlbnNbaV0pIHtcbiAgICAgIC8vIHRvcC1sZXZlbCBzZWxmLWNsb3NpbmcgdGFnc1xuICAgICAgaWYgKHRva2VuLnNsaWNlKC0yKSA9PT0gJy8+Jykge1xuICAgICAgICB0b2tlbnNbaV0gPSB0b2tlbi5zbGljZSgwLC0yKSArIGNtZElkICsgJy8+JztcbiAgICAgIH1cbiAgICAgIC8vIHRvcC1sZXZlbCBvcGVuIHRhZ3NcbiAgICAgIGVsc2UgaWYgKHRva2VuLmNoYXJBdCgwKSA9PT0gJzwnKSB7XG4gICAgICAgIHByYXkoJ25vdCBhbiB1bm1hdGNoZWQgdG9wLWxldmVsIGNsb3NlIHRhZycsIHRva2VuLmNoYXJBdCgxKSAhPT0gJy8nKTtcblxuICAgICAgICB0b2tlbnNbaV0gPSB0b2tlbi5zbGljZSgwLC0xKSArIGNtZElkICsgJz4nO1xuXG4gICAgICAgIC8vIHNraXAgbWF0Y2hpbmcgdG9wLWxldmVsIGNsb3NlIHRhZyBhbmQgYWxsIHRhZyBwYWlycyBpbiBiZXR3ZWVuXG4gICAgICAgIHZhciBuZXN0aW5nID0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGkgKz0gMSwgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgcHJheSgnbm8gbWlzc2luZyBjbG9zZSB0YWdzJywgdG9rZW4pO1xuICAgICAgICAgIC8vIGNsb3NlIHRhZ3NcbiAgICAgICAgICBpZiAodG9rZW4uc2xpY2UoMCwyKSA9PT0gJzwvJykge1xuICAgICAgICAgICAgbmVzdGluZyAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBub24tc2VsZi1jbG9zaW5nIG9wZW4gdGFnc1xuICAgICAgICAgIGVsc2UgaWYgKHRva2VuLmNoYXJBdCgwKSA9PT0gJzwnICYmIHRva2VuLnNsaWNlKC0yKSAhPT0gJy8+Jykge1xuICAgICAgICAgICAgbmVzdGluZyArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobmVzdGluZyA+IDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zLmpvaW4oJycpLnJlcGxhY2UoLz4mKFxcZCspL2csIGZ1bmN0aW9uKCQwLCAkMSkge1xuICAgICAgcmV0dXJuICcgbWF0aHF1aWxsLWJsb2NrLWlkPScgKyBibG9ja3NbJDFdLmlkICsgJz4nICsgYmxvY2tzWyQxXS5qb2luKCdodG1sJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gbWV0aG9kcyB0byBleHBvcnQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdGggdHJlZVxuICBfLmxhdGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9sZENoaWxkcmVuKHRoaXMuY3RybFNlcSwgZnVuY3Rpb24obGF0ZXgsIGNoaWxkKSB7XG4gICAgICByZXR1cm4gbGF0ZXggKyAneycgKyAoY2hpbGQubGF0ZXgoKSB8fCAnICcpICsgJ30nO1xuICAgIH0pO1xuICB9O1xuICBfLnRleHRUZW1wbGF0ZSA9IFsnJ107XG4gIF8udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjbWQgPSB0aGlzLCBpID0gMDtcbiAgICByZXR1cm4gY21kLmZvbGRDaGlsZHJlbihjbWQudGV4dFRlbXBsYXRlW2ldLCBmdW5jdGlvbih0ZXh0LCBjaGlsZCkge1xuICAgICAgaSArPSAxO1xuICAgICAgdmFyIGNoaWxkX3RleHQgPSBjaGlsZC50ZXh0KCk7XG4gICAgICBpZiAodGV4dCAmJiBjbWQudGV4dFRlbXBsYXRlW2ldID09PSAnKCdcbiAgICAgICAgICAmJiBjaGlsZF90ZXh0WzBdID09PSAnKCcgJiYgY2hpbGRfdGV4dC5zbGljZSgtMSkgPT09ICcpJylcbiAgICAgICAgcmV0dXJuIHRleHQgKyBjaGlsZF90ZXh0LnNsaWNlKDEsIC0xKSArIGNtZC50ZXh0VGVtcGxhdGVbaV07XG4gICAgICByZXR1cm4gdGV4dCArIGNoaWxkLnRleHQoKSArIChjbWQudGV4dFRlbXBsYXRlW2ldIHx8ICcnKTtcbiAgICB9KTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIExpZ2h0d2VpZ2h0IGNvbW1hbmQgd2l0aG91dCBibG9ja3Mgb3IgY2hpbGRyZW4uXG4gKi9cbnZhciBTeW1ib2wgPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24oY3RybFNlcSwgaHRtbCwgdGV4dCkge1xuICAgIGlmICghdGV4dCkgdGV4dCA9IGN0cmxTZXEgJiYgY3RybFNlcS5sZW5ndGggPiAxID8gY3RybFNlcS5zbGljZSgxKSA6IGN0cmxTZXE7XG5cbiAgICBzdXBlcl8uaW5pdC5jYWxsKHRoaXMsIGN0cmxTZXEsIGh0bWwsIFsgdGV4dCBdKTtcbiAgfTtcblxuICBfLnBhcnNlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gUGFyc2VyLnN1Y2NlZWQodGhpcyk7IH07XG4gIF8ubnVtQmxvY2tzID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG4gIF8ucmVwbGFjZXMgPSBmdW5jdGlvbihyZXBsYWNlZEZyYWdtZW50KSB7XG4gICAgcmVwbGFjZWRGcmFnbWVudC5yZW1vdmUoKTtcbiAgfTtcbiAgXy5jcmVhdGVCbG9ja3MgPSBub29wO1xuXG4gIF8ubW92ZVRvd2FyZHMgPSBmdW5jdGlvbihkaXIsIGN1cnNvcikge1xuICAgIGN1cnNvci5qUS5pbnNEaXJPZihkaXIsIHRoaXMualEpO1xuICAgIGN1cnNvclstZGlyXSA9IHRoaXM7XG4gICAgY3Vyc29yW2Rpcl0gPSB0aGlzW2Rpcl07XG4gIH07XG4gIF8uZGVsZXRlVG93YXJkcyA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgY3Vyc29yW2Rpcl0gPSB0aGlzLnJlbW92ZSgpW2Rpcl07XG4gIH07XG4gIF8uc2VlayA9IGZ1bmN0aW9uKHBhZ2VYLCBjdXJzb3IpIHtcbiAgICAvLyBpbnNlcnQgYXQgd2hpY2hldmVyIHNpZGUgdGhlIGNsaWNrIHdhcyBjbG9zZXIgdG9cbiAgICBpZiAocGFnZVggLSB0aGlzLmpRLm9mZnNldCgpLmxlZnQgPCB0aGlzLmpRLm91dGVyV2lkdGgoKS8yKVxuICAgICAgY3Vyc29yLmluc0xlZnRPZih0aGlzKTtcbiAgICBlbHNlXG4gICAgICBjdXJzb3IuaW5zUmlnaHRPZih0aGlzKTtcbiAgfTtcblxuICBfLmxhdGV4ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuY3RybFNlcTsgfTtcbiAgXy50ZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGV4dFRlbXBsYXRlOyB9O1xuICBfLnBsYWNlQ3Vyc29yID0gbm9vcDtcbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRydWU7IH07XG59KTtcbnZhciBWYW5pbGxhU3ltYm9sID0gUChTeW1ib2wsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihjaCwgaHRtbCkge1xuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcywgY2gsICc8c3Bhbj4nKyhodG1sIHx8IGNoKSsnPC9zcGFuPicpO1xuICB9O1xufSk7XG52YXIgQmluYXJ5T3BlcmF0b3IgPSBQKFN5bWJvbCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGN0cmxTZXEsIGh0bWwsIHRleHQpIHtcbiAgICBzdXBlcl8uaW5pdC5jYWxsKHRoaXMsXG4gICAgICBjdHJsU2VxLCAnPHNwYW4gY2xhc3M9XCJtcS1iaW5hcnktb3BlcmF0b3JcIj4nK2h0bWwrJzwvc3Bhbj4nLCB0ZXh0XG4gICAgKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIENoaWxkcmVuIGFuZCBwYXJlbnQgb2YgTWF0aENvbW1hbmQncy4gQmFzaWNhbGx5IHBhcnRpdGlvbnMgYWxsIHRoZVxuICogc3ltYm9scyBhbmQgb3BlcmF0b3JzIHRoYXQgZGVzY2VuZCAoaW4gdGhlIE1hdGggRE9NIHRyZWUpIGZyb21cbiAqIGFuY2VzdG9yIG9wZXJhdG9ycy5cbiAqL1xudmFyIE1hdGhCbG9jayA9IFAoTWF0aEVsZW1lbnQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmpvaW4gPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9sZENoaWxkcmVuKCcnLCBmdW5jdGlvbihmb2xkLCBjaGlsZCkge1xuICAgICAgcmV0dXJuIGZvbGQgKyBjaGlsZFttZXRob2ROYW1lXSgpO1xuICAgIH0pO1xuICB9O1xuICBfLmh0bWwgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuam9pbignaHRtbCcpOyB9O1xuICBfLmxhdGV4ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmpvaW4oJ2xhdGV4Jyk7IH07XG4gIF8udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5lbmRzW0xdID09PSB0aGlzLmVuZHNbUl0gJiYgdGhpcy5lbmRzW0xdICE9PSAwKSA/XG4gICAgICB0aGlzLmVuZHNbTF0udGV4dCgpIDpcbiAgICAgIHRoaXMuam9pbigndGV4dCcpXG4gICAgO1xuICB9O1xuXG4gIF8ua2V5c3Ryb2tlID0gZnVuY3Rpb24oa2V5LCBlLCBjdHJscikge1xuICAgIGlmIChjdHJsci5vcHRpb25zLnNwYWNlQmVoYXZlc0xpa2VUYWJcbiAgICAgICAgJiYgKGtleSA9PT0gJ1NwYWNlYmFyJyB8fCBrZXkgPT09ICdTaGlmdC1TcGFjZWJhcicpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjdHJsci5lc2NhcGVEaXIoa2V5ID09PSAnU2hpZnQtU3BhY2ViYXInID8gTCA6IFIsIGtleSwgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBzdXBlcl8ua2V5c3Ryb2tlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gZWRpdGFiaWxpdHkgbWV0aG9kczogY2FsbGVkIGJ5IHRoZSBjdXJzb3IgZm9yIGVkaXRpbmcsIGN1cnNvciBtb3ZlbWVudHMsXG4gIC8vIGFuZCBzZWxlY3Rpb24gb2YgdGhlIE1hdGhRdWlsbCB0cmVlLCB0aGVzZSBhbGwgdGFrZSBpbiBhIGRpcmVjdGlvbiBhbmRcbiAgLy8gdGhlIGN1cnNvclxuICBfLm1vdmVPdXRPZiA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yLCB1cGRvd24pIHtcbiAgICB2YXIgdXBkb3duSW50byA9IHVwZG93biAmJiB0aGlzLnBhcmVudFt1cGRvd24rJ0ludG8nXTtcbiAgICBpZiAoIXVwZG93bkludG8gJiYgdGhpc1tkaXJdKSBjdXJzb3IuaW5zQXREaXJFbmQoLWRpciwgdGhpc1tkaXJdKTtcbiAgICBlbHNlIGN1cnNvci5pbnNEaXJPZihkaXIsIHRoaXMucGFyZW50KTtcbiAgfTtcbiAgXy5zZWxlY3RPdXRPZiA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgY3Vyc29yLmluc0Rpck9mKGRpciwgdGhpcy5wYXJlbnQpO1xuICB9O1xuICBfLmRlbGV0ZU91dE9mID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBjdXJzb3IudW53cmFwR3JhbXAoKTtcbiAgfTtcbiAgXy5zZWVrID0gZnVuY3Rpb24ocGFnZVgsIGN1cnNvcikge1xuICAgIHZhciBub2RlID0gdGhpcy5lbmRzW1JdO1xuICAgIGlmICghbm9kZSB8fCBub2RlLmpRLm9mZnNldCgpLmxlZnQgKyBub2RlLmpRLm91dGVyV2lkdGgoKSA8IHBhZ2VYKSB7XG4gICAgICByZXR1cm4gY3Vyc29yLmluc0F0UmlnaHRFbmQodGhpcyk7XG4gICAgfVxuICAgIGlmIChwYWdlWCA8IHRoaXMuZW5kc1tMXS5qUS5vZmZzZXQoKS5sZWZ0KSByZXR1cm4gY3Vyc29yLmluc0F0TGVmdEVuZCh0aGlzKTtcbiAgICB3aGlsZSAocGFnZVggPCBub2RlLmpRLm9mZnNldCgpLmxlZnQpIG5vZGUgPSBub2RlW0xdO1xuICAgIHJldHVybiBub2RlLnNlZWsocGFnZVgsIGN1cnNvcik7XG4gIH07XG4gIF8uY2hUb0NtZCA9IGZ1bmN0aW9uKGNoKSB7XG4gICAgdmFyIGNvbnM7XG4gICAgLy8gZXhjbHVkZSBmIGJlY2F1c2UgaXQgZ2V0cyBhIGRlZGljYXRlZCBjb21tYW5kIHdpdGggbW9yZSBzcGFjaW5nXG4gICAgaWYgKGNoLm1hdGNoKC9eW2EtZWctekEtWl0kLykpXG4gICAgICByZXR1cm4gTGV0dGVyKGNoKTtcbiAgICBlbHNlIGlmICgvXlxcZCQvLnRlc3QoY2gpKVxuICAgICAgcmV0dXJuIERpZ2l0KGNoKTtcbiAgICBlbHNlIGlmIChjb25zID0gQ2hhckNtZHNbY2hdIHx8IExhdGV4Q21kc1tjaF0pXG4gICAgICByZXR1cm4gY29ucyhjaCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFZhbmlsbGFTeW1ib2woY2gpO1xuICB9O1xuICBfLndyaXRlID0gZnVuY3Rpb24oY3Vyc29yLCBjaCkge1xuICAgIHZhciBjbWQgPSB0aGlzLmNoVG9DbWQoY2gpO1xuICAgIGlmIChjdXJzb3Iuc2VsZWN0aW9uKSBjbWQucmVwbGFjZXMoY3Vyc29yLnJlcGxhY2VTZWxlY3Rpb24oKSk7XG4gICAgY21kLmNyZWF0ZUxlZnRPZihjdXJzb3Iuc2hvdygpKTtcbiAgfTtcblxuICBfLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5qUS5hZGRDbGFzcygnbXEtaGFzQ3Vyc29yJyk7XG4gICAgdGhpcy5qUS5yZW1vdmVDbGFzcygnbXEtZW1wdHknKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfLmJsdXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmpRLnJlbW92ZUNsYXNzKCdtcS1oYXNDdXJzb3InKTtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpXG4gICAgICB0aGlzLmpRLmFkZENsYXNzKCdtcS1lbXB0eScpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuQVBJLlN0YXRpY01hdGggPSBmdW5jdGlvbihBUElDbGFzc2VzKSB7XG4gIHJldHVybiBQKEFQSUNsYXNzZXMuQWJzdHJhY3RNYXRoUXVpbGwsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICAgIHRoaXMuUm9vdEJsb2NrID0gTWF0aEJsb2NrO1xuICAgIF8uX19tYXRocXVpbGxpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHN1cGVyXy5fX21hdGhxdWlsbGlmeS5jYWxsKHRoaXMsICdtcS1tYXRoLW1vZGUnKTtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyLmRlbGVnYXRlTW91c2VFdmVudHMoKTtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyLnN0YXRpY01hdGhUZXh0YXJlYUV2ZW50cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHN1cGVyXy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLl9fY29udHJvbGxlci5yb290LnBvc3RPcmRlcihcbiAgICAgICAgJ3JlZ2lzdGVySW5uZXJGaWVsZCcsIHRoaXMuaW5uZXJGaWVsZHMgPSBbXSwgQVBJQ2xhc3Nlcy5NYXRoRmllbGQpO1xuICAgIH07XG4gICAgXy5sYXRleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJldHVybmVkID0gc3VwZXJfLmxhdGV4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fX2NvbnRyb2xsZXIucm9vdC5wb3N0T3JkZXIoXG4gICAgICAgICAgJ3JlZ2lzdGVySW5uZXJGaWVsZCcsIHRoaXMuaW5uZXJGaWVsZHMgPSBbXSwgQVBJQ2xhc3Nlcy5NYXRoRmllbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVybmVkO1xuICAgIH07XG4gIH0pO1xufTtcblxudmFyIFJvb3RNYXRoQmxvY2sgPSBQKE1hdGhCbG9jaywgUm9vdEJsb2NrTWl4aW4pO1xuQVBJLk1hdGhGaWVsZCA9IGZ1bmN0aW9uKEFQSUNsYXNzZXMpIHtcbiAgcmV0dXJuIFAoQVBJQ2xhc3Nlcy5FZGl0YWJsZUZpZWxkLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgICB0aGlzLlJvb3RCbG9jayA9IFJvb3RNYXRoQmxvY2s7XG4gICAgXy5fX21hdGhxdWlsbGlmeSA9IGZ1bmN0aW9uKG9wdHMsIGludGVyZmFjZVZlcnNpb24pIHtcbiAgICAgIHRoaXMuY29uZmlnKG9wdHMpO1xuICAgICAgaWYgKGludGVyZmFjZVZlcnNpb24gPiAxKSB0aGlzLl9fY29udHJvbGxlci5yb290LnJlZmxvdyA9IG5vb3A7XG4gICAgICBzdXBlcl8uX19tYXRocXVpbGxpZnkuY2FsbCh0aGlzLCAnbXEtZWRpdGFibGUtZmllbGQgbXEtbWF0aC1tb2RlJyk7XG4gICAgICBkZWxldGUgdGhpcy5fX2NvbnRyb2xsZXIucm9vdC5yZWZsb3c7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9KTtcbn07XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQWJzdHJhY3QgY2xhc3NlcyBvZiB0ZXh0IGJsb2Nrc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gKiBCbG9ja3Mgb2YgcGxhaW4gdGV4dCwgd2l0aCBvbmUgb3IgdHdvIFRleHRQaWVjZSdzIGFzIGNoaWxkcmVuLlxuICogUmVwcmVzZW50cyBmbGF0IHN0cmluZ3Mgb2YgdHlwaWNhbGx5IHNlcmlmLWZvbnQgUm9tYW4gY2hhcmFjdGVycywgYXNcbiAqIG9wcG9zZWQgdG8gaGllcmNoaWNhbCwgbmVzdGVkLCB0cmVlLXN0cnVjdHVyZWQgbWF0aC5cbiAqIFdyYXBzIGEgc2luZ2xlIEhUTUxTcGFuRWxlbWVudC5cbiAqL1xudmFyIFRleHRCbG9jayA9IFAoTm9kZSwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uY3RybFNlcSA9ICdcXFxcdGV4dCc7XG5cbiAgXy5yZXBsYWNlcyA9IGZ1bmN0aW9uKHJlcGxhY2VkVGV4dCkge1xuICAgIGlmIChyZXBsYWNlZFRleHQgaW5zdGFuY2VvZiBGcmFnbWVudClcbiAgICAgIHRoaXMucmVwbGFjZWRUZXh0ID0gcmVwbGFjZWRUZXh0LnJlbW92ZSgpLmpRLnRleHQoKTtcbiAgICBlbHNlIGlmICh0eXBlb2YgcmVwbGFjZWRUZXh0ID09PSAnc3RyaW5nJylcbiAgICAgIHRoaXMucmVwbGFjZWRUZXh0ID0gcmVwbGFjZWRUZXh0O1xuICB9O1xuXG4gIF8ualFhZGQgPSBmdW5jdGlvbihqUSkge1xuICAgIHN1cGVyXy5qUWFkZC5jYWxsKHRoaXMsIGpRKTtcbiAgICBpZiAodGhpcy5lbmRzW0xdKSB0aGlzLmVuZHNbTF0ualFhZGQodGhpcy5qUVswXS5maXJzdENoaWxkKTtcbiAgfTtcblxuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIHZhciB0ZXh0QmxvY2sgPSB0aGlzO1xuICAgIHN1cGVyXy5jcmVhdGVMZWZ0T2YuY2FsbCh0aGlzLCBjdXJzb3IpO1xuXG4gICAgaWYgKHRleHRCbG9ja1tSXS5zaWJsaW5nQ3JlYXRlZCkgdGV4dEJsb2NrW1JdLnNpYmxpbmdDcmVhdGVkKGN1cnNvci5vcHRpb25zLCBMKTtcbiAgICBpZiAodGV4dEJsb2NrW0xdLnNpYmxpbmdDcmVhdGVkKSB0ZXh0QmxvY2tbTF0uc2libGluZ0NyZWF0ZWQoY3Vyc29yLm9wdGlvbnMsIFIpO1xuICAgIHRleHRCbG9jay5idWJibGUoJ3JlZmxvdycpO1xuXG4gICAgY3Vyc29yLmluc0F0UmlnaHRFbmQodGV4dEJsb2NrKTtcblxuICAgIGlmICh0ZXh0QmxvY2sucmVwbGFjZWRUZXh0KVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0QmxvY2sucmVwbGFjZWRUZXh0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB0ZXh0QmxvY2sud3JpdGUoY3Vyc29yLCB0ZXh0QmxvY2sucmVwbGFjZWRUZXh0LmNoYXJBdChpKSk7XG4gIH07XG5cbiAgXy5wYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGV4dEJsb2NrID0gdGhpcztcblxuICAgIC8vIFRPRE86IGNvcnJlY3RseSBwYXJzZSB0ZXh0IG1vZGVcbiAgICB2YXIgc3RyaW5nID0gUGFyc2VyLnN0cmluZztcbiAgICB2YXIgcmVnZXggPSBQYXJzZXIucmVnZXg7XG4gICAgdmFyIG9wdFdoaXRlc3BhY2UgPSBQYXJzZXIub3B0V2hpdGVzcGFjZTtcbiAgICByZXR1cm4gb3B0V2hpdGVzcGFjZVxuICAgICAgLnRoZW4oc3RyaW5nKCd7JykpLnRoZW4ocmVnZXgoL15bXn1dKi8pKS5za2lwKHN0cmluZygnfScpKVxuICAgICAgLm1hcChmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IGlzIHRoaXMgdGhlIGNvcnJlY3QgYmVoYXZpb3Igd2hlbiBwYXJzaW5nXG4gICAgICAgIC8vIHRoZSBsYXRleCBcXHRleHR7fSA/ICBUaGlzIHZpb2xhdGVzIHRoZSByZXF1aXJlbWVudCB0aGF0XG4gICAgICAgIC8vIHRoZSB0ZXh0IGNvbnRlbnRzIGFyZSBhbHdheXMgbm9uZW1wdHkuICBTaG91bGQgd2UganVzdFxuICAgICAgICAvLyBkaXNvd24gdGhlIHBhcmVudCBub2RlIGluc3RlYWQ/XG4gICAgICAgIFRleHRQaWVjZSh0ZXh0KS5hZG9wdCh0ZXh0QmxvY2ssIDAsIDApO1xuICAgICAgICByZXR1cm4gdGV4dEJsb2NrO1xuICAgICAgfSlcbiAgICA7XG4gIH07XG5cbiAgXy50ZXh0Q29udGVudHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkQ2hpbGRyZW4oJycsIGZ1bmN0aW9uKHRleHQsIGNoaWxkKSB7XG4gICAgICByZXR1cm4gdGV4dCArIGNoaWxkLnRleHQ7XG4gICAgfSk7XG4gIH07XG4gIF8udGV4dCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ1wiJyArIHRoaXMudGV4dENvbnRlbnRzKCkgKyAnXCInOyB9O1xuICBfLmxhdGV4ID0gZnVuY3Rpb24oKSB7IHJldHVybiAnXFxcXHRleHR7JyArIHRoaXMudGV4dENvbnRlbnRzKCkgKyAnfSc7IH07XG4gIF8uaHRtbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgICc8c3BhbiBjbGFzcz1cIm1xLXRleHQtbW9kZVwiIG1hdGhxdWlsbC1jb21tYW5kLWlkPScrdGhpcy5pZCsnPidcbiAgICAgICsgICB0aGlzLnRleHRDb250ZW50cygpXG4gICAgICArICc8L3NwYW4+J1xuICAgICk7XG4gIH07XG5cbiAgLy8gZWRpdGFiaWxpdHkgbWV0aG9kczogY2FsbGVkIGJ5IHRoZSBjdXJzb3IgZm9yIGVkaXRpbmcsIGN1cnNvciBtb3ZlbWVudHMsXG4gIC8vIGFuZCBzZWxlY3Rpb24gb2YgdGhlIE1hdGhRdWlsbCB0cmVlLCB0aGVzZSBhbGwgdGFrZSBpbiBhIGRpcmVjdGlvbiBhbmRcbiAgLy8gdGhlIGN1cnNvclxuICBfLm1vdmVUb3dhcmRzID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHsgY3Vyc29yLmluc0F0RGlyRW5kKC1kaXIsIHRoaXMpOyB9O1xuICBfLm1vdmVPdXRPZiA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7IGN1cnNvci5pbnNEaXJPZihkaXIsIHRoaXMpOyB9O1xuICBfLnVuc2VsZWN0SW50byA9IF8ubW92ZVRvd2FyZHM7XG5cbiAgLy8gVE9ETzogbWFrZSB0aGVzZSBtZXRob2RzIHBhcnQgb2YgYSBzaGFyZWQgbWl4aW4gb3Igc29tZXRoaW5nLlxuICBfLnNlbGVjdFRvd2FyZHMgPSBNYXRoQ29tbWFuZC5wcm90b3R5cGUuc2VsZWN0VG93YXJkcztcbiAgXy5kZWxldGVUb3dhcmRzID0gTWF0aENvbW1hbmQucHJvdG90eXBlLmRlbGV0ZVRvd2FyZHM7XG5cbiAgXy5zZWxlY3RPdXRPZiA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgY3Vyc29yLmluc0Rpck9mKGRpciwgdGhpcyk7XG4gIH07XG4gIF8uZGVsZXRlT3V0T2YgPSBmdW5jdGlvbihkaXIsIGN1cnNvcikge1xuICAgIC8vIGJhY2tzcGFjZSBhbmQgZGVsZXRlIGF0IGVuZHMgb2YgYmxvY2sgZG9uJ3QgdW53cmFwXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSBjdXJzb3IuaW5zUmlnaHRPZih0aGlzKTtcbiAgfTtcbiAgXy53cml0ZSA9IGZ1bmN0aW9uKGN1cnNvciwgY2gpIHtcbiAgICBjdXJzb3Iuc2hvdygpLmRlbGV0ZVNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGNoICE9PSAnJCcpIHtcbiAgICAgIGlmICghY3Vyc29yW0xdKSBUZXh0UGllY2UoY2gpLmNyZWF0ZUxlZnRPZihjdXJzb3IpO1xuICAgICAgZWxzZSBjdXJzb3JbTF0uYXBwZW5kVGV4dChjaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICBjdXJzb3IuaW5zUmlnaHRPZih0aGlzKTtcbiAgICAgIFZhbmlsbGFTeW1ib2woJ1xcXFwkJywnJCcpLmNyZWF0ZUxlZnRPZihjdXJzb3IpO1xuICAgIH1cbiAgICBlbHNlIGlmICghY3Vyc29yW1JdKSBjdXJzb3IuaW5zUmlnaHRPZih0aGlzKTtcbiAgICBlbHNlIGlmICghY3Vyc29yW0xdKSBjdXJzb3IuaW5zTGVmdE9mKHRoaXMpO1xuICAgIGVsc2UgeyAvLyBzcGxpdCBhcGFydFxuICAgICAgdmFyIGxlZnRCbG9jayA9IFRleHRCbG9jaygpO1xuICAgICAgdmFyIGxlZnRQYyA9IHRoaXMuZW5kc1tMXTtcbiAgICAgIGxlZnRQYy5kaXNvd24oKTtcbiAgICAgIGxlZnRQYy5hZG9wdChsZWZ0QmxvY2ssIDAsIDApO1xuXG4gICAgICBjdXJzb3IuaW5zTGVmdE9mKHRoaXMpO1xuICAgICAgc3VwZXJfLmNyZWF0ZUxlZnRPZi5jYWxsKGxlZnRCbG9jaywgY3Vyc29yKTtcbiAgICB9XG4gIH07XG5cbiAgXy5zZWVrID0gZnVuY3Rpb24ocGFnZVgsIGN1cnNvcikge1xuICAgIGN1cnNvci5oaWRlKCk7XG4gICAgdmFyIHRleHRQYyA9IGZ1c2VDaGlsZHJlbih0aGlzKTtcblxuICAgIC8vIGluc2VydCBjdXJzb3IgYXQgYXBwcm94IHBvc2l0aW9uIGluIERPTVRleHROb2RlXG4gICAgdmFyIGF2Z0NoV2lkdGggPSB0aGlzLmpRLndpZHRoKCkvdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB2YXIgYXBwcm94UG9zaXRpb24gPSBNYXRoLnJvdW5kKChwYWdlWCAtIHRoaXMualEub2Zmc2V0KCkubGVmdCkvYXZnQ2hXaWR0aCk7XG4gICAgaWYgKGFwcHJveFBvc2l0aW9uIDw9IDApIGN1cnNvci5pbnNBdExlZnRFbmQodGhpcyk7XG4gICAgZWxzZSBpZiAoYXBwcm94UG9zaXRpb24gPj0gdGV4dFBjLnRleHQubGVuZ3RoKSBjdXJzb3IuaW5zQXRSaWdodEVuZCh0aGlzKTtcbiAgICBlbHNlIGN1cnNvci5pbnNMZWZ0T2YodGV4dFBjLnNwbGl0UmlnaHQoYXBwcm94UG9zaXRpb24pKTtcblxuICAgIC8vIG1vdmUgdG93YXJkcyBtb3VzZWRvd24gKHBhZ2VYKVxuICAgIHZhciBkaXNwbCA9IHBhZ2VYIC0gY3Vyc29yLnNob3coKS5vZmZzZXQoKS5sZWZ0OyAvLyBkaXNwbGFjZW1lbnRcbiAgICB2YXIgZGlyID0gZGlzcGwgJiYgZGlzcGwgPCAwID8gTCA6IFI7XG4gICAgdmFyIHByZXZEaXNwbCA9IGRpcjtcbiAgICAvLyBkaXNwbCAqIHByZXZEaXNwbCA+IDAgaWZmIGRpc3BsYWNlbWVudCBkaXJlY3Rpb24gPT09IHByZXZpb3VzIGRpcmVjdGlvblxuICAgIHdoaWxlIChjdXJzb3JbZGlyXSAmJiBkaXNwbCAqIHByZXZEaXNwbCA+IDApIHtcbiAgICAgIGN1cnNvcltkaXJdLm1vdmVUb3dhcmRzKGRpciwgY3Vyc29yKTtcbiAgICAgIHByZXZEaXNwbCA9IGRpc3BsO1xuICAgICAgZGlzcGwgPSBwYWdlWCAtIGN1cnNvci5vZmZzZXQoKS5sZWZ0O1xuICAgIH1cbiAgICBpZiAoZGlyKmRpc3BsIDwgLWRpcipwcmV2RGlzcGwpIGN1cnNvclstZGlyXS5tb3ZlVG93YXJkcygtZGlyLCBjdXJzb3IpO1xuXG4gICAgaWYgKCFjdXJzb3IuYW50aWN1cnNvcikge1xuICAgICAgLy8gYWJvdXQgdG8gc3RhcnQgbW91c2Utc2VsZWN0aW5nLCB0aGUgYW50aWN1cnNvciBpcyBnb25uYSBnZXQgcHV0IGhlcmVcbiAgICAgIHRoaXMuYW50aWN1cnNvclBvc2l0aW9uID0gY3Vyc29yW0xdICYmIGN1cnNvcltMXS50ZXh0Lmxlbmd0aDtcbiAgICAgIC8vIF4gZ2V0IGl0PyAnY29zIGlmIHRoZXJlJ3Mgbm8gY3Vyc29yW0xdLCBpdCdzIDAuLi4gSSdtIGEgdGVycmlibGUgcGVyc29uLlxuICAgIH1cbiAgICBlbHNlIGlmIChjdXJzb3IuYW50aWN1cnNvci5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIC8vIG1vdXNlLXNlbGVjdGluZyB3aXRoaW4gdGhpcyBUZXh0QmxvY2ssIHJlLWluc2VydCB0aGUgYW50aWN1cnNvclxuICAgICAgdmFyIGN1cnNvclBvc2l0aW9uID0gY3Vyc29yW0xdICYmIGN1cnNvcltMXS50ZXh0Lmxlbmd0aDs7XG4gICAgICBpZiAodGhpcy5hbnRpY3Vyc29yUG9zaXRpb24gPT09IGN1cnNvclBvc2l0aW9uKSB7XG4gICAgICAgIGN1cnNvci5hbnRpY3Vyc29yID0gUG9pbnQuY29weShjdXJzb3IpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFudGljdXJzb3JQb3NpdGlvbiA8IGN1cnNvclBvc2l0aW9uKSB7XG4gICAgICAgICAgdmFyIG5ld1RleHRQYyA9IGN1cnNvcltMXS5zcGxpdFJpZ2h0KHRoaXMuYW50aWN1cnNvclBvc2l0aW9uKTtcbiAgICAgICAgICBjdXJzb3JbTF0gPSBuZXdUZXh0UGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1RleHRQYyA9IGN1cnNvcltSXS5zcGxpdFJpZ2h0KHRoaXMuYW50aWN1cnNvclBvc2l0aW9uIC0gY3Vyc29yUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnNvci5hbnRpY3Vyc29yID0gUG9pbnQodGhpcywgbmV3VGV4dFBjW0xdLCBuZXdUZXh0UGMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfLmJsdXIgPSBmdW5jdGlvbigpIHtcbiAgICBNYXRoQmxvY2sucHJvdG90eXBlLmJsdXIuY2FsbCh0aGlzKTtcbiAgICBmdXNlQ2hpbGRyZW4odGhpcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZnVzZUNoaWxkcmVuKHNlbGYpIHtcbiAgICBzZWxmLmpRWzBdLm5vcm1hbGl6ZSgpO1xuXG4gICAgdmFyIHRleHRQY0RvbSA9IHNlbGYualFbMF0uZmlyc3RDaGlsZDtcbiAgICBwcmF5KCdvbmx5IG5vZGUgaW4gVGV4dEJsb2NrIHNwYW4gaXMgVGV4dCBub2RlJywgdGV4dFBjRG9tLm5vZGVUeXBlID09PSAzKTtcbiAgICAvLyBub2RlVHlwZSA9PT0gMyBoYXMgbWVhbnQgYSBUZXh0IG5vZGUgc2luY2UgYW5jaWVudCB0aW1lczpcbiAgICAvLyAgIGh0dHA6Ly9yZWZlcmVuY2Uuc2l0ZXBvaW50LmNvbS9qYXZhc2NyaXB0L05vZGUvbm9kZVR5cGVcblxuICAgIHZhciB0ZXh0UGMgPSBUZXh0UGllY2UodGV4dFBjRG9tLmRhdGEpO1xuICAgIHRleHRQYy5qUWFkZCh0ZXh0UGNEb20pO1xuXG4gICAgc2VsZi5jaGlsZHJlbigpLmRpc293bigpO1xuICAgIHJldHVybiB0ZXh0UGMuYWRvcHQoc2VsZiwgMCwgMCk7XG4gIH1cblxuICBfLmZvY3VzID0gTWF0aEJsb2NrLnByb3RvdHlwZS5mb2N1cztcbn0pO1xuXG4vKipcbiAqIFBpZWNlIG9mIHBsYWluIHRleHQsIHdpdGggYSBUZXh0QmxvY2sgYXMgYSBwYXJlbnQgYW5kIG5vIGNoaWxkcmVuLlxuICogV3JhcHMgYSBzaW5nbGUgRE9NVGV4dE5vZGUuXG4gKiBGb3IgY29udmVuaWVuY2UsIGhhcyBhIC50ZXh0IHByb3BlcnR5IHRoYXQncyBqdXN0IGEgSmF2YVNjcmlwdCBzdHJpbmdcbiAqIG1pcnJvcmluZyB0aGUgdGV4dCBjb250ZW50cyBvZiB0aGUgRE9NVGV4dE5vZGUuXG4gKiBUZXh0IGNvbnRlbnRzIG11c3QgYWx3YXlzIGJlIG5vbmVtcHR5LlxuICovXG52YXIgVGV4dFBpZWNlID0gUChOb2RlLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcyk7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfTtcbiAgXy5qUWFkZCA9IGZ1bmN0aW9uKGRvbSkgeyB0aGlzLmRvbSA9IGRvbTsgdGhpcy5qUSA9ICQoZG9tKTsgfTtcbiAgXy5qUWl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmpRYWRkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCkpO1xuICB9O1xuICBfLmFwcGVuZFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ICs9IHRleHQ7XG4gICAgdGhpcy5kb20uYXBwZW5kRGF0YSh0ZXh0KTtcbiAgfTtcbiAgXy5wcmVwZW5kVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0ICsgdGhpcy50ZXh0O1xuICAgIHRoaXMuZG9tLmluc2VydERhdGEoMCwgdGV4dCk7XG4gIH07XG4gIF8uaW5zVGV4dEF0RGlyRW5kID0gZnVuY3Rpb24odGV4dCwgZGlyKSB7XG4gICAgcHJheURpcmVjdGlvbihkaXIpO1xuICAgIGlmIChkaXIgPT09IFIpIHRoaXMuYXBwZW5kVGV4dCh0ZXh0KTtcbiAgICBlbHNlIHRoaXMucHJlcGVuZFRleHQodGV4dCk7XG4gIH07XG4gIF8uc3BsaXRSaWdodCA9IGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgbmV3UGMgPSBUZXh0UGllY2UodGhpcy50ZXh0LnNsaWNlKGkpKS5hZG9wdCh0aGlzLnBhcmVudCwgdGhpcywgdGhpc1tSXSk7XG4gICAgbmV3UGMualFhZGQodGhpcy5kb20uc3BsaXRUZXh0KGkpKTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIG5ld1BjO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVuZENoYXIoZGlyLCB0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQuY2hhckF0KGRpciA9PT0gTCA/IDAgOiAtMSArIHRleHQubGVuZ3RoKTtcbiAgfVxuXG4gIF8ubW92ZVRvd2FyZHMgPSBmdW5jdGlvbihkaXIsIGN1cnNvcikge1xuICAgIHByYXlEaXJlY3Rpb24oZGlyKTtcblxuICAgIHZhciBjaCA9IGVuZENoYXIoLWRpciwgdGhpcy50ZXh0KVxuXG4gICAgdmFyIGZyb20gPSB0aGlzWy1kaXJdO1xuICAgIGlmIChmcm9tKSBmcm9tLmluc1RleHRBdERpckVuZChjaCwgZGlyKTtcbiAgICBlbHNlIFRleHRQaWVjZShjaCkuY3JlYXRlRGlyKC1kaXIsIGN1cnNvcik7XG5cbiAgICByZXR1cm4gdGhpcy5kZWxldGVUb3dhcmRzKGRpciwgY3Vyc29yKTtcbiAgfTtcblxuICBfLmxhdGV4ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRleHQ7IH07XG5cbiAgXy5kZWxldGVUb3dhcmRzID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBpZiAodGhpcy50ZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmIChkaXIgPT09IFIpIHtcbiAgICAgICAgdGhpcy5kb20uZGVsZXRlRGF0YSgwLCAxKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlc2UgMiBsaW5lcyBpcyBhbm5veWluZ2x5IGltcG9ydGFudFxuICAgICAgICAvLyAodGhlIHNlY29uZCBsaW5lIG11dGF0ZXMgdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgdGhpcy5kb20uZGVsZXRlRGF0YSgtMSArIHRoaXMudGV4dC5sZW5ndGgsIDEpO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB0aGlzLmpRLnJlbW92ZSgpO1xuICAgICAgY3Vyc29yW2Rpcl0gPSB0aGlzW2Rpcl07XG4gICAgfVxuICB9O1xuXG4gIF8uc2VsZWN0VG93YXJkcyA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgcHJheURpcmVjdGlvbihkaXIpO1xuICAgIHZhciBhbnRpY3Vyc29yID0gY3Vyc29yLmFudGljdXJzb3I7XG5cbiAgICB2YXIgY2ggPSBlbmRDaGFyKC1kaXIsIHRoaXMudGV4dClcblxuICAgIGlmIChhbnRpY3Vyc29yW2Rpcl0gPT09IHRoaXMpIHtcbiAgICAgIHZhciBuZXdQYyA9IFRleHRQaWVjZShjaCkuY3JlYXRlRGlyKGRpciwgY3Vyc29yKTtcbiAgICAgIGFudGljdXJzb3JbZGlyXSA9IG5ld1BjO1xuICAgICAgY3Vyc29yLmluc0Rpck9mKGRpciwgbmV3UGMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBmcm9tID0gdGhpc1stZGlyXTtcbiAgICAgIGlmIChmcm9tKSBmcm9tLmluc1RleHRBdERpckVuZChjaCwgZGlyKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgbmV3UGMgPSBUZXh0UGllY2UoY2gpLmNyZWF0ZURpcigtZGlyLCBjdXJzb3IpO1xuICAgICAgICBuZXdQYy5qUS5pbnNEaXJPZigtZGlyLCBjdXJzb3Iuc2VsZWN0aW9uLmpRKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGV4dC5sZW5ndGggPT09IDEgJiYgYW50aWN1cnNvclstZGlyXSA9PT0gdGhpcykge1xuICAgICAgICBhbnRpY3Vyc29yWy1kaXJdID0gdGhpc1stZGlyXTsgLy8gYHRoaXNgIHdpbGwgYmUgcmVtb3ZlZCBpbiBkZWxldGVUb3dhcmRzXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlVG93YXJkcyhkaXIsIGN1cnNvcik7XG4gIH07XG59KTtcblxuQ2hhckNtZHMuJCA9XG5MYXRleENtZHMudGV4dCA9XG5MYXRleENtZHMudGV4dG5vcm1hbCA9XG5MYXRleENtZHMudGV4dHJtID1cbkxhdGV4Q21kcy50ZXh0dXAgPVxuTGF0ZXhDbWRzLnRleHRtZCA9IFRleHRCbG9jaztcblxuZnVuY3Rpb24gbWFrZVRleHRCbG9jayhsYXRleCwgdGFnTmFtZSwgYXR0cnMpIHtcbiAgcmV0dXJuIFAoVGV4dEJsb2NrLCB7XG4gICAgY3RybFNlcTogbGF0ZXgsXG4gICAgaHRtbFRlbXBsYXRlOiAnPCcrdGFnTmFtZSsnICcrYXR0cnMrJz4mMDwvJyt0YWdOYW1lKyc+J1xuICB9KTtcbn1cblxuTGF0ZXhDbWRzLmVtID0gTGF0ZXhDbWRzLml0YWxpYyA9IExhdGV4Q21kcy5pdGFsaWNzID1cbkxhdGV4Q21kcy5lbXBoID0gTGF0ZXhDbWRzLnRleHRpdCA9IExhdGV4Q21kcy50ZXh0c2wgPVxuICBtYWtlVGV4dEJsb2NrKCdcXFxcdGV4dGl0JywgJ2knLCAnY2xhc3M9XCJtcS10ZXh0LW1vZGVcIicpO1xuTGF0ZXhDbWRzLnN0cm9uZyA9IExhdGV4Q21kcy5ib2xkID0gTGF0ZXhDbWRzLnRleHRiZiA9XG4gIG1ha2VUZXh0QmxvY2soJ1xcXFx0ZXh0YmYnLCAnYicsICdjbGFzcz1cIm1xLXRleHQtbW9kZVwiJyk7XG5MYXRleENtZHMuc2YgPSBMYXRleENtZHMudGV4dHNmID1cbiAgbWFrZVRleHRCbG9jaygnXFxcXHRleHRzZicsICdzcGFuJywgJ2NsYXNzPVwibXEtc2Fucy1zZXJpZiBtcS10ZXh0LW1vZGVcIicpO1xuTGF0ZXhDbWRzLnR0ID0gTGF0ZXhDbWRzLnRleHR0dCA9XG4gIG1ha2VUZXh0QmxvY2soJ1xcXFx0ZXh0dHQnLCAnc3BhbicsICdjbGFzcz1cIm1xLW1vbm9zcGFjZSBtcS10ZXh0LW1vZGVcIicpO1xuTGF0ZXhDbWRzLnRleHRzYyA9XG4gIG1ha2VUZXh0QmxvY2soJ1xcXFx0ZXh0c2MnLCAnc3BhbicsICdzdHlsZT1cImZvbnQtdmFyaWFudDpzbWFsbC1jYXBzXCIgY2xhc3M9XCJtcS10ZXh0LW1vZGVcIicpO1xuTGF0ZXhDbWRzLnVwcGVyY2FzZSA9XG4gIG1ha2VUZXh0QmxvY2soJ1xcXFx1cHBlcmNhc2UnLCAnc3BhbicsICdzdHlsZT1cInRleHQtdHJhbnNmb3JtOnVwcGVyY2FzZVwiIGNsYXNzPVwibXEtdGV4dC1tb2RlXCInKTtcbkxhdGV4Q21kcy5sb3dlcmNhc2UgPVxuICBtYWtlVGV4dEJsb2NrKCdcXFxcbG93ZXJjYXNlJywgJ3NwYW4nLCAnc3R5bGU9XCJ0ZXh0LXRyYW5zZm9ybTpsb3dlcmNhc2VcIiBjbGFzcz1cIm1xLXRleHQtbW9kZVwiJyk7XG5cblxudmFyIFJvb3RNYXRoQ29tbWFuZCA9IFAoTWF0aENvbW1hbmQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICBzdXBlcl8uaW5pdC5jYWxsKHRoaXMsICckJyk7XG4gICAgdGhpcy5jdXJzb3IgPSBjdXJzb3I7XG4gIH07XG4gIF8uaHRtbFRlbXBsYXRlID0gJzxzcGFuIGNsYXNzPVwibXEtbWF0aC1tb2RlXCI+JjA8L3NwYW4+JztcbiAgXy5jcmVhdGVCbG9ja3MgPSBmdW5jdGlvbigpIHtcbiAgICBzdXBlcl8uY3JlYXRlQmxvY2tzLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmVuZHNbTF0uY3Vyc29yID0gdGhpcy5jdXJzb3I7XG4gICAgdGhpcy5lbmRzW0xdLndyaXRlID0gZnVuY3Rpb24oY3Vyc29yLCBjaCkge1xuICAgICAgaWYgKGNoICE9PSAnJCcpXG4gICAgICAgIE1hdGhCbG9jay5wcm90b3R5cGUud3JpdGUuY2FsbCh0aGlzLCBjdXJzb3IsIGNoKTtcbiAgICAgIGVsc2UgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIGN1cnNvci5pbnNSaWdodE9mKHRoaXMucGFyZW50KTtcbiAgICAgICAgdGhpcy5wYXJlbnQuZGVsZXRlVG93YXJkcyhkaXIsIGN1cnNvcik7XG4gICAgICAgIFZhbmlsbGFTeW1ib2woJ1xcXFwkJywnJCcpLmNyZWF0ZUxlZnRPZihjdXJzb3Iuc2hvdygpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFjdXJzb3JbUl0pXG4gICAgICAgIGN1cnNvci5pbnNSaWdodE9mKHRoaXMucGFyZW50KTtcbiAgICAgIGVsc2UgaWYgKCFjdXJzb3JbTF0pXG4gICAgICAgIGN1cnNvci5pbnNMZWZ0T2YodGhpcy5wYXJlbnQpO1xuICAgICAgZWxzZVxuICAgICAgICBNYXRoQmxvY2sucHJvdG90eXBlLndyaXRlLmNhbGwodGhpcywgY3Vyc29yLCBjaCk7XG4gICAgfTtcbiAgfTtcbiAgXy5sYXRleCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJCcgKyB0aGlzLmVuZHNbTF0ubGF0ZXgoKSArICckJztcbiAgfTtcbn0pO1xuXG52YXIgUm9vdFRleHRCbG9jayA9IFAoUm9vdE1hdGhCbG9jaywgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8ua2V5c3Ryb2tlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGtleSA9PT0gJ1NwYWNlYmFyJyB8fCBrZXkgPT09ICdTaGlmdC1TcGFjZWJhcicpIHJldHVybjtcbiAgICByZXR1cm4gc3VwZXJfLmtleXN0cm9rZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBfLndyaXRlID0gZnVuY3Rpb24oY3Vyc29yLCBjaCkge1xuICAgIGN1cnNvci5zaG93KCkuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgaWYgKGNoID09PSAnJCcpXG4gICAgICBSb290TWF0aENvbW1hbmQoY3Vyc29yKS5jcmVhdGVMZWZ0T2YoY3Vyc29yKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBodG1sO1xuICAgICAgaWYgKGNoID09PSAnPCcpIGh0bWwgPSAnJmx0Oyc7XG4gICAgICBlbHNlIGlmIChjaCA9PT0gJz4nKSBodG1sID0gJyZndDsnO1xuICAgICAgVmFuaWxsYVN5bWJvbChjaCwgaHRtbCkuY3JlYXRlTGVmdE9mKGN1cnNvcik7XG4gICAgfVxuICB9O1xufSk7XG5BUEkuVGV4dEZpZWxkID0gZnVuY3Rpb24oQVBJQ2xhc3Nlcykge1xuICByZXR1cm4gUChBUElDbGFzc2VzLkVkaXRhYmxlRmllbGQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICAgIHRoaXMuUm9vdEJsb2NrID0gUm9vdFRleHRCbG9jaztcbiAgICBfLl9fbWF0aHF1aWxsaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3VwZXJfLl9fbWF0aHF1aWxsaWZ5LmNhbGwodGhpcywgJ21xLWVkaXRhYmxlLWZpZWxkIG1xLXRleHQtbW9kZScpO1xuICAgIH07XG4gICAgXy5sYXRleCA9IGZ1bmN0aW9uKGxhdGV4KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fX2NvbnRyb2xsZXIucmVuZGVyTGF0ZXhUZXh0KGxhdGV4KTtcbiAgICAgICAgaWYgKHRoaXMuX19jb250cm9sbGVyLmJsdXJyZWQpIHRoaXMuX19jb250cm9sbGVyLmN1cnNvci5oaWRlKCkucGFyZW50LmJsdXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2NvbnRyb2xsZXIuZXhwb3J0TGF0ZXgoKTtcbiAgICB9O1xuICB9KTtcbn07XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogSW5wdXQgYm94IHRvIHR5cGUgYmFja3NsYXNoIGNvbW1hbmRzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgTGF0ZXhDb21tYW5kSW5wdXQgPVxuQ2hhckNtZHNbJ1xcXFwnXSA9IFAoTWF0aENvbW1hbmQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmN0cmxTZXEgPSAnXFxcXCc7XG4gIF8ucmVwbGFjZXMgPSBmdW5jdGlvbihyZXBsYWNlZEZyYWdtZW50KSB7XG4gICAgdGhpcy5fcmVwbGFjZWRGcmFnbWVudCA9IHJlcGxhY2VkRnJhZ21lbnQuZGlzb3duKCk7XG4gICAgdGhpcy5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgfTtcbiAgXy5odG1sVGVtcGxhdGUgPSAnPHNwYW4gY2xhc3M9XCJtcS1sYXRleC1jb21tYW5kLWlucHV0IG1xLW5vbi1sZWFmXCI+XFxcXDxzcGFuPiYwPC9zcGFuPjwvc3Bhbj4nO1xuICBfLnRleHRUZW1wbGF0ZSA9IFsnXFxcXCddO1xuICBfLmNyZWF0ZUJsb2NrcyA9IGZ1bmN0aW9uKCkge1xuICAgIHN1cGVyXy5jcmVhdGVCbG9ja3MuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVuZHNbTF0uZm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucGFyZW50LmpRLmFkZENsYXNzKCdtcS1oYXNDdXJzb3InKTtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSlcbiAgICAgICAgdGhpcy5wYXJlbnQualEucmVtb3ZlQ2xhc3MoJ21xLWVtcHR5Jyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy5lbmRzW0xdLmJsdXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucGFyZW50LmpRLnJlbW92ZUNsYXNzKCdtcS1oYXNDdXJzb3InKTtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSlcbiAgICAgICAgdGhpcy5wYXJlbnQualEuYWRkQ2xhc3MoJ21xLWVtcHR5Jyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy5lbmRzW0xdLndyaXRlID0gZnVuY3Rpb24oY3Vyc29yLCBjaCkge1xuICAgICAgY3Vyc29yLnNob3coKS5kZWxldGVTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKGNoLm1hdGNoKC9bYS16XS9pKSkgVmFuaWxsYVN5bWJvbChjaCkuY3JlYXRlTGVmdE9mKGN1cnNvcik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQucmVuZGVyQ29tbWFuZChjdXJzb3IpO1xuICAgICAgICBpZiAoY2ggIT09ICdcXFxcJyB8fCAhdGhpcy5pc0VtcHR5KCkpIHRoaXMucGFyZW50LnBhcmVudC53cml0ZShjdXJzb3IsIGNoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZW5kc1tMXS5rZXlzdHJva2UgPSBmdW5jdGlvbihrZXksIGUsIGN0cmxyKSB7XG4gICAgICBpZiAoa2V5ID09PSAnVGFiJyB8fCBrZXkgPT09ICdFbnRlcicgfHwga2V5ID09PSAnU3BhY2ViYXInKSB7XG4gICAgICAgIHRoaXMucGFyZW50LnJlbmRlckNvbW1hbmQoY3RybHIuY3Vyc29yKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXJfLmtleXN0cm9rZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG4gIF8uY3JlYXRlTGVmdE9mID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgc3VwZXJfLmNyZWF0ZUxlZnRPZi5jYWxsKHRoaXMsIGN1cnNvcik7XG5cbiAgICBpZiAodGhpcy5fcmVwbGFjZWRGcmFnbWVudCkge1xuICAgICAgdmFyIGVsID0gdGhpcy5qUVswXTtcbiAgICAgIHRoaXMualEgPVxuICAgICAgICB0aGlzLl9yZXBsYWNlZEZyYWdtZW50LmpRLmFkZENsYXNzKCdtcS1ibHVyJykuYmluZChcbiAgICAgICAgICAnbW91c2Vkb3duIG1vdXNlbW92ZScsIC8vRklYTUU6IGlzIG1vbmtleS1wYXRjaGluZyB0aGUgbW91c2Vkb3duIGFuZCBtb3VzZW1vdmUgaGFuZGxlcnMgdGhlIHJpZ2h0IHdheSB0byBkbyB0aGlzP1xuICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICQoZS50YXJnZXQgPSBlbCkudHJpZ2dlcihlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICkuaW5zZXJ0QmVmb3JlKHRoaXMualEpLmFkZCh0aGlzLmpRKTtcbiAgICB9XG4gIH07XG4gIF8ubGF0ZXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgdGhpcy5lbmRzW0xdLmxhdGV4KCkgKyAnICc7XG4gIH07XG4gIF8ucmVuZGVyQ29tbWFuZCA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIHRoaXMualEgPSB0aGlzLmpRLmxhc3QoKTtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIGlmICh0aGlzW1JdKSB7XG4gICAgICBjdXJzb3IuaW5zTGVmdE9mKHRoaXNbUl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IuaW5zQXRSaWdodEVuZCh0aGlzLnBhcmVudCk7XG4gICAgfVxuXG4gICAgdmFyIGxhdGV4ID0gdGhpcy5lbmRzW0xdLmxhdGV4KCk7XG4gICAgaWYgKCFsYXRleCkgbGF0ZXggPSAnICc7XG4gICAgdmFyIGNtZCA9IExhdGV4Q21kc1tsYXRleF07XG4gICAgaWYgKGNtZCkge1xuICAgICAgY21kID0gY21kKGxhdGV4KTtcbiAgICAgIGlmICh0aGlzLl9yZXBsYWNlZEZyYWdtZW50KSBjbWQucmVwbGFjZXModGhpcy5fcmVwbGFjZWRGcmFnbWVudCk7XG4gICAgICBjbWQuY3JlYXRlTGVmdE9mKGN1cnNvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY21kID0gVGV4dEJsb2NrKCk7XG4gICAgICBjbWQucmVwbGFjZXMobGF0ZXgpO1xuICAgICAgY21kLmNyZWF0ZUxlZnRPZihjdXJzb3IpO1xuICAgICAgY3Vyc29yLmluc1JpZ2h0T2YoY21kKTtcbiAgICAgIGlmICh0aGlzLl9yZXBsYWNlZEZyYWdtZW50KVxuICAgICAgICB0aGlzLl9yZXBsYWNlZEZyYWdtZW50LnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBTeW1ib2xzIGZvciBBZHZhbmNlZCBNYXRoZW1hdGljc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5MYXRleENtZHMubm90aW4gPVxuTGF0ZXhDbWRzLmNvbmcgPVxuTGF0ZXhDbWRzLmVxdWl2ID1cbkxhdGV4Q21kcy5vcGx1cyA9XG5MYXRleENtZHMub3RpbWVzID0gUChCaW5hcnlPcGVyYXRvciwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGxhdGV4KSB7XG4gICAgc3VwZXJfLmluaXQuY2FsbCh0aGlzLCAnXFxcXCcrbGF0ZXgrJyAnLCAnJicrbGF0ZXgrJzsnKTtcbiAgfTtcbn0pO1xuXG5MYXRleENtZHNbJ1xcdTIyNjAnXSA9IExhdGV4Q21kcy5uZSA9IExhdGV4Q21kcy5uZXEgPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcbmUgJywnJm5lOycpO1xuXG5MYXRleENtZHMuYXN0ID0gTGF0ZXhDbWRzLnN0YXIgPSBMYXRleENtZHMubG9hc3QgPSBMYXRleENtZHMubG93YXN0ID1cbiAgYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXGFzdCAnLCcmbG93YXN0OycpO1xuICAvL2Nhc2UgJ3RoZXJlNCA9IC8vIGEgc3BlY2lhbCBleGNlcHRpb24gZm9yIHRoaXMgb25lLCBwZXJoYXBzP1xuTGF0ZXhDbWRzLnRoZXJlZm9yID0gTGF0ZXhDbWRzLnRoZXJlZm9yZSA9XG4gIGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFx0aGVyZWZvcmUgJywnJnRoZXJlNDsnKTtcblxuTGF0ZXhDbWRzLmN1eiA9IC8vIGwzM3RcbkxhdGV4Q21kcy5iZWNhdXNlID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXGJlY2F1c2UgJywnJiM4NzU3OycpO1xuXG5MYXRleENtZHMucHJvcCA9IExhdGV4Q21kcy5wcm9wdG8gPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxccHJvcHRvICcsJyZwcm9wOycpO1xuXG5MYXRleENtZHNbJ1xcdTIyNDgnXSA9IExhdGV4Q21kcy5hc3ltcCA9IExhdGV4Q21kcy5hcHByb3ggPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcYXBwcm94ICcsJyZhc3ltcDsnKTtcblxuTGF0ZXhDbWRzLmlzaW4gPSBMYXRleENtZHNbJ2luJ10gPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcaW4gJywnJmlzaW47Jyk7XG5cbkxhdGV4Q21kcy5uaSA9IExhdGV4Q21kcy5jb250YWlucyA9IGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxuaSAnLCcmbmk7Jyk7XG5cbkxhdGV4Q21kcy5ub3RuaSA9IExhdGV4Q21kcy5uaXRvbiA9IExhdGV4Q21kcy5ub3Rjb250YWlucyA9IExhdGV4Q21kcy5kb2Vzbm90Y29udGFpbiA9XG4gIGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxub3RcXFxcbmkgJywnJiM4NzE2OycpO1xuXG5MYXRleENtZHMuc3ViID0gTGF0ZXhDbWRzLnN1YnNldCA9IGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxzdWJzZXQgJywnJnN1YjsnKTtcblxuTGF0ZXhDbWRzLnN1cCA9IExhdGV4Q21kcy5zdXBzZXQgPSBMYXRleENtZHMuc3VwZXJzZXQgPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcc3Vwc2V0ICcsJyZzdXA7Jyk7XG5cbkxhdGV4Q21kcy5uc3ViID0gTGF0ZXhDbWRzLm5vdHN1YiA9XG5MYXRleENtZHMubnN1YnNldCA9IExhdGV4Q21kcy5ub3RzdWJzZXQgPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcbm90XFxcXHN1YnNldCAnLCcmIzg4MzY7Jyk7XG5cbkxhdGV4Q21kcy5uc3VwID0gTGF0ZXhDbWRzLm5vdHN1cCA9XG5MYXRleENtZHMubnN1cHNldCA9IExhdGV4Q21kcy5ub3RzdXBzZXQgPVxuTGF0ZXhDbWRzLm5zdXBlcnNldCA9IExhdGV4Q21kcy5ub3RzdXBlcnNldCA9XG4gIGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxub3RcXFxcc3Vwc2V0ICcsJyYjODgzNzsnKTtcblxuTGF0ZXhDbWRzLnN1YmUgPSBMYXRleENtZHMuc3ViZXEgPSBMYXRleENtZHMuc3Vic2V0ZSA9IExhdGV4Q21kcy5zdWJzZXRlcSA9XG4gIGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxzdWJzZXRlcSAnLCcmc3ViZTsnKTtcblxuTGF0ZXhDbWRzLnN1cGUgPSBMYXRleENtZHMuc3VwZXEgPVxuTGF0ZXhDbWRzLnN1cHNldGUgPSBMYXRleENtZHMuc3Vwc2V0ZXEgPVxuTGF0ZXhDbWRzLnN1cGVyc2V0ZSA9IExhdGV4Q21kcy5zdXBlcnNldGVxID1cbiAgYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXHN1cHNldGVxICcsJyZzdXBlOycpO1xuXG5MYXRleENtZHMubnN1YmUgPSBMYXRleENtZHMubnN1YmVxID1cbkxhdGV4Q21kcy5ub3RzdWJlID0gTGF0ZXhDbWRzLm5vdHN1YmVxID1cbkxhdGV4Q21kcy5uc3Vic2V0ZSA9IExhdGV4Q21kcy5uc3Vic2V0ZXEgPVxuTGF0ZXhDbWRzLm5vdHN1YnNldGUgPSBMYXRleENtZHMubm90c3Vic2V0ZXEgPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcbm90XFxcXHN1YnNldGVxICcsJyYjODg0MDsnKTtcblxuTGF0ZXhDbWRzLm5zdXBlID0gTGF0ZXhDbWRzLm5zdXBlcSA9XG5MYXRleENtZHMubm90c3VwZSA9IExhdGV4Q21kcy5ub3RzdXBlcSA9XG5MYXRleENtZHMubnN1cHNldGUgPSBMYXRleENtZHMubnN1cHNldGVxID1cbkxhdGV4Q21kcy5ub3RzdXBzZXRlID0gTGF0ZXhDbWRzLm5vdHN1cHNldGVxID1cbkxhdGV4Q21kcy5uc3VwZXJzZXRlID0gTGF0ZXhDbWRzLm5zdXBlcnNldGVxID1cbkxhdGV4Q21kcy5ub3RzdXBlcnNldGUgPSBMYXRleENtZHMubm90c3VwZXJzZXRlcSA9XG4gIGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxub3RcXFxcc3Vwc2V0ZXEgJywnJiM4ODQxOycpO1xuXG5cbi8vdGhlIGNhbm9uaWNhbCBzZXRzIG9mIG51bWJlcnNcbkxhdGV4Q21kcy5OID0gTGF0ZXhDbWRzLm5hdHVyYWxzID0gTGF0ZXhDbWRzLk5hdHVyYWxzID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbWF0aGJie059JywnJiM4NDY5OycpO1xuXG5MYXRleENtZHMuUCA9XG5MYXRleENtZHMucHJpbWVzID0gTGF0ZXhDbWRzLlByaW1lcyA9XG5MYXRleENtZHMucHJvamVjdGl2ZSA9IExhdGV4Q21kcy5Qcm9qZWN0aXZlID1cbkxhdGV4Q21kcy5wcm9iYWJpbGl0eSA9IExhdGV4Q21kcy5Qcm9iYWJpbGl0eSA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXG1hdGhiYntQfScsJyYjODQ3MzsnKTtcblxuTGF0ZXhDbWRzLlogPSBMYXRleENtZHMuaW50ZWdlcnMgPSBMYXRleENtZHMuSW50ZWdlcnMgPVxuICBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxtYXRoYmJ7Wn0nLCcmIzg0ODQ7Jyk7XG5cbkxhdGV4Q21kcy5RID0gTGF0ZXhDbWRzLnJhdGlvbmFscyA9IExhdGV4Q21kcy5SYXRpb25hbHMgPVxuICBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxtYXRoYmJ7UX0nLCcmIzg0NzQ7Jyk7XG5cbkxhdGV4Q21kcy5SID0gTGF0ZXhDbWRzLnJlYWxzID0gTGF0ZXhDbWRzLlJlYWxzID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbWF0aGJie1J9JywnJiM4NDc3OycpO1xuXG5MYXRleENtZHMuQyA9XG5MYXRleENtZHMuY29tcGxleCA9IExhdGV4Q21kcy5Db21wbGV4ID1cbkxhdGV4Q21kcy5jb21wbGV4ZXMgPSBMYXRleENtZHMuQ29tcGxleGVzID1cbkxhdGV4Q21kcy5jb21wbGV4cGxhbmUgPSBMYXRleENtZHMuQ29tcGxleHBsYW5lID0gTGF0ZXhDbWRzLkNvbXBsZXhQbGFuZSA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXG1hdGhiYntDfScsJyYjODQ1MDsnKTtcblxuTGF0ZXhDbWRzLkggPSBMYXRleENtZHMuSGFtaWx0b25pYW4gPSBMYXRleENtZHMucXVhdGVybmlvbnMgPSBMYXRleENtZHMuUXVhdGVybmlvbnMgPVxuICBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxtYXRoYmJ7SH0nLCcmIzg0NjE7Jyk7XG5cbi8vc3BhY2luZ1xuTGF0ZXhDbWRzLnF1YWQgPSBMYXRleENtZHMuZW1zcCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXHF1YWQgJywnICAgICcpO1xuTGF0ZXhDbWRzLnFxdWFkID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxccXF1YWQgJywnICAgICAgICAnKTtcbi8qIHNwYWNpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzLCBnb25uYSBoYXZlIHRvIGltcGxlbWVudCB0aGlzIGluIExhdGV4Q29tbWFuZElucHV0OjpvblRleHQgc29tZWhvd1xuY2FzZSAnLCc6XG4gIHJldHVybiBWYW5pbGxhU3ltYm9sKCdcXFxcLCAnLCcgJyk7XG5jYXNlICc6JzpcbiAgcmV0dXJuIFZhbmlsbGFTeW1ib2woJ1xcXFw6ICcsJyAgJyk7XG5jYXNlICc7JzpcbiAgcmV0dXJuIFZhbmlsbGFTeW1ib2woJ1xcXFw7ICcsJyAgICcpO1xuY2FzZSAnISc6XG4gIHJldHVybiBTeW1ib2woJ1xcXFwhICcsJzxzcGFuIHN0eWxlPVwibWFyZ2luLXJpZ2h0Oi0uMmVtXCI+PC9zcGFuPicpO1xuKi9cblxuLy9iaW5hcnkgb3BlcmF0b3JzXG5MYXRleENtZHMuZGlhbW9uZCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxkaWFtb25kICcsICcmIzk2NzE7Jyk7XG5MYXRleENtZHMuYmlndHJpYW5nbGV1cCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxiaWd0cmlhbmdsZXVwICcsICcmIzk2NTE7Jyk7XG5MYXRleENtZHMub21pbnVzID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXG9taW51cyAnLCAnJiM4ODU0OycpO1xuTGF0ZXhDbWRzLnVwbHVzID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHVwbHVzICcsICcmIzg4NDY7Jyk7XG5MYXRleENtZHMuYmlndHJpYW5nbGVkb3duID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJpZ3RyaWFuZ2xlZG93biAnLCAnJiM5NjYxOycpO1xuTGF0ZXhDbWRzLnNxY2FwID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHNxY2FwICcsICcmIzg4NTE7Jyk7XG5MYXRleENtZHMudHJpYW5nbGVsZWZ0ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHRyaWFuZ2xlbGVmdCAnLCAnJiM4ODgyOycpO1xuTGF0ZXhDbWRzLnNxY3VwID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHNxY3VwICcsICcmIzg4NTI7Jyk7XG5MYXRleENtZHMudHJpYW5nbGVyaWdodCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFx0cmlhbmdsZXJpZ2h0ICcsICcmIzg4ODM7Jyk7XG4vL2NpcmNsZWRvdCBpcyBub3QgYSBub3QgcmVhbCBMYVRleCBjb21tYW5kIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWF0aHF1aWxsL21hdGhxdWlsbC9wdWxsLzU1MiBmb3IgbW9yZSBkZXRhaWxzXG5MYXRleENtZHMub2RvdCA9IExhdGV4Q21kcy5jaXJjbGVkb3QgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcb2RvdCAnLCAnJiM4ODU3OycpO1xuTGF0ZXhDbWRzLmJpZ2NpcmMgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcYmlnY2lyYyAnLCAnJiM5NzExOycpO1xuTGF0ZXhDbWRzLmRhZ2dlciA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxkYWdnZXIgJywgJyYjMDEzNDsnKTtcbkxhdGV4Q21kcy5kZGFnZ2VyID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGRkYWdnZXIgJywgJyYjMTM1OycpO1xuTGF0ZXhDbWRzLndyID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHdyICcsICcmIzg3Njg7Jyk7XG5MYXRleENtZHMuYW1hbGcgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcYW1hbGcgJywgJyYjODcyMDsnKTtcblxuLy9yZWxhdGlvbnNoaXAgc3ltYm9sc1xuTGF0ZXhDbWRzLm1vZGVscyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxtb2RlbHMgJywgJyYjODg3MjsnKTtcbkxhdGV4Q21kcy5wcmVjID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHByZWMgJywgJyYjODgyNjsnKTtcbkxhdGV4Q21kcy5zdWNjID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHN1Y2MgJywgJyYjODgyNzsnKTtcbkxhdGV4Q21kcy5wcmVjZXEgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxccHJlY2VxICcsICcmIzg4Mjg7Jyk7XG5MYXRleENtZHMuc3VjY2VxID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHN1Y2NlcSAnLCAnJiM4ODI5OycpO1xuTGF0ZXhDbWRzLnNpbWVxID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHNpbWVxICcsICcmIzg3NzE7Jyk7XG5MYXRleENtZHMubWlkID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXG1pZCAnLCAnJiM4NzM5OycpO1xuTGF0ZXhDbWRzLmxsID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGxsICcsICcmIzg4MTA7Jyk7XG5MYXRleENtZHMuZ2cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcZ2cgJywgJyYjODgxMTsnKTtcbkxhdGV4Q21kcy5wYXJhbGxlbCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxwYXJhbGxlbCAnLCAnJiM4NzQxOycpO1xuTGF0ZXhDbWRzLm5wYXJhbGxlbCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxucGFyYWxsZWwgJywgJyYjODc0MjsnKTtcbkxhdGV4Q21kcy5ib3d0aWUgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcYm93dGllICcsICcmIzg5MDQ7Jyk7XG5MYXRleENtZHMuc3FzdWJzZXQgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcc3FzdWJzZXQgJywgJyYjODg0NzsnKTtcbkxhdGV4Q21kcy5zcXN1cHNldCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzcXN1cHNldCAnLCAnJiM4ODQ4OycpO1xuTGF0ZXhDbWRzLnNtaWxlID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHNtaWxlICcsICcmIzg5OTU7Jyk7XG5MYXRleENtZHMuc3FzdWJzZXRlcSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzcXN1YnNldGVxICcsICcmIzg4NDk7Jyk7XG5MYXRleENtZHMuc3FzdXBzZXRlcSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzcXN1cHNldGVxICcsICcmIzg4NTA7Jyk7XG5MYXRleENtZHMuZG90ZXEgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcZG90ZXEgJywgJyYjODc4NDsnKTtcbkxhdGV4Q21kcy5mcm93biA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxmcm93biAnLCAnJiM4OTk0OycpO1xuTGF0ZXhDbWRzLnZkYXNoID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHZkYXNoICcsICcmIzg4NzA7Jyk7XG5MYXRleENtZHMuZGFzaHYgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcZGFzaHYgJywgJyYjODg2NzsnKTtcbkxhdGV4Q21kcy5ubGVzcyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxubGVzcyAnLCAnJiM4ODE0OycpO1xuTGF0ZXhDbWRzLm5ndHIgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbmd0ciAnLCAnJiM4ODE1OycpO1xuXG4vL2Fycm93c1xuTGF0ZXhDbWRzLmxvbmdsZWZ0YXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbG9uZ2xlZnRhcnJvdyAnLCAnJiM4NTkyOycpO1xuTGF0ZXhDbWRzLmxvbmdyaWdodGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGxvbmdyaWdodGFycm93ICcsICcmIzg1OTQ7Jyk7XG5MYXRleENtZHMuTG9uZ2xlZnRhcnJvdyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxMb25nbGVmdGFycm93ICcsICcmIzg2NTY7Jyk7XG5MYXRleENtZHMuTG9uZ3JpZ2h0YXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcTG9uZ3JpZ2h0YXJyb3cgJywgJyYjODY1ODsnKTtcbkxhdGV4Q21kcy5sb25nbGVmdHJpZ2h0YXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbG9uZ2xlZnRyaWdodGFycm93ICcsICcmIzg1OTY7Jyk7XG5MYXRleENtZHMudXBkb3duYXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcdXBkb3duYXJyb3cgJywgJyYjODU5NzsnKTtcbkxhdGV4Q21kcy5Mb25nbGVmdHJpZ2h0YXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcTG9uZ2xlZnRyaWdodGFycm93ICcsICcmIzg2NjA7Jyk7XG5MYXRleENtZHMuVXBkb3duYXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcVXBkb3duYXJyb3cgJywgJyYjODY2MTsnKTtcbkxhdGV4Q21kcy5tYXBzdG8gPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbWFwc3RvICcsICcmIzg2MTQ7Jyk7XG5MYXRleENtZHMubmVhcnJvdyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxuZWFycm93ICcsICcmIzg1OTk7Jyk7XG5MYXRleENtZHMuaG9va2xlZnRhcnJvdyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxob29rbGVmdGFycm93ICcsICcmIzg2MTc7Jyk7XG5MYXRleENtZHMuaG9va3JpZ2h0YXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcaG9va3JpZ2h0YXJyb3cgJywgJyYjODYxODsnKTtcbkxhdGV4Q21kcy5zZWFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHNlYXJyb3cgJywgJyYjODYwMDsnKTtcbkxhdGV4Q21kcy5sZWZ0aGFycG9vbnVwID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGxlZnRoYXJwb29udXAgJywgJyYjODYzNjsnKTtcbkxhdGV4Q21kcy5yaWdodGhhcnBvb251cCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxyaWdodGhhcnBvb251cCAnLCAnJiM4NjQwOycpO1xuTGF0ZXhDbWRzLnN3YXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcc3dhcnJvdyAnLCAnJiM4NjAxOycpO1xuTGF0ZXhDbWRzLmxlZnRoYXJwb29uZG93biA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxsZWZ0aGFycG9vbmRvd24gJywgJyYjODYzNzsnKTtcbkxhdGV4Q21kcy5yaWdodGhhcnBvb25kb3duID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHJpZ2h0aGFycG9vbmRvd24gJywgJyYjODY0MTsnKTtcbkxhdGV4Q21kcy5ud2Fycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXG53YXJyb3cgJywgJyYjODU5ODsnKTtcblxuLy9NaXNjXG5MYXRleENtZHMubGRvdHMgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbGRvdHMgJywgJyYjODIzMDsnKTtcbkxhdGV4Q21kcy5jZG90cyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxjZG90cyAnLCAnJiM4OTQzOycpO1xuTGF0ZXhDbWRzLnZkb3RzID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHZkb3RzICcsICcmIzg5NDI7Jyk7XG5MYXRleENtZHMuZGRvdHMgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcZGRvdHMgJywgJyYjODk0NTsnKTtcbkxhdGV4Q21kcy5zdXJkID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHN1cmQgJywgJyYjODczMDsnKTtcbkxhdGV4Q21kcy50cmlhbmdsZSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFx0cmlhbmdsZSAnLCAnJiM5NjUxOycpO1xuTGF0ZXhDbWRzLmVsbCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxlbGwgJywgJyYjODQ2NzsnKTtcbkxhdGV4Q21kcy50b3AgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcdG9wICcsICcmIzg4Njg7Jyk7XG5MYXRleENtZHMuZmxhdCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxmbGF0ICcsICcmIzk4Mzc7Jyk7XG5MYXRleENtZHMubmF0dXJhbCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxuYXR1cmFsICcsICcmIzk4Mzg7Jyk7XG5MYXRleENtZHMuc2hhcnAgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcc2hhcnAgJywgJyYjOTgzOTsnKTtcbkxhdGV4Q21kcy53cCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFx3cCAnLCAnJiM4NDcyOycpO1xuTGF0ZXhDbWRzLmJvdCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxib3QgJywgJyYjODg2OTsnKTtcbkxhdGV4Q21kcy5jbHVic3VpdCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxjbHVic3VpdCAnLCAnJiM5ODI3OycpO1xuTGF0ZXhDbWRzLmRpYW1vbmRzdWl0ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGRpYW1vbmRzdWl0ICcsICcmIzk4MjY7Jyk7XG5MYXRleENtZHMuaGVhcnRzdWl0ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGhlYXJ0c3VpdCAnLCAnJiM5ODI1OycpO1xuTGF0ZXhDbWRzLnNwYWRlc3VpdCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzcGFkZXN1aXQgJywgJyYjOTgyNDsnKTtcbi8vbm90IHJlYWwgTGFUZXggY29tbWFuZCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hdGhxdWlsbC9tYXRocXVpbGwvcHVsbC81NTIgZm9yIG1vcmUgZGV0YWlsc1xuTGF0ZXhDbWRzLnBhcmFsbGVsb2dyYW0gPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxccGFyYWxsZWxvZ3JhbSAnLCAnJiM5NjQ5OycpO1xuTGF0ZXhDbWRzLnNxdWFyZSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzcXVhcmUgJywgJyYjMTEwMzY7Jyk7XG5cbi8vdmFyaWFibGUtc2l6ZWRcbkxhdGV4Q21kcy5vaW50ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXG9pbnQgJywgJyYjODc1MDsnKTtcbkxhdGV4Q21kcy5iaWdjYXAgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcYmlnY2FwICcsICcmIzg3NDU7Jyk7XG5MYXRleENtZHMuYmlnY3VwID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJpZ2N1cCAnLCAnJiM4NzQ2OycpO1xuTGF0ZXhDbWRzLmJpZ3NxY3VwID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJpZ3NxY3VwICcsICcmIzg4NTI7Jyk7XG5MYXRleENtZHMuYmlndmVlID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJpZ3ZlZSAnLCAnJiM4NzQ0OycpO1xuTGF0ZXhDbWRzLmJpZ3dlZGdlID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJpZ3dlZGdlICcsICcmIzg3NDM7Jyk7XG5MYXRleENtZHMuYmlnb2RvdCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxiaWdvZG90ICcsICcmIzg4NTc7Jyk7XG5MYXRleENtZHMuYmlnb3RpbWVzID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJpZ290aW1lcyAnLCAnJiM4ODU1OycpO1xuTGF0ZXhDbWRzLmJpZ29wbHVzID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJpZ29wbHVzICcsICcmIzg4NTM7Jyk7XG5MYXRleENtZHMuYmlndXBsdXMgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcYmlndXBsdXMgJywgJyYjODg0NjsnKTtcblxuLy9kZWxpbWl0ZXJzXG5MYXRleENtZHMubGZsb29yID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGxmbG9vciAnLCAnJiM4OTcwOycpO1xuTGF0ZXhDbWRzLnJmbG9vciA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxyZmxvb3IgJywgJyYjODk3MTsnKTtcbkxhdGV4Q21kcy5sY2VpbCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxsY2VpbCAnLCAnJiM4OTY4OycpO1xuTGF0ZXhDbWRzLnJjZWlsID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHJjZWlsICcsICcmIzg5Njk7Jyk7XG5MYXRleENtZHMub3BlbmN1cmx5YnJhY2UgPSBMYXRleENtZHMubGJyYWNlID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGxicmFjZSAnLCAneycpO1xuTGF0ZXhDbWRzLmNsb3NlY3VybHlicmFjZSA9IExhdGV4Q21kcy5yYnJhY2UgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxccmJyYWNlICcsICd9Jyk7XG5MYXRleENtZHMubGJyYWNrID0gYmluZChWYW5pbGxhU3ltYm9sLCAnWycpO1xuTGF0ZXhDbWRzLnJicmFjayA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ10nKTtcblxuLy92YXJpb3VzIHN5bWJvbHNcbkxhdGV4Q21kc1snXFx1MjIyYiddID1cbkxhdGV4Q21kc1snaW50J10gPVxuTGF0ZXhDbWRzLmludGVncmFsID0gYmluZChTeW1ib2wsJ1xcXFxpbnQgJywnPGJpZz4maW50OzwvYmlnPicpO1xuXG5MYXRleENtZHMuc2xhc2ggPSBiaW5kKFZhbmlsbGFTeW1ib2wsICcvJyk7XG5MYXRleENtZHMudmVydCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnfCcpO1xuTGF0ZXhDbWRzLnBlcnAgPSBMYXRleENtZHMucGVycGVuZGljdWxhciA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXHBlcnAgJywnJnBlcnA7Jyk7XG5MYXRleENtZHMubmFibGEgPSBMYXRleENtZHMuZGVsID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbmFibGEgJywnJm5hYmxhOycpO1xuTGF0ZXhDbWRzLmhiYXIgPSBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxoYmFyICcsJyYjODQ2MzsnKTtcblxuTGF0ZXhDbWRzLkFBID0gTGF0ZXhDbWRzLkFuZ3N0cm9tID0gTGF0ZXhDbWRzLmFuZ3N0cm9tID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcdGV4dFxcXFxBQSAnLCcmIzg0OTE7Jyk7XG5cbkxhdGV4Q21kcy5yaW5nID0gTGF0ZXhDbWRzLmNpcmMgPSBMYXRleENtZHMuY2lyY2xlID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcY2lyYyAnLCcmIzg3Mjg7Jyk7XG5cbkxhdGV4Q21kcy5idWxsID0gTGF0ZXhDbWRzLmJ1bGxldCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGJ1bGxldCAnLCcmYnVsbDsnKTtcblxuTGF0ZXhDbWRzLnNldG1pbnVzID0gTGF0ZXhDbWRzLnNtYWxsc2V0bWludXMgPVxuICBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxzZXRtaW51cyAnLCcmIzg3MjY7Jyk7XG5cbkxhdGV4Q21kcy5ub3QgPSAvL2JpbmQoU3ltYm9sLCdcXFxcbm90ICcsJzxzcGFuIGNsYXNzPVwibm90XCI+Lzwvc3Bhbj4nKTtcbkxhdGV4Q21kc1snXFx1MDBhYyddID0gTGF0ZXhDbWRzLm5lZyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXG5lZyAnLCcmbm90OycpO1xuXG5MYXRleENtZHNbJ1xcdTIwMjYnXSA9IExhdGV4Q21kcy5kb3RzID0gTGF0ZXhDbWRzLmVsbGlwID0gTGF0ZXhDbWRzLmhlbGxpcCA9XG5MYXRleENtZHMuZWxsaXBzaXMgPSBMYXRleENtZHMuaGVsbGlwc2lzID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcZG90cyAnLCcmaGVsbGlwOycpO1xuXG5MYXRleENtZHMuY29udmVyZ2VzID1cbkxhdGV4Q21kcy5kYXJyID0gTGF0ZXhDbWRzLmRuYXJyID0gTGF0ZXhDbWRzLmRuYXJyb3cgPSBMYXRleENtZHMuZG93bmFycm93ID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcZG93bmFycm93ICcsJyZkYXJyOycpO1xuXG5MYXRleENtZHMuZEFyciA9IExhdGV4Q21kcy5kbkFyciA9IExhdGV4Q21kcy5kbkFycm93ID0gTGF0ZXhDbWRzLkRvd25hcnJvdyA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXERvd25hcnJvdyAnLCcmZEFycjsnKTtcblxuTGF0ZXhDbWRzLmRpdmVyZ2VzID0gTGF0ZXhDbWRzLnVhcnIgPSBMYXRleENtZHMudXBhcnJvdyA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXHVwYXJyb3cgJywnJnVhcnI7Jyk7XG5cbkxhdGV4Q21kcy51QXJyID0gTGF0ZXhDbWRzLlVwYXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxVcGFycm93ICcsJyZ1QXJyOycpO1xuXG5MYXRleENtZHMudG8gPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcdG8gJywnJnJhcnI7Jyk7XG5cbkxhdGV4Q21kcy5yYXJyID0gTGF0ZXhDbWRzLnJpZ2h0YXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxyaWdodGFycm93ICcsJyZyYXJyOycpO1xuXG5MYXRleENtZHMuaW1wbGllcyA9IGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxSaWdodGFycm93ICcsJyZyQXJyOycpO1xuXG5MYXRleENtZHMuckFyciA9IExhdGV4Q21kcy5SaWdodGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcUmlnaHRhcnJvdyAnLCcmckFycjsnKTtcblxuTGF0ZXhDbWRzLmdldHMgPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcZ2V0cyAnLCcmbGFycjsnKTtcblxuTGF0ZXhDbWRzLmxhcnIgPSBMYXRleENtZHMubGVmdGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbGVmdGFycm93ICcsJyZsYXJyOycpO1xuXG5MYXRleENtZHMuaW1wbGllZGJ5ID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXExlZnRhcnJvdyAnLCcmbEFycjsnKTtcblxuTGF0ZXhDbWRzLmxBcnIgPSBMYXRleENtZHMuTGVmdGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcTGVmdGFycm93ICcsJyZsQXJyOycpO1xuXG5MYXRleENtZHMuaGFyciA9IExhdGV4Q21kcy5scmFyciA9IExhdGV4Q21kcy5sZWZ0cmlnaHRhcnJvdyA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGxlZnRyaWdodGFycm93ICcsJyZoYXJyOycpO1xuXG5MYXRleENtZHMuaWZmID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXExlZnRyaWdodGFycm93ICcsJyZoQXJyOycpO1xuXG5MYXRleENtZHMuaEFyciA9IExhdGV4Q21kcy5sckFyciA9IExhdGV4Q21kcy5MZWZ0cmlnaHRhcnJvdyA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXExlZnRyaWdodGFycm93ICcsJyZoQXJyOycpO1xuXG5MYXRleENtZHMuUmUgPSBMYXRleENtZHMuUmVhbCA9IExhdGV4Q21kcy5yZWFsID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcUmUgJywnJnJlYWw7Jyk7XG5cbkxhdGV4Q21kcy5JbSA9IExhdGV4Q21kcy5pbWFnID1cbkxhdGV4Q21kcy5pbWFnZSA9IExhdGV4Q21kcy5pbWFnaW4gPSBMYXRleENtZHMuaW1hZ2luYXJ5ID0gTGF0ZXhDbWRzLkltYWdpbmFyeSA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXEltICcsJyZpbWFnZTsnKTtcblxuTGF0ZXhDbWRzLnBhcnQgPSBMYXRleENtZHMucGFydGlhbCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXHBhcnRpYWwgJywnJnBhcnQ7Jyk7XG5cbkxhdGV4Q21kcy5pbmZ0eSA9IExhdGV4Q21kcy5pbmZpbiA9IExhdGV4Q21kcy5pbmZpbml0eSA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGluZnR5ICcsJyZpbmZpbjsnKTtcblxuTGF0ZXhDbWRzLmFsZWYgPSBMYXRleENtZHMuYWxlZnN5bSA9IExhdGV4Q21kcy5hbGVwaCA9IExhdGV4Q21kcy5hbGVwaHN5bSA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGFsZXBoICcsJyZhbGVmc3ltOycpO1xuXG5MYXRleENtZHMueGlzdCA9IC8vTE9MXG5MYXRleENtZHMueGlzdHMgPSBMYXRleENtZHMuZXhpc3QgPSBMYXRleENtZHMuZXhpc3RzID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcZXhpc3RzICcsJyZleGlzdDsnKTtcblxuTGF0ZXhDbWRzLmFuZCA9IExhdGV4Q21kcy5sYW5kID0gTGF0ZXhDbWRzLndlZGdlID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcd2VkZ2UgJywnJmFuZDsnKTtcblxuTGF0ZXhDbWRzLm9yID0gTGF0ZXhDbWRzLmxvciA9IExhdGV4Q21kcy52ZWUgPSBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFx2ZWUgJywnJm9yOycpO1xuXG5MYXRleENtZHMubyA9IExhdGV4Q21kcy5PID1cbkxhdGV4Q21kcy5lbXB0eSA9IExhdGV4Q21kcy5lbXB0eXNldCA9XG5MYXRleENtZHMub3NsYXNoID0gTGF0ZXhDbWRzLk9zbGFzaCA9XG5MYXRleENtZHMubm90aGluZyA9IExhdGV4Q21kcy52YXJub3RoaW5nID1cbiAgYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXHZhcm5vdGhpbmcgJywnJmVtcHR5OycpO1xuXG5MYXRleENtZHMuY3VwID0gTGF0ZXhDbWRzLnVuaW9uID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXGN1cCAnLCcmY3VwOycpO1xuXG5MYXRleENtZHMuY2FwID0gTGF0ZXhDbWRzLmludGVyc2VjdCA9IExhdGV4Q21kcy5pbnRlcnNlY3Rpb24gPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcY2FwICcsJyZjYXA7Jyk7XG5cbi8vIEZJWE1FOiB0aGUgY29ycmVjdCBMYVRlWCB3b3VsZCBiZSBeXFxjaXJjIGJ1dCB3ZSBjYW4ndCBwYXJzZSB0aGF0XG5MYXRleENtZHMuZGVnID0gTGF0ZXhDbWRzLmRlZ3JlZSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGRlZ3JlZSAnLCcmZGVnOycpO1xuXG5MYXRleENtZHMuYW5nID0gTGF0ZXhDbWRzLmFuZ2xlID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcYW5nbGUgJywnJmFuZzsnKTtcbkxhdGV4Q21kcy5tZWFzdXJlZGFuZ2xlID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbWVhc3VyZWRhbmdsZSAnLCcmIzg3Mzc7Jyk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBTeW1ib2xzIGZvciBCYXNpYyBNYXRoZW1hdGljc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgRGlnaXQgPSBQKFZhbmlsbGFTeW1ib2wsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIGlmIChjdXJzb3Iub3B0aW9ucy5hdXRvU3Vic2NyaXB0TnVtZXJhbHNcbiAgICAgICAgJiYgY3Vyc29yLnBhcmVudCAhPT0gY3Vyc29yLnBhcmVudC5wYXJlbnQuc3ViXG4gICAgICAgICYmICgoY3Vyc29yW0xdIGluc3RhbmNlb2YgVmFyaWFibGUgJiYgY3Vyc29yW0xdLmlzSXRhbGljICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHx8IChjdXJzb3JbTF0gaW5zdGFuY2VvZiBTdXBTdWJcbiAgICAgICAgICAgICAgICAmJiBjdXJzb3JbTF1bTF0gaW5zdGFuY2VvZiBWYXJpYWJsZVxuICAgICAgICAgICAgICAgICYmIGN1cnNvcltMXVtMXS5pc0l0YWxpYyAhPT0gZmFsc2UpKSkge1xuICAgICAgTGF0ZXhDbWRzLl8oKS5jcmVhdGVMZWZ0T2YoY3Vyc29yKTtcbiAgICAgIHN1cGVyXy5jcmVhdGVMZWZ0T2YuY2FsbCh0aGlzLCBjdXJzb3IpO1xuICAgICAgY3Vyc29yLmluc1JpZ2h0T2YoY3Vyc29yLnBhcmVudC5wYXJlbnQpO1xuICAgIH1cbiAgICBlbHNlIHN1cGVyXy5jcmVhdGVMZWZ0T2YuY2FsbCh0aGlzLCBjdXJzb3IpO1xuICB9O1xufSk7XG5cbnZhciBWYXJpYWJsZSA9IFAoU3ltYm9sLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24oY2gsIGh0bWwpIHtcbiAgICBzdXBlcl8uaW5pdC5jYWxsKHRoaXMsIGNoLCAnPHZhcj4nKyhodG1sIHx8IGNoKSsnPC92YXI+Jyk7XG4gIH07XG4gIF8udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXh0ID0gdGhpcy5jdHJsU2VxO1xuICAgIGlmICh0aGlzW0xdICYmICEodGhpc1tMXSBpbnN0YW5jZW9mIFZhcmlhYmxlKVxuICAgICAgICAmJiAhKHRoaXNbTF0gaW5zdGFuY2VvZiBCaW5hcnlPcGVyYXRvcilcbiAgICAgICAgJiYgdGhpc1tMXS5jdHJsU2VxICE9PSBcIlxcXFwgXCIpXG4gICAgICB0ZXh0ID0gJyonICsgdGV4dDtcbiAgICBpZiAodGhpc1tSXSAmJiAhKHRoaXNbUl0gaW5zdGFuY2VvZiBCaW5hcnlPcGVyYXRvcilcbiAgICAgICAgJiYgISh0aGlzW1JdIGluc3RhbmNlb2YgU3VwU3ViKSlcbiAgICAgIHRleHQgKz0gJyonO1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufSk7XG5cbk9wdGlvbnMucC5hdXRvQ29tbWFuZHMgPSB7IF9tYXhMZW5ndGg6IDAgfTtcbm9wdGlvblByb2Nlc3NvcnMuYXV0b0NvbW1hbmRzID0gZnVuY3Rpb24oY21kcykge1xuICBpZiAoIS9eW2Etel0rKD86IFthLXpdKykqJC9pLnRlc3QoY21kcykpIHtcbiAgICB0aHJvdyAnXCInK2NtZHMrJ1wiIG5vdCBhIHNwYWNlLWRlbGltaXRlZCBsaXN0IG9mIG9ubHkgbGV0dGVycyc7XG4gIH1cbiAgdmFyIGxpc3QgPSBjbWRzLnNwbGl0KCcgJyksIGRpY3QgPSB7fSwgbWF4TGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGNtZCA9IGxpc3RbaV07XG4gICAgaWYgKGNtZC5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyAnYXV0b2NvbW1hbmQgXCInK2NtZCsnXCIgbm90IG1pbmltdW0gbGVuZ3RoIG9mIDInO1xuICAgIH1cbiAgICBpZiAoTGF0ZXhDbWRzW2NtZF0gPT09IE9wZXJhdG9yTmFtZSkge1xuICAgICAgdGhyb3cgJ1wiJyArIGNtZCArICdcIiBpcyBhIGJ1aWx0LWluIG9wZXJhdG9yIG5hbWUnO1xuICAgIH1cbiAgICBkaWN0W2NtZF0gPSAxO1xuICAgIG1heExlbmd0aCA9IG1heChtYXhMZW5ndGgsIGNtZC5sZW5ndGgpO1xuICB9XG4gIGRpY3QuX21heExlbmd0aCA9IG1heExlbmd0aDtcbiAgcmV0dXJuIGRpY3Q7XG59O1xuXG52YXIgTGV0dGVyID0gUChWYXJpYWJsZSwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGNoKSB7IHJldHVybiBzdXBlcl8uaW5pdC5jYWxsKHRoaXMsIHRoaXMubGV0dGVyID0gY2gpOyB9O1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIHZhciBhdXRvQ21kcyA9IGN1cnNvci5vcHRpb25zLmF1dG9Db21tYW5kcywgbWF4TGVuZ3RoID0gYXV0b0NtZHMuX21heExlbmd0aDtcbiAgICBpZiAobWF4TGVuZ3RoID4gMCkge1xuICAgICAgLy8gd2FudCBsb25nZXN0IHBvc3NpYmxlIGF1dG9jb21tYW5kLCBzbyBqb2luIHRvZ2V0aGVyIGxvbmdlc3RcbiAgICAgIC8vIHNlcXVlbmNlIG9mIGxldHRlcnNcbiAgICAgIHZhciBzdHIgPSB0aGlzLmxldHRlciwgbCA9IGN1cnNvcltMXSwgaSA9IDE7XG4gICAgICB3aGlsZSAobCBpbnN0YW5jZW9mIExldHRlciAmJiBpIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHN0ciA9IGwubGV0dGVyICsgc3RyLCBsID0gbFtMXSwgaSArPSAxO1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgZm9yIGFuIGF1dG9jb21tYW5kLCBnb2luZyB0aHJ1IHN1YnN0cmluZ3MgbG9uZ2VzdCB0byBzaG9ydGVzdFxuICAgICAgd2hpbGUgKHN0ci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGF1dG9DbWRzLmhhc093blByb3BlcnR5KHN0cikpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMiwgbCA9IGN1cnNvcltMXTsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSwgbCA9IGxbTF0pO1xuICAgICAgICAgIEZyYWdtZW50KGwsIGN1cnNvcltMXSkucmVtb3ZlKCk7XG4gICAgICAgICAgY3Vyc29yW0xdID0gbFtMXTtcbiAgICAgICAgICByZXR1cm4gTGF0ZXhDbWRzW3N0cl0oc3RyKS5jcmVhdGVMZWZ0T2YoY3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyXy5jcmVhdGVMZWZ0T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgXy5pdGFsaWNpemUgPSBmdW5jdGlvbihib29sKSB7XG4gICAgdGhpcy5pc0l0YWxpYyA9IGJvb2w7XG4gICAgdGhpcy5qUS50b2dnbGVDbGFzcygnbXEtb3BlcmF0b3ItbmFtZScsICFib29sKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgXy5maW5hbGl6ZVRyZWUgPSBfLnNpYmxpbmdEZWxldGVkID0gXy5zaWJsaW5nQ3JlYXRlZCA9IGZ1bmN0aW9uKG9wdHMsIGRpcikge1xuICAgIC8vIGRvbid0IGF1dG8tdW4taXRhbGljaXplIGlmIHRoZSBzaWJsaW5nIHRvIG15IHJpZ2h0IGNoYW5nZWQgKGRpciA9PT0gUiBvclxuICAgIC8vIHVuZGVmaW5lZCkgYW5kIGl0J3Mgbm93IGEgTGV0dGVyLCBpdCB3aWxsIHVuLWl0YWxpY2l6ZSBldmVyeW9uZVxuICAgIGlmIChkaXIgIT09IEwgJiYgdGhpc1tSXSBpbnN0YW5jZW9mIExldHRlcikgcmV0dXJuO1xuICAgIHRoaXMuYXV0b1VuSXRhbGljaXplKG9wdHMpO1xuICB9O1xuICBfLmF1dG9Vbkl0YWxpY2l6ZSA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICB2YXIgYXV0b09wcyA9IG9wdHMuYXV0b09wZXJhdG9yTmFtZXM7XG4gICAgaWYgKGF1dG9PcHMuX21heExlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIC8vIHdhbnQgbG9uZ2VzdCBwb3NzaWJsZSBvcGVyYXRvciBuYW1lcywgc28gam9pbiB0b2dldGhlciBlbnRpcmUgY29udGlndW91c1xuICAgIC8vIHNlcXVlbmNlIG9mIGxldHRlcnNcbiAgICB2YXIgc3RyID0gdGhpcy5sZXR0ZXI7XG4gICAgZm9yICh2YXIgbCA9IHRoaXNbTF07IGwgaW5zdGFuY2VvZiBMZXR0ZXI7IGwgPSBsW0xdKSBzdHIgPSBsLmxldHRlciArIHN0cjtcbiAgICBmb3IgKHZhciByID0gdGhpc1tSXTsgciBpbnN0YW5jZW9mIExldHRlcjsgciA9IHJbUl0pIHN0ciArPSByLmxldHRlcjtcblxuICAgIC8vIHJlbW92ZUNsYXNzIGFuZCBkZWxldGUgZmxhZ3MgZnJvbSBhbGwgbGV0dGVycyBiZWZvcmUgZmlndXJpbmcgb3V0XG4gICAgLy8gd2hpY2gsIGlmIGFueSwgYXJlIHBhcnQgb2YgYW4gb3BlcmF0b3IgbmFtZVxuICAgIEZyYWdtZW50KGxbUl0gfHwgdGhpcy5wYXJlbnQuZW5kc1tMXSwgcltMXSB8fCB0aGlzLnBhcmVudC5lbmRzW1JdKS5lYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICBlbC5pdGFsaWNpemUodHJ1ZSkualEucmVtb3ZlQ2xhc3MoJ21xLWZpcnN0IG1xLWxhc3QnKTtcbiAgICAgIGVsLmN0cmxTZXEgPSBlbC5sZXR0ZXI7XG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmb3Igb3BlcmF0b3IgbmFtZXM6IGF0IGVhY2ggcG9zaXRpb24gZnJvbSBsZWZ0IHRvIHJpZ2h0LCBjaGVja1xuICAgIC8vIHN1YnN0cmluZ3MgZnJvbSBsb25nZXN0IHRvIHNob3J0ZXN0XG4gICAgb3V0ZXI6IGZvciAodmFyIGkgPSAwLCBmaXJzdCA9IGxbUl0gfHwgdGhpcy5wYXJlbnQuZW5kc1tMXTsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSwgZmlyc3QgPSBmaXJzdFtSXSkge1xuICAgICAgZm9yICh2YXIgbGVuID0gbWluKGF1dG9PcHMuX21heExlbmd0aCwgc3RyLmxlbmd0aCAtIGkpOyBsZW4gPiAwOyBsZW4gLT0gMSkge1xuICAgICAgICB2YXIgd29yZCA9IHN0ci5zbGljZShpLCBpICsgbGVuKTtcbiAgICAgICAgaWYgKGF1dG9PcHMuaGFzT3duUHJvcGVydHkod29yZCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGV0dGVyID0gZmlyc3Q7IGogPCBsZW47IGogKz0gMSwgbGV0dGVyID0gbGV0dGVyW1JdKSB7XG4gICAgICAgICAgICBsZXR0ZXIuaXRhbGljaXplKGZhbHNlKTtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gbGV0dGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0J1aWx0SW4gPSBCdWlsdEluT3BOYW1lcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKTtcbiAgICAgICAgICBmaXJzdC5jdHJsU2VxID0gKGlzQnVpbHRJbiA/ICdcXFxcJyA6ICdcXFxcb3BlcmF0b3JuYW1leycpICsgZmlyc3QuY3RybFNlcTtcbiAgICAgICAgICBsYXN0LmN0cmxTZXEgKz0gKGlzQnVpbHRJbiA/ICcgJyA6ICd9Jyk7XG4gICAgICAgICAgaWYgKFR3b1dvcmRPcE5hbWVzLmhhc093blByb3BlcnR5KHdvcmQpKSBsYXN0W0xdW0xdW0xdLmpRLmFkZENsYXNzKCdtcS1sYXN0Jyk7XG4gICAgICAgICAgaWYgKG5vbk9wZXJhdG9yU3ltYm9sKGZpcnN0W0xdKSkgZmlyc3QualEuYWRkQ2xhc3MoJ21xLWZpcnN0Jyk7XG4gICAgICAgICAgaWYgKG5vbk9wZXJhdG9yU3ltYm9sKGxhc3RbUl0pKSBsYXN0LmpRLmFkZENsYXNzKCdtcS1sYXN0Jyk7XG5cbiAgICAgICAgICBpICs9IGxlbiAtIDE7XG4gICAgICAgICAgZmlyc3QgPSBsYXN0O1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBub25PcGVyYXRvclN5bWJvbChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBTeW1ib2wgJiYgIShub2RlIGluc3RhbmNlb2YgQmluYXJ5T3BlcmF0b3IpO1xuICB9XG59KTtcbnZhciBCdWlsdEluT3BOYW1lcyA9IHt9OyAvLyB0aGUgc2V0IG9mIG9wZXJhdG9yIG5hbWVzIGxpa2UgXFxzaW4sIFxcY29zLCBldGMgdGhhdFxuICAvLyBhcmUgYnVpbHQtaW50byBMYVRlWDogaHR0cDovL2xhdGV4Lndpa2lhLmNvbS93aWtpL0xpc3Rfb2ZfTGFUZVhfc3ltYm9scyNOYW1lZF9vcGVyYXRvcnM6X3Npbi4yQ19jb3MuMkNfZXRjLlxuICAvLyBNYXRoUXVpbGwgYXV0by11bml0YWxpY2l6ZXMgc29tZSBvcGVyYXRvciBuYW1lcyBub3QgaW4gdGhhdCBzZXQsIGxpa2UgJ2hjZidcbiAgLy8gYW5kICdhcnNpbmgnLCB3aGljaCBtdXN0IGJlIGV4cG9ydGVkIGFzIFxcb3BlcmF0b3JuYW1le2hjZn0gYW5kXG4gIC8vIFxcb3BlcmF0b3JuYW1le2Fyc2luaH0uIE5vdGU6IG92ZXIvdW5kZXIgbGluZS9hcnJvdyBcXGxpbSB2YXJpYW50cyBsaWtlXG4gIC8vIFxcdmFybGltc3VwIGFyZSBub3Qgc3VwcG9ydGVkXG52YXIgQXV0b09wTmFtZXMgPSBPcHRpb25zLnAuYXV0b09wZXJhdG9yTmFtZXMgPSB7IF9tYXhMZW5ndGg6IDkgfTsgLy8gdGhlIHNldFxuICAvLyBvZiBvcGVyYXRvciBuYW1lcyB0aGF0IE1hdGhRdWlsbCBhdXRvLXVuaXRhbGljaXplcyBieSBkZWZhdWx0OyBvdmVycmlkYWJsZVxudmFyIFR3b1dvcmRPcE5hbWVzID0geyBsaW1zdXA6IDEsIGxpbWluZjogMSwgcHJvamxpbTogMSwgaW5qbGltOiAxIH07XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBtb3N0T3BzID0gKCdhcmcgZGVnIGRldCBkaW0gZXhwIGdjZCBob20gaW5mIGtlciBsZyBsaW0gbG4gbG9nIG1heCBtaW4gc3VwJ1xuICAgICAgICAgICAgICAgICArICcgbGltc3VwIGxpbWluZiBpbmpsaW0gcHJvamxpbSBQcicpLnNwbGl0KCcgJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbW9zdE9wcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIEJ1aWx0SW5PcE5hbWVzW21vc3RPcHNbaV1dID0gQXV0b09wTmFtZXNbbW9zdE9wc1tpXV0gPSAxO1xuICB9XG5cbiAgdmFyIGJ1aWx0SW5UcmlncyA9IC8vIHdoeSBjb3RoIGJ1dCBub3Qgc2VjaCBhbmQgY3NjaCwgTGFUZVg/XG4gICAgJ3NpbiBjb3MgdGFuIGFyY3NpbiBhcmNjb3MgYXJjdGFuIHNpbmggY29zaCB0YW5oIHNlYyBjc2MgY290IGNvdGgnLnNwbGl0KCcgJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVpbHRJblRyaWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgQnVpbHRJbk9wTmFtZXNbYnVpbHRJblRyaWdzW2ldXSA9IDE7XG4gIH1cblxuICB2YXIgYXV0b1RyaWdzID0gJ3NpbiBjb3MgdGFuIHNlYyBjb3NlYyBjc2MgY290YW4gY290IGN0Zycuc3BsaXQoJyAnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdXRvVHJpZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBBdXRvT3BOYW1lc1thdXRvVHJpZ3NbaV1dID1cbiAgICBBdXRvT3BOYW1lc1snYXJjJythdXRvVHJpZ3NbaV1dID1cbiAgICBBdXRvT3BOYW1lc1thdXRvVHJpZ3NbaV0rJ2gnXSA9XG4gICAgQXV0b09wTmFtZXNbJ2FyJythdXRvVHJpZ3NbaV0rJ2gnXSA9XG4gICAgQXV0b09wTmFtZXNbJ2FyYycrYXV0b1RyaWdzW2ldKydoJ10gPSAxO1xuICB9XG5cbiAgLy8gY29tcGF0IHdpdGggc29tZSBvZiB0aGUgbm9uc3RhbmRhcmQgTGFUZVggZXhwb3J0ZWQgYnkgTWF0aFF1aWxsXG4gIC8vIGJlZm9yZSAjMjQ3LiBOb25lIG9mIHRoZXNlIGFyZSByZWFsIExhVGVYIGNvbW1hbmRzIHNvLCBzZWVtcyBzYWZlXG4gIHZhciBtb3JlTm9uc3RhbmRhcmRPcHMgPSAnZ2NmIGhjZiBsY20gcHJvaiBzcGFuJy5zcGxpdCgnICcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1vcmVOb25zdGFuZGFyZE9wcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIEF1dG9PcE5hbWVzW21vcmVOb25zdGFuZGFyZE9wc1tpXV0gPSAxO1xuICB9XG59KCkpO1xub3B0aW9uUHJvY2Vzc29ycy5hdXRvT3BlcmF0b3JOYW1lcyA9IGZ1bmN0aW9uKGNtZHMpIHtcbiAgaWYgKCEvXlthLXpdKyg/OiBbYS16XSspKiQvaS50ZXN0KGNtZHMpKSB7XG4gICAgdGhyb3cgJ1wiJytjbWRzKydcIiBub3QgYSBzcGFjZS1kZWxpbWl0ZWQgbGlzdCBvZiBvbmx5IGxldHRlcnMnO1xuICB9XG4gIHZhciBsaXN0ID0gY21kcy5zcGxpdCgnICcpLCBkaWN0ID0ge30sIG1heExlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBjbWQgPSBsaXN0W2ldO1xuICAgIGlmIChjbWQubGVuZ3RoIDwgMikge1xuICAgICAgdGhyb3cgJ1wiJytjbWQrJ1wiIG5vdCBtaW5pbXVtIGxlbmd0aCBvZiAyJztcbiAgICB9XG4gICAgZGljdFtjbWRdID0gMTtcbiAgICBtYXhMZW5ndGggPSBtYXgobWF4TGVuZ3RoLCBjbWQubGVuZ3RoKTtcbiAgfVxuICBkaWN0Ll9tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4gIHJldHVybiBkaWN0O1xufTtcbnZhciBPcGVyYXRvck5hbWUgPSBQKFN5bWJvbCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGZuKSB7IHRoaXMuY3RybFNlcSA9IGZuOyB9O1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIHZhciBmbiA9IHRoaXMuY3RybFNlcTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBMZXR0ZXIoZm4uY2hhckF0KGkpKS5jcmVhdGVMZWZ0T2YoY3Vyc29yKTtcbiAgICB9XG4gIH07XG4gIF8ucGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZuID0gdGhpcy5jdHJsU2VxO1xuICAgIHZhciBibG9jayA9IE1hdGhCbG9jaygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIExldHRlcihmbi5jaGFyQXQoaSkpLmFkb3B0KGJsb2NrLCBibG9jay5lbmRzW1JdLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlci5zdWNjZWVkKGJsb2NrLmNoaWxkcmVuKCkpO1xuICB9O1xufSk7XG5mb3IgKHZhciBmbiBpbiBBdXRvT3BOYW1lcykgaWYgKEF1dG9PcE5hbWVzLmhhc093blByb3BlcnR5KGZuKSkge1xuICBMYXRleENtZHNbZm5dID0gT3BlcmF0b3JOYW1lO1xufVxuTGF0ZXhDbWRzLm9wZXJhdG9ybmFtZSA9IFAoTWF0aENvbW1hbmQsIGZ1bmN0aW9uKF8pIHtcbiAgXy5jcmVhdGVMZWZ0T2YgPSBub29wO1xuICBfLm51bUJsb2NrcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMTsgfTtcbiAgXy5wYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbGF0ZXhNYXRoUGFyc2VyLmJsb2NrLm1hcChmdW5jdGlvbihiKSB7IHJldHVybiBiLmNoaWxkcmVuKCk7IH0pO1xuICB9O1xufSk7XG5cbkxhdGV4Q21kcy5mID0gUChMZXR0ZXIsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBTeW1ib2wucC5pbml0LmNhbGwodGhpcywgdGhpcy5sZXR0ZXIgPSAnZicsICc8dmFyIGNsYXNzPVwibXEtZlwiPmY8L3Zhcj4nKTtcbiAgfTtcbiAgXy5pdGFsaWNpemUgPSBmdW5jdGlvbihib29sKSB7XG4gICAgdGhpcy5qUS5odG1sKCdmJykudG9nZ2xlQ2xhc3MoJ21xLWYnLCBib29sKTtcbiAgICByZXR1cm4gc3VwZXJfLml0YWxpY2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5cbi8vIFZhbmlsbGFTeW1ib2wnc1xuTGF0ZXhDbWRzWycgJ10gPSBMYXRleENtZHMuc3BhY2UgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcICcsICcmbmJzcDsnKTtcblxuTGF0ZXhDbWRzW1wiJ1wiXSA9IExhdGV4Q21kcy5wcmltZSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgXCInXCIsICcmcHJpbWU7Jyk7XG5cbkxhdGV4Q21kcy5iYWNrc2xhc2ggPSBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxiYWNrc2xhc2ggJywnXFxcXCcpO1xuaWYgKCFDaGFyQ21kc1snXFxcXCddKSBDaGFyQ21kc1snXFxcXCddID0gTGF0ZXhDbWRzLmJhY2tzbGFzaDtcblxuTGF0ZXhDbWRzLiQgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcJCcsICckJyk7XG5cbi8vIGRvZXMgbm90IHVzZSBTeW1ib2xhIGZvbnRcbnZhciBOb25TeW1ib2xhU3ltYm9sID0gUChTeW1ib2wsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihjaCwgaHRtbCkge1xuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcywgY2gsICc8c3BhbiBjbGFzcz1cIm1xLW5vblN5bWJvbGFcIj4nKyhodG1sIHx8IGNoKSsnPC9zcGFuPicpO1xuICB9O1xufSk7XG5cbkxhdGV4Q21kc1snQCddID0gTm9uU3ltYm9sYVN5bWJvbDtcbkxhdGV4Q21kc1snJiddID0gYmluZChOb25TeW1ib2xhU3ltYm9sLCAnXFxcXCYnLCAnJmFtcDsnKTtcbkxhdGV4Q21kc1snJSddID0gYmluZChOb25TeW1ib2xhU3ltYm9sLCAnXFxcXCUnLCAnJScpO1xuXG4vL3RoZSBmb2xsb3dpbmcgYXJlIGFsbCBHcmVlayB0byBtZSwgYnV0IHRoaXMgaGVscGVkIGEgbG90OiBodHRwOi8vd3d3LmFtcy5vcmcvU1RJWC9pb24vc3RpeHNpZzAzLmh0bWxcblxuLy9sb3dlcmNhc2UgR3JlZWsgbGV0dGVyIHZhcmlhYmxlc1xuTGF0ZXhDbWRzLmFscGhhID1cbkxhdGV4Q21kcy5iZXRhID1cbkxhdGV4Q21kcy5nYW1tYSA9XG5MYXRleENtZHMuZGVsdGEgPVxuTGF0ZXhDbWRzLnpldGEgPVxuTGF0ZXhDbWRzLmV0YSA9XG5MYXRleENtZHMudGhldGEgPVxuTGF0ZXhDbWRzLmlvdGEgPVxuTGF0ZXhDbWRzLmthcHBhID1cbkxhdGV4Q21kcy5tdSA9XG5MYXRleENtZHMubnUgPVxuTGF0ZXhDbWRzLnhpID1cbkxhdGV4Q21kcy5yaG8gPVxuTGF0ZXhDbWRzLnNpZ21hID1cbkxhdGV4Q21kcy50YXUgPVxuTGF0ZXhDbWRzLmNoaSA9XG5MYXRleENtZHMucHNpID1cbkxhdGV4Q21kcy5vbWVnYSA9IFAoVmFyaWFibGUsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihsYXRleCkge1xuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcywnXFxcXCcrbGF0ZXgrJyAnLCcmJytsYXRleCsnOycpO1xuICB9O1xufSk7XG5cbi8vd2h5IGNhbid0IGFueWJvZHkgRlVDS0lORyBhZ3JlZSBvbiB0aGVzZVxuTGF0ZXhDbWRzLnBoaSA9IC8vVzNDIG9yIFVuaWNvZGU/XG4gIGJpbmQoVmFyaWFibGUsJ1xcXFxwaGkgJywnJiM5ODE7Jyk7XG5cbkxhdGV4Q21kcy5waGl2ID0gLy9FbHNldmllciBhbmQgOTU3My0xM1xuTGF0ZXhDbWRzLnZhcnBoaSA9IC8vQU1TIGFuZCBMYVRlWFxuICBiaW5kKFZhcmlhYmxlLCdcXFxcdmFycGhpICcsJyZwaGk7Jyk7XG5cbkxhdGV4Q21kcy5lcHNpbG9uID0gLy9XM0Mgb3IgVW5pY29kZT9cbiAgYmluZChWYXJpYWJsZSwnXFxcXGVwc2lsb24gJywnJiMxMDEzOycpO1xuXG5MYXRleENtZHMuZXBzaXYgPSAvL0Vsc2V2aWVyIGFuZCA5NTczLTEzXG5MYXRleENtZHMudmFyZXBzaWxvbiA9IC8vQU1TIGFuZCBMYVRlWFxuICBiaW5kKFZhcmlhYmxlLCdcXFxcdmFyZXBzaWxvbiAnLCcmZXBzaWxvbjsnKTtcblxuTGF0ZXhDbWRzLnBpdiA9IC8vVzNDL1VuaWNvZGUgYW5kIEVsc2V2aWVyIGFuZCA5NTczLTEzXG5MYXRleENtZHMudmFycGkgPSAvL0FNUyBhbmQgTGFUZVhcbiAgYmluZChWYXJpYWJsZSwnXFxcXHZhcnBpICcsJyZwaXY7Jyk7XG5cbkxhdGV4Q21kcy5zaWdtYWYgPSAvL1czQy9Vbmljb2RlXG5MYXRleENtZHMuc2lnbWF2ID0gLy9FbHNldmllclxuTGF0ZXhDbWRzLnZhcnNpZ21hID0gLy9MYVRlWFxuICBiaW5kKFZhcmlhYmxlLCdcXFxcdmFyc2lnbWEgJywnJnNpZ21hZjsnKTtcblxuTGF0ZXhDbWRzLnRoZXRhdiA9IC8vRWxzZXZpZXIgYW5kIDk1NzMtMTNcbkxhdGV4Q21kcy52YXJ0aGV0YSA9IC8vQU1TIGFuZCBMYVRlWFxuTGF0ZXhDbWRzLnRoZXRhc3ltID0gLy9XM0MvVW5pY29kZVxuICBiaW5kKFZhcmlhYmxlLCdcXFxcdmFydGhldGEgJywnJnRoZXRhc3ltOycpO1xuXG5MYXRleENtZHMudXBzaWxvbiA9IC8vQU1TIGFuZCBMYVRlWCBhbmQgVzNDL1VuaWNvZGVcbkxhdGV4Q21kcy51cHNpID0gLy9FbHNldmllciBhbmQgOTU3My0xM1xuICBiaW5kKFZhcmlhYmxlLCdcXFxcdXBzaWxvbiAnLCcmdXBzaWxvbjsnKTtcblxuLy90aGVzZSBhcmVuJ3QgZXZlbiBtZW50aW9uZWQgaW4gdGhlIEhUTUwgY2hhcmFjdGVyIGVudGl0eSByZWZlcmVuY2VzXG5MYXRleENtZHMuZ2FtbWFkID0gLy9FbHNldmllclxuTGF0ZXhDbWRzLkdhbW1hZCA9IC8vOTU3My0xMyAtLSBXVEYsIHJpZ2h0PyBJIGR1bm5vIGlmIHRoaXMgd2FzIGEgdHlwbyBpbiB0aGUgcmVmZXJlbmNlIChzZWUgYWJvdmUpXG5MYXRleENtZHMuZGlnYW1tYSA9IC8vTGFUZVhcbiAgYmluZChWYXJpYWJsZSwnXFxcXGRpZ2FtbWEgJywnJiM5ODk7Jyk7XG5cbkxhdGV4Q21kcy5rYXBwYXYgPSAvL0Vsc2V2aWVyXG5MYXRleENtZHMudmFya2FwcGEgPSAvL0FNUyBhbmQgTGFUZVhcbiAgYmluZChWYXJpYWJsZSwnXFxcXHZhcmthcHBhICcsJyYjMTAwODsnKTtcblxuTGF0ZXhDbWRzLnJob3YgPSAvL0Vsc2V2aWVyIGFuZCA5NTczLTEzXG5MYXRleENtZHMudmFycmhvID0gLy9BTVMgYW5kIExhVGVYXG4gIGJpbmQoVmFyaWFibGUsJ1xcXFx2YXJyaG8gJywnJiMxMDA5OycpO1xuXG4vL0dyZWVrIGNvbnN0YW50cywgbG9vayBiZXN0IGluIG5vbi1pdGFsaWNpemVkIFRpbWVzIE5ldyBSb21hblxuTGF0ZXhDbWRzLnBpID0gTGF0ZXhDbWRzWydcXHUwM2MwJ10gPSBiaW5kKE5vblN5bWJvbGFTeW1ib2wsJ1xcXFxwaSAnLCcmcGk7Jyk7XG5MYXRleENtZHMubGFtYmRhID0gYmluZChOb25TeW1ib2xhU3ltYm9sLCdcXFxcbGFtYmRhICcsJyZsYW1iZGE7Jyk7XG5cbi8vdXBwZXJjYXNlIGdyZWVrIGxldHRlcnNcblxuTGF0ZXhDbWRzLlVwc2lsb24gPSAvL0xhVGVYXG5MYXRleENtZHMuVXBzaSA9IC8vRWxzZXZpZXIgYW5kIDk1NzMtMTNcbkxhdGV4Q21kcy51cHNpaCA9IC8vVzNDL1VuaWNvZGUgXCJ1cHNpbG9uIHdpdGggaG9va1wiXG5MYXRleENtZHMuVXBzaWggPSAvLydjb3MgaXQgbWFrZXMgc2Vuc2UgdG8gbWVcbiAgYmluZChTeW1ib2wsJ1xcXFxVcHNpbG9uICcsJzx2YXIgc3R5bGU9XCJmb250LWZhbWlseTogc2VyaWZcIj4mdXBzaWg7PC92YXI+Jyk7IC8vU3ltYm9sYSdzICd1cHNpbG9uIHdpdGggYSBob29rJyBpcyBhIGNhcGl0YWwgWSB3aXRob3V0IGhvb2tzIDooXG5cbi8vb3RoZXIgc3ltYm9scyB3aXRoIHRoZSBzYW1lIExhVGVYIGNvbW1hbmQgYW5kIEhUTUwgY2hhcmFjdGVyIGVudGl0eSByZWZlcmVuY2VcbkxhdGV4Q21kcy5HYW1tYSA9XG5MYXRleENtZHMuRGVsdGEgPVxuTGF0ZXhDbWRzLlRoZXRhID1cbkxhdGV4Q21kcy5MYW1iZGEgPVxuTGF0ZXhDbWRzLlhpID1cbkxhdGV4Q21kcy5QaSA9XG5MYXRleENtZHMuU2lnbWEgPVxuTGF0ZXhDbWRzLlBoaSA9XG5MYXRleENtZHMuUHNpID1cbkxhdGV4Q21kcy5PbWVnYSA9XG5MYXRleENtZHMuZm9yYWxsID0gUChWYW5pbGxhU3ltYm9sLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24obGF0ZXgpIHtcbiAgICBzdXBlcl8uaW5pdC5jYWxsKHRoaXMsJ1xcXFwnK2xhdGV4KycgJywnJicrbGF0ZXgrJzsnKTtcbiAgfTtcbn0pO1xuXG4vLyBzeW1ib2xzIHRoYXQgYXJlbid0IGEgc2luZ2xlIE1hdGhDb21tYW5kLCBidXQgYXJlIGluc3RlYWQgYSB3aG9sZVxuLy8gRnJhZ21lbnQuIENyZWF0ZXMgdGhlIEZyYWdtZW50IGZyb20gYSBMYVRlWCBzdHJpbmdcbnZhciBMYXRleEZyYWdtZW50ID0gUChNYXRoQ29tbWFuZCwgZnVuY3Rpb24oXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihsYXRleCkgeyB0aGlzLmxhdGV4ID0gbGF0ZXg7IH07XG4gIF8uY3JlYXRlTGVmdE9mID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgdmFyIGJsb2NrID0gbGF0ZXhNYXRoUGFyc2VyLnBhcnNlKHRoaXMubGF0ZXgpO1xuICAgIGJsb2NrLmNoaWxkcmVuKCkuYWRvcHQoY3Vyc29yLnBhcmVudCwgY3Vyc29yW0xdLCBjdXJzb3JbUl0pO1xuICAgIGN1cnNvcltMXSA9IGJsb2NrLmVuZHNbUl07XG4gICAgYmxvY2sualFpemUoKS5pbnNlcnRCZWZvcmUoY3Vyc29yLmpRKTtcbiAgICBibG9jay5maW5hbGl6ZUluc2VydChjdXJzb3Iub3B0aW9ucywgY3Vyc29yKTtcbiAgICBpZiAoYmxvY2suZW5kc1tSXVtSXS5zaWJsaW5nQ3JlYXRlZCkgYmxvY2suZW5kc1tSXVtSXS5zaWJsaW5nQ3JlYXRlZChjdXJzb3Iub3B0aW9ucywgTCk7XG4gICAgaWYgKGJsb2NrLmVuZHNbTF1bTF0uc2libGluZ0NyZWF0ZWQpIGJsb2NrLmVuZHNbTF1bTF0uc2libGluZ0NyZWF0ZWQoY3Vyc29yLm9wdGlvbnMsIFIpO1xuICAgIGN1cnNvci5wYXJlbnQuYnViYmxlKCdyZWZsb3cnKTtcbiAgfTtcbiAgXy5wYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnJhZyA9IGxhdGV4TWF0aFBhcnNlci5wYXJzZSh0aGlzLmxhdGV4KS5jaGlsZHJlbigpO1xuICAgIHJldHVybiBQYXJzZXIuc3VjY2VlZChmcmFnKTtcbiAgfTtcbn0pO1xuXG4vLyBmb3Igd2hhdCBzZWVtcyB0byBtZSBsaWtlIFtzdHVwaWQgcmVhc29uc11bMV0sIFVuaWNvZGUgcHJvdmlkZXNcbi8vIHN1YnNjcmlwdGVkIGFuZCBzdXBlcnNjcmlwdGVkIHZlcnNpb25zIG9mIGFsbCB0ZW4gQXJhYmljIG51bWVyYWxzLFxuLy8gYXMgd2VsbCBhcyBbc28tY2FsbGVkIFwidnVsZ2FyIGZyYWN0aW9uc1wiXVsyXS5cbi8vIE5vYm9keSByZWFsbHkgY2FyZXMgYWJvdXQgbW9zdCBvZiB0aGVtLCBidXQgc29tZSBvZiB0aGVtIGFjdHVhbGx5XG4vLyBwcmVkYXRlIFVuaWNvZGUsIGRhdGluZyBiYWNrIHRvIFtJU08tODg1OS0xXVszXSwgYXBwYXJlbnRseSBhbHNvXG4vLyBrbm93biBhcyBcIkxhdGluLTFcIiwgd2hpY2ggYW1vbmcgb3RoZXIgdGhpbmdzIFtXaW5kb3dzLTEyNTJdWzRdXG4vLyBsYXJnZWx5IGNvaW5jaWRlcyB3aXRoLCBzbyBNaWNyb3NvZnQgV29yZCBzb21ldGltZXMgaW5zZXJ0cyB0aGVtXG4vLyBhbmQgdGhleSBnZXQgY29weS1wYXN0ZWQgaW50byBNYXRoUXVpbGwuXG4vL1xuLy8gKElycmVsZXZhbnQgYnV0IGZ1bm55IHN0b3J5OiB0aG91Z2ggbm90IGEgc3VwZXJzZXQgb2YgTGF0aW4tMSBha2Fcbi8vIElTTy04ODU5LTEsIFdpbmRvd3MtMTI1MiAqKmlzKiogYSBzdHJpY3Qgc3VwZXJzZXQgb2YgdGhlIFwiY2xvc2VseVxuLy8gcmVsYXRlZCBidXQgZGlzdGluY3RcIlszXSBcIklTTyA4ODU5LTFcIiAtLSBzZWUgdGhlIGxhY2sgb2YgYSBkYXNoXG4vLyBhZnRlciBcIklTT1wiPyBDb21wbGV0ZWx5IGRpZmZlcmVudCBjaGFyYWN0ZXIgc2V0LCBsaWtlIGVsZXBoYW50cyB2c1xuLy8gZWxlcGhhbnQgc2VhbHMsIG9yIFwiWm9tYmllc1wiIHZzIFwiWm9tYmllIFJlZG5lY2sgVG9ydHVyZSBGYW1pbHlcIi5cbi8vIFdoYXQga2luZCBvZiBpZGlvdCB3b3VsZCBnZXQgdGhlbSBjb25mdXNlZC5cbi8vIFBlb3BsZSBpbiBmYWN0IGdvdCB0aGVtIGNvbmZ1c2VkIHNvIG11Y2gsIGl0IHdhcyBzbyBjb21tb24gdG9cbi8vIG1pc2xhYmVsIFdpbmRvd3MtMTI1MiB0ZXh0IGFzIElTTy04ODU5LTEsIHRoYXQgbW9zdCBtb2Rlcm4gd2ViXG4vLyBicm93c2VycyBhbmQgZW1haWwgY2xpZW50cyB0cmVhdCB0aGUgTUlNRSBjaGFyc2V0IG9mIElTTy04ODU5LTFcbi8vIGFzIGFjdHVhbGx5IFdpbmRvd3MtMTI1MiwgYmVoYXZpb3Igbm93IHN0YW5kYXJkIGluIHRoZSBIVE1MNSBzcGVjLilcbi8vXG4vLyBbMV06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pY29kZV9zdWJzY3JpcHRzX2FuZHN1cGVyX3NjcmlwdHNcbi8vIFsyXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OdW1iZXJfRm9ybXNcbi8vIFszXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU08vSUVDXzg4NTktMVxuLy8gWzRdOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dpbmRvd3MtMTI1MlxuTGF0ZXhDbWRzWydcXHUwMGI5J10gPSBiaW5kKExhdGV4RnJhZ21lbnQsICdeMScpO1xuTGF0ZXhDbWRzWydcXHUwMGIyJ10gPSBiaW5kKExhdGV4RnJhZ21lbnQsICdeMicpO1xuTGF0ZXhDbWRzWydcXHUwMGIzJ10gPSBiaW5kKExhdGV4RnJhZ21lbnQsICdeMycpO1xuTGF0ZXhDbWRzWydcXHUwMGJjJ10gPSBiaW5kKExhdGV4RnJhZ21lbnQsICdcXFxcZnJhYzE0Jyk7XG5MYXRleENtZHNbJ1xcdTAwYmQnXSA9IGJpbmQoTGF0ZXhGcmFnbWVudCwgJ1xcXFxmcmFjMTInKTtcbkxhdGV4Q21kc1snXFx1MDBiZSddID0gYmluZChMYXRleEZyYWdtZW50LCAnXFxcXGZyYWMzNCcpO1xuXG52YXIgUGx1c01pbnVzID0gUChCaW5hcnlPcGVyYXRvciwgZnVuY3Rpb24oXykge1xuICBfLmluaXQgPSBWYW5pbGxhU3ltYm9sLnByb3RvdHlwZS5pbml0O1xuXG4gIF8uY29udGFjdFdlbGQgPSBfLnNpYmxpbmdDcmVhdGVkID0gXy5zaWJsaW5nRGVsZXRlZCA9IGZ1bmN0aW9uKG9wdHMsIGRpcikge1xuICAgIGlmIChkaXIgPT09IFIpIHJldHVybjsgLy8gaWdub3JlIGlmIHNpYmxpbmcgb25seSBjaGFuZ2VkIG9uIHRoZSByaWdodFxuICAgIHRoaXMualFbMF0uY2xhc3NOYW1lID1cbiAgICAgICghdGhpc1tMXSB8fCB0aGlzW0xdIGluc3RhbmNlb2YgQmluYXJ5T3BlcmF0b3IgPyAnJyA6ICdtcS1iaW5hcnktb3BlcmF0b3InKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG5MYXRleENtZHNbJysnXSA9IGJpbmQoUGx1c01pbnVzLCAnKycsICcrJyk7XG4vL3llcywgdGhlc2UgYXJlIGRpZmZlcmVudCBkYXNoZXMsIEkgdGhpbmsgb25lIGlzIGFuIGVuIGRhc2ggYW5kIHRoZSBvdGhlciBpcyBhIGh5cGhlblxuTGF0ZXhDbWRzWydcXHUyMDEzJ10gPSBMYXRleENtZHNbJy0nXSA9IGJpbmQoUGx1c01pbnVzLCAnLScsICcmbWludXM7Jyk7XG5MYXRleENtZHNbJ1xcdTAwYjEnXSA9IExhdGV4Q21kcy5wbSA9IExhdGV4Q21kcy5wbHVzbW4gPSBMYXRleENtZHMucGx1c21pbnVzID1cbiAgYmluZChQbHVzTWludXMsJ1xcXFxwbSAnLCcmcGx1c21uOycpO1xuTGF0ZXhDbWRzLm1wID0gTGF0ZXhDbWRzLm1ucGx1cyA9IExhdGV4Q21kcy5taW51c3BsdXMgPVxuICBiaW5kKFBsdXNNaW51cywnXFxcXG1wICcsJyYjODcyMzsnKTtcblxuQ2hhckNtZHNbJyonXSA9IExhdGV4Q21kcy5zZG90ID0gTGF0ZXhDbWRzLmNkb3QgPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCAnXFxcXGNkb3QgJywgJyZtaWRkb3Q7JywgJyonKTtcbi8vc2VtYW50aWNhbGx5IHNob3VsZCBiZSAmc2RvdDssIGJ1dCAmbWlkZG90OyBsb29rcyBiZXR0ZXJcblxudmFyIEluZXF1YWxpdHkgPSBQKEJpbmFyeU9wZXJhdG9yLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24oZGF0YSwgc3RyaWN0KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnN0cmljdCA9IHN0cmljdDtcbiAgICB2YXIgc3RyaWN0bmVzcyA9IChzdHJpY3QgPyAnU3RyaWN0JyA6ICcnKTtcbiAgICBzdXBlcl8uaW5pdC5jYWxsKHRoaXMsIGRhdGFbJ2N0cmxTZXEnK3N0cmljdG5lc3NdLCBkYXRhWydodG1sJytzdHJpY3RuZXNzXSxcbiAgICAgICAgICAgICAgICAgICAgIGRhdGFbJ3RleHQnK3N0cmljdG5lc3NdKTtcbiAgfTtcbiAgXy5zd2FwID0gZnVuY3Rpb24oc3RyaWN0KSB7XG4gICAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG4gICAgdmFyIHN0cmljdG5lc3MgPSAoc3RyaWN0ID8gJ1N0cmljdCcgOiAnJyk7XG4gICAgdGhpcy5jdHJsU2VxID0gdGhpcy5kYXRhWydjdHJsU2VxJytzdHJpY3RuZXNzXTtcbiAgICB0aGlzLmpRLmh0bWwodGhpcy5kYXRhWydodG1sJytzdHJpY3RuZXNzXSk7XG4gICAgdGhpcy50ZXh0VGVtcGxhdGUgPSBbIHRoaXMuZGF0YVsndGV4dCcrc3RyaWN0bmVzc10gXTtcbiAgfTtcbiAgXy5kZWxldGVUb3dhcmRzID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBpZiAoZGlyID09PSBMICYmICF0aGlzLnN0cmljdCkge1xuICAgICAgdGhpcy5zd2FwKHRydWUpO1xuICAgICAgdGhpcy5idWJibGUoJ3JlZmxvdycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlcl8uZGVsZXRlVG93YXJkcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5cbnZhciBsZXNzID0geyBjdHJsU2VxOiAnXFxcXGxlICcsIGh0bWw6ICcmbGU7JywgdGV4dDogJ1xcdTIyNjQnLFxuICAgICAgICAgICAgIGN0cmxTZXFTdHJpY3Q6ICc8JywgaHRtbFN0cmljdDogJyZsdDsnLCB0ZXh0U3RyaWN0OiAnPCcgfTtcbnZhciBncmVhdGVyID0geyBjdHJsU2VxOiAnXFxcXGdlICcsIGh0bWw6ICcmZ2U7JywgdGV4dDogJ1xcdTIyNjUnLFxuICAgICAgICAgICAgICAgIGN0cmxTZXFTdHJpY3Q6ICc+JywgaHRtbFN0cmljdDogJyZndDsnLCB0ZXh0U3RyaWN0OiAnPicgfTtcblxuTGF0ZXhDbWRzWyc8J10gPSBMYXRleENtZHMubHQgPSBiaW5kKEluZXF1YWxpdHksIGxlc3MsIHRydWUpO1xuTGF0ZXhDbWRzWyc+J10gPSBMYXRleENtZHMuZ3QgPSBiaW5kKEluZXF1YWxpdHksIGdyZWF0ZXIsIHRydWUpO1xuTGF0ZXhDbWRzWydcXHUyMjY0J10gPSBMYXRleENtZHMubGUgPSBMYXRleENtZHMubGVxID0gYmluZChJbmVxdWFsaXR5LCBsZXNzLCBmYWxzZSk7XG5MYXRleENtZHNbJ1xcdTIyNjUnXSA9IExhdGV4Q21kcy5nZSA9IExhdGV4Q21kcy5nZXEgPSBiaW5kKEluZXF1YWxpdHksIGdyZWF0ZXIsIGZhbHNlKTtcblxudmFyIEVxdWFsaXR5ID0gUChCaW5hcnlPcGVyYXRvciwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcywgJz0nLCAnPScpO1xuICB9O1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIGlmIChjdXJzb3JbTF0gaW5zdGFuY2VvZiBJbmVxdWFsaXR5ICYmIGN1cnNvcltMXS5zdHJpY3QpIHtcbiAgICAgIGN1cnNvcltMXS5zd2FwKGZhbHNlKTtcbiAgICAgIGN1cnNvcltMXS5idWJibGUoJ3JlZmxvdycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlcl8uY3JlYXRlTGVmdE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KTtcbkxhdGV4Q21kc1snPSddID0gRXF1YWxpdHk7XG5cbkxhdGV4Q21kc1snXFx1MDBkNyddID0gTGF0ZXhDbWRzLnRpbWVzID0gYmluZChCaW5hcnlPcGVyYXRvciwgJ1xcXFx0aW1lcyAnLCAnJnRpbWVzOycsICdbeF0nKTtcblxuTGF0ZXhDbWRzWydcXHUwMGY3J10gPSBMYXRleENtZHMuZGl2ID0gTGF0ZXhDbWRzLmRpdmlkZSA9IExhdGV4Q21kcy5kaXZpZGVzID1cbiAgYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXGRpdiAnLCcmZGl2aWRlOycsICdbL10nKTtcblxuQ2hhckNtZHNbJ34nXSA9IExhdGV4Q21kcy5zaW0gPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCAnXFxcXHNpbSAnLCAnficsICd+Jyk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb21tYW5kcyBhbmQgT3BlcmF0b3JzLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgc2NhbGUsIC8vID0gZnVuY3Rpb24oalEsIHgsIHkpIHsgLi4uIH1cbi8vd2lsbCB1c2UgYSBDU1MgMkQgdHJhbnNmb3JtIHRvIHNjYWxlIHRoZSBqUXVlcnktd3JhcHBlZCBIVE1MIGVsZW1lbnRzLFxuLy9vciB0aGUgZmlsdGVyIG1hdHJpeCB0cmFuc2Zvcm0gZmFsbGJhY2sgZm9yIElFIDUuNS04LCBvciBncmFjZWZ1bGx5IGRlZ3JhZGUgdG9cbi8vaW5jcmVhc2luZyB0aGUgZm9udFNpemUgdG8gbWF0Y2ggdGhlIHZlcnRpY2FsIFkgc2NhbGluZyBmYWN0b3IuXG5cbi8vaWRlYXMgZnJvbSBodHRwOi8vZ2l0aHViLmNvbS9sb3Vpc3JlbWkvanF1ZXJ5LnRyYW5zZm9ybS5qc1xuLy9zZWUgYWxzbyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzMwMTQodj12cy44NSkuYXNweFxuXG4gIGZvcmNlSUVSZWRyYXcgPSBub29wLFxuICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgZGl2X3N0eWxlID0gZGl2LnN0eWxlLFxuICB0cmFuc2Zvcm1Qcm9wTmFtZXMgPSB7XG4gICAgdHJhbnNmb3JtOjEsXG4gICAgV2Via2l0VHJhbnNmb3JtOjEsXG4gICAgTW96VHJhbnNmb3JtOjEsXG4gICAgT1RyYW5zZm9ybToxLFxuICAgIG1zVHJhbnNmb3JtOjFcbiAgfSxcbiAgdHJhbnNmb3JtUHJvcE5hbWU7XG5cbmZvciAodmFyIHByb3AgaW4gdHJhbnNmb3JtUHJvcE5hbWVzKSB7XG4gIGlmIChwcm9wIGluIGRpdl9zdHlsZSkge1xuICAgIHRyYW5zZm9ybVByb3BOYW1lID0gcHJvcDtcbiAgICBicmVhaztcbiAgfVxufVxuXG5pZiAodHJhbnNmb3JtUHJvcE5hbWUpIHtcbiAgc2NhbGUgPSBmdW5jdGlvbihqUSwgeCwgeSkge1xuICAgIGpRLmNzcyh0cmFuc2Zvcm1Qcm9wTmFtZSwgJ3NjYWxlKCcreCsnLCcreSsnKScpO1xuICB9O1xufVxuZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZGl2X3N0eWxlKSB7IC8vSUUgNiwgNywgJiA4IGZhbGxiYWNrLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2xhdWdoaW5naGFuL21hdGhxdWlsbC93aWtpL1RyYW5zZm9ybXNcbiAgZm9yY2VJRVJlZHJhdyA9IGZ1bmN0aW9uKGVsKXsgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lOyB9O1xuICBzY2FsZSA9IGZ1bmN0aW9uKGpRLCB4LCB5KSB7IC8vTk9URTogYXNzdW1lcyB5ID4geFxuICAgIHggLz0gKDErKHktMSkvMik7XG4gICAgalEuY3NzKCdmb250U2l6ZScsIHkgKyAnZW0nKTtcbiAgICBpZiAoIWpRLmhhc0NsYXNzKCdtcS1tYXRyaXhlZC1jb250YWluZXInKSkge1xuICAgICAgalEuYWRkQ2xhc3MoJ21xLW1hdHJpeGVkLWNvbnRhaW5lcicpXG4gICAgICAud3JhcElubmVyKCc8c3BhbiBjbGFzcz1cIm1xLW1hdHJpeGVkXCI+PC9zcGFuPicpO1xuICAgIH1cbiAgICB2YXIgaW5uZXJqUSA9IGpRLmNoaWxkcmVuKClcbiAgICAuY3NzKCdmaWx0ZXInLCAncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0J1xuICAgICAgICArICcuTWF0cml4KE0xMT0nICsgeCArIFwiLFNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKVwiXG4gICAgKTtcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVNYXJnaW5SaWdodCgpIHtcbiAgICAgIGpRLmNzcygnbWFyZ2luUmlnaHQnLCAoaW5uZXJqUS53aWR0aCgpLTEpKih4LTEpL3ggKyAncHgnKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlTWFyZ2luUmlnaHQoKTtcbiAgICB2YXIgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGNhbGN1bGF0ZU1hcmdpblJpZ2h0KTtcbiAgICAkKHdpbmRvdykubG9hZChmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnRlcnZhbElkKTtcbiAgICAgIGNhbGN1bGF0ZU1hcmdpblJpZ2h0KCk7XG4gICAgfSk7XG4gIH07XG59XG5lbHNlIHtcbiAgc2NhbGUgPSBmdW5jdGlvbihqUSwgeCwgeSkge1xuICAgIGpRLmNzcygnZm9udFNpemUnLCB5ICsgJ2VtJyk7XG4gIH07XG59XG5cbnZhciBTdHlsZSA9IFAoTWF0aENvbW1hbmQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihjdHJsU2VxLCB0YWdOYW1lLCBhdHRycykge1xuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcywgY3RybFNlcSwgJzwnK3RhZ05hbWUrJyAnK2F0dHJzKyc+JjA8LycrdGFnTmFtZSsnPicpO1xuICB9O1xufSk7XG5cbi8vZm9udHNcbkxhdGV4Q21kcy5tYXRocm0gPSBiaW5kKFN0eWxlLCAnXFxcXG1hdGhybScsICdzcGFuJywgJ2NsYXNzPVwibXEtcm9tYW4gbXEtZm9udFwiJyk7XG5MYXRleENtZHMubWF0aGl0ID0gYmluZChTdHlsZSwgJ1xcXFxtYXRoaXQnLCAnaScsICdjbGFzcz1cIm1xLWZvbnRcIicpO1xuTGF0ZXhDbWRzLm1hdGhiZiA9IGJpbmQoU3R5bGUsICdcXFxcbWF0aGJmJywgJ2InLCAnY2xhc3M9XCJtcS1mb250XCInKTtcbkxhdGV4Q21kcy5tYXRoc2YgPSBiaW5kKFN0eWxlLCAnXFxcXG1hdGhzZicsICdzcGFuJywgJ2NsYXNzPVwibXEtc2Fucy1zZXJpZiBtcS1mb250XCInKTtcbkxhdGV4Q21kcy5tYXRodHQgPSBiaW5kKFN0eWxlLCAnXFxcXG1hdGh0dCcsICdzcGFuJywgJ2NsYXNzPVwibXEtbW9ub3NwYWNlIG1xLWZvbnRcIicpO1xuLy90ZXh0LWRlY29yYXRpb25cbkxhdGV4Q21kcy51bmRlcmxpbmUgPSBiaW5kKFN0eWxlLCAnXFxcXHVuZGVybGluZScsICdzcGFuJywgJ2NsYXNzPVwibXEtbm9uLWxlYWYgbXEtdW5kZXJsaW5lXCInKTtcbkxhdGV4Q21kcy5vdmVybGluZSA9IExhdGV4Q21kcy5iYXIgPSBiaW5kKFN0eWxlLCAnXFxcXG92ZXJsaW5lJywgJ3NwYW4nLCAnY2xhc3M9XCJtcS1ub24tbGVhZiBtcS1vdmVybGluZVwiJyk7XG5MYXRleENtZHMub3ZlcnJpZ2h0YXJyb3cgPSBiaW5kKFN0eWxlLCAnXFxcXG92ZXJyaWdodGFycm93JywgJ3NwYW4nLCAnY2xhc3M9XCJtcS1ub24tbGVhZiBtcS1vdmVyYXJyb3cgbXEtYXJyb3ctcmlnaHRcIicpO1xuTGF0ZXhDbWRzLm92ZXJsZWZ0YXJyb3cgPSBiaW5kKFN0eWxlLCAnXFxcXG92ZXJsZWZ0YXJyb3cnLCAnc3BhbicsICdjbGFzcz1cIm1xLW5vbi1sZWFmIG1xLW92ZXJhcnJvdyBtcS1hcnJvdy1sZWZ0XCInKTtcblxuLy8gYFxcdGV4dGNvbG9ye2NvbG9yfXttYXRofWAgd2lsbCBhcHBseSBhIGNvbG9yIHRvIHRoZSBnaXZlbiBtYXRoIGNvbnRlbnQsIHdoZXJlXG4vLyBgY29sb3JgIGlzIGFueSB2YWxpZCBDU1MgQ29sb3IgVmFsdWUgKHNlZSBbU2l0ZVBvaW50IGRvY3NdW10gKHJlY29tbWVuZGVkKSxcbi8vIFtNb3ppbGxhIGRvY3NdW10sIG9yIFtXM0Mgc3BlY11bXSkuXG4vL1xuLy8gW1NpdGVQb2ludCBkb2NzXTogaHR0cDovL3JlZmVyZW5jZS5zaXRlcG9pbnQuY29tL2Nzcy9jb2xvcnZhbHVlc1xuLy8gW01vemlsbGEgZG9jc106IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2NvbG9yX3ZhbHVlI1ZhbHVlc1xuLy8gW1czQyBzcGVjXTogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzMy1jb2xvci8jY29sb3J1bml0c1xudmFyIFRleHRDb2xvciA9IExhdGV4Q21kcy50ZXh0Y29sb3IgPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5zZXRDb2xvciA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuaHRtbFRlbXBsYXRlID1cbiAgICAgICc8c3BhbiBjbGFzcz1cIm1xLXRleHRjb2xvclwiIHN0eWxlPVwiY29sb3I6JyArIGNvbG9yICsgJ1wiPiYwPC9zcGFuPic7XG4gIH07XG4gIF8ubGF0ZXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ1xcXFx0ZXh0Y29sb3J7JyArIHRoaXMuY29sb3IgKyAnfXsnICsgdGhpcy5ibG9ja3NbMF0ubGF0ZXgoKSArICd9JztcbiAgfTtcbiAgXy5wYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG9wdFdoaXRlc3BhY2UgPSBQYXJzZXIub3B0V2hpdGVzcGFjZTtcbiAgICB2YXIgc3RyaW5nID0gUGFyc2VyLnN0cmluZztcbiAgICB2YXIgcmVnZXggPSBQYXJzZXIucmVnZXg7XG5cbiAgICByZXR1cm4gb3B0V2hpdGVzcGFjZVxuICAgICAgLnRoZW4oc3RyaW5nKCd7JykpXG4gICAgICAudGhlbihyZWdleCgvXlsjXFx3XFxzLiwoKSUtXSovKSlcbiAgICAgIC5za2lwKHN0cmluZygnfScpKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgc2VsZi5zZXRDb2xvcihjb2xvcik7XG4gICAgICAgIHJldHVybiBzdXBlcl8ucGFyc2VyLmNhbGwoc2VsZik7XG4gICAgICB9KVxuICAgIDtcbiAgfTtcbn0pO1xuXG4vLyBWZXJ5IHNpbWlsYXIgdG8gdGhlIFxcdGV4dGNvbG9yIGNvbW1hbmQsIGJ1dCB3aWxsIGFkZCB0aGUgZ2l2ZW4gQ1NTIGNsYXNzLlxuLy8gVXNhZ2U6IFxcY2xhc3N7Y2xhc3NuYW1lfXttYXRofVxuLy8gTm90ZSByZWdleCB0aGF0IHdoaXRlbGlzdHMgdmFsaWQgQ1NTIGNsYXNzbmFtZSBjaGFyYWN0ZXJzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhxdWlsbC9tYXRocXVpbGwvcHVsbC8xOTEjZGlzY3Vzc2lvbl9yNDMyNzQ0MlxudmFyIENsYXNzID0gTGF0ZXhDbWRzWydjbGFzcyddID0gUChNYXRoQ29tbWFuZCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8ucGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBzdHJpbmcgPSBQYXJzZXIuc3RyaW5nLCByZWdleCA9IFBhcnNlci5yZWdleDtcbiAgICByZXR1cm4gUGFyc2VyLm9wdFdoaXRlc3BhY2VcbiAgICAgIC50aGVuKHN0cmluZygneycpKVxuICAgICAgLnRoZW4ocmVnZXgoL15bLVxcd1xcc1xcXFxcXHhBMC1cXHhGRl0qLykpXG4gICAgICAuc2tpcChzdHJpbmcoJ30nKSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKGNscykge1xuICAgICAgICBzZWxmLmh0bWxUZW1wbGF0ZSA9ICc8c3BhbiBjbGFzcz1cIm1xLWNsYXNzICcrY2xzKydcIj4mMDwvc3Bhbj4nO1xuICAgICAgICByZXR1cm4gc3VwZXJfLnBhcnNlci5jYWxsKHNlbGYpO1xuICAgICAgfSlcbiAgICA7XG4gIH07XG59KTtcblxudmFyIFN1cFN1YiA9IFAoTWF0aENvbW1hbmQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmN0cmxTZXEgPSAnX3suLi59XnsuLi59JztcbiAgXy5jcmVhdGVMZWZ0T2YgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICBpZiAoIWN1cnNvcltMXSAmJiBjdXJzb3Iub3B0aW9ucy5zdXBTdWJzUmVxdWlyZU9wZXJhbmQpIHJldHVybjtcbiAgICByZXR1cm4gc3VwZXJfLmNyZWF0ZUxlZnRPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBfLmNvbnRhY3RXZWxkID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgLy8gTG9vayBvbiBlaXRoZXIgc2lkZSBmb3IgYSBTdXBTdWIsIGlmIG9uZSBpcyBmb3VuZCBjb21wYXJlIG15XG4gICAgLy8gLnN1YiwgLnN1cCB3aXRoIGl0cyAuc3ViLCAuc3VwLiBJZiBJIGhhdmUgb25lIHRoYXQgaXQgZG9lc24ndCxcbiAgICAvLyB0aGVuIGNhbGwgLmFkZEJsb2NrKCkgb24gaXQgd2l0aCBteSBibG9jazsgaWYgSSBoYXZlIG9uZSB0aGF0XG4gICAgLy8gaXQgYWxzbyBoYXMsIHRoZW4gaW5zZXJ0IG15IGJsb2NrJ3MgY2hpbGRyZW4gaW50byBpdHMgYmxvY2ssXG4gICAgLy8gdW5sZXNzIG15IGJsb2NrIGhhcyBub25lLCBpbiB3aGljaCBjYXNlIGluc2VydCB0aGUgY3Vyc29yIGludG9cbiAgICAvLyBpdHMgYmxvY2sgKGFuZCBub3QgbWluZSwgSSdtIGFib3V0IHRvIHJlbW92ZSBteXNlbGYpIGluIHRoZSBjYXNlXG4gICAgLy8gSSB3YXMganVzdCB0eXBlZC5cbiAgICAvLyBUT0RPOiBzaW1wbGlmeVxuXG4gICAgLy8gZXF1aXYuIHRvIFtMLCBSXS5mb3JFYWNoKGZ1bmN0aW9uKGRpcikgeyAuLi4gfSk7XG4gICAgZm9yICh2YXIgZGlyID0gTDsgZGlyOyBkaXIgPSAoZGlyID09PSBMID8gUiA6IGZhbHNlKSkge1xuICAgICAgaWYgKHRoaXNbZGlyXSBpbnN0YW5jZW9mIFN1cFN1Yikge1xuICAgICAgICAvLyBlcXVpdi4gdG8gJ3N1YiBzdXAnLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihzdXBzdWIpIHsgLi4uIH0pO1xuICAgICAgICBmb3IgKHZhciBzdXBzdWIgPSAnc3ViJzsgc3Vwc3ViOyBzdXBzdWIgPSAoc3Vwc3ViID09PSAnc3ViJyA/ICdzdXAnIDogZmFsc2UpKSB7XG4gICAgICAgICAgdmFyIHNyYyA9IHRoaXNbc3Vwc3ViXSwgZGVzdCA9IHRoaXNbZGlyXVtzdXBzdWJdO1xuICAgICAgICAgIGlmICghc3JjKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAoIWRlc3QpIHRoaXNbZGlyXS5hZGRCbG9jayhzcmMuZGlzb3duKCkpO1xuICAgICAgICAgIGVsc2UgaWYgKCFzcmMuaXNFbXB0eSgpKSB7IC8vIGlucyBzcmMgY2hpbGRyZW4gYXQgLWRpciBlbmQgb2YgZGVzdFxuICAgICAgICAgICAgc3JjLmpRLmNoaWxkcmVuKCkuaW5zQXREaXJFbmQoLWRpciwgZGVzdC5qUSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBzcmMuY2hpbGRyZW4oKS5kaXNvd24oKTtcbiAgICAgICAgICAgIHZhciBwdCA9IFBvaW50KGRlc3QsIGNoaWxkcmVuLmVuZHNbUl0sIGRlc3QuZW5kc1tMXSk7XG4gICAgICAgICAgICBpZiAoZGlyID09PSBMKSBjaGlsZHJlbi5hZG9wdChkZXN0LCBkZXN0LmVuZHNbUl0sIDApO1xuICAgICAgICAgICAgZWxzZSBjaGlsZHJlbi5hZG9wdChkZXN0LCAwLCBkZXN0LmVuZHNbTF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHZhciBwdCA9IFBvaW50KGRlc3QsIDAsIGRlc3QuZW5kc1tMXSk7XG4gICAgICAgICAgdGhpcy5wbGFjZUN1cnNvciA9IChmdW5jdGlvbihkZXN0LCBzcmMpIHsgLy8gVE9ETzogZG9uJ3QgbW9ua2V5LXBhdGNoXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY3Vyc29yKSB7IGN1cnNvci5pbnNBdERpckVuZCgtZGlyLCBkZXN0IHx8IHNyYyk7IH07XG4gICAgICAgICAgfShkZXN0LCBzcmMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICBpZiAoY3Vyc29yICYmIGN1cnNvcltMXSA9PT0gdGhpcykge1xuICAgICAgICAgIGlmIChkaXIgPT09IFIgJiYgcHQpIHtcbiAgICAgICAgICAgIHB0W0xdID8gY3Vyc29yLmluc1JpZ2h0T2YocHRbTF0pIDogY3Vyc29yLmluc0F0TGVmdEVuZChwdC5wYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGN1cnNvci5pbnNSaWdodE9mKHRoaXNbZGlyXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVzcGFjZSgpO1xuICB9O1xuICBPcHRpb25zLnAuY2hhcnNUaGF0QnJlYWtPdXRPZlN1cFN1YiA9ICcnO1xuICBfLmZpbmFsaXplVHJlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZW5kc1tMXS53cml0ZSA9IGZ1bmN0aW9uKGN1cnNvciwgY2gpIHtcbiAgICAgIGlmIChjdXJzb3Iub3B0aW9ucy5hdXRvU3Vic2NyaXB0TnVtZXJhbHMgJiYgdGhpcyA9PT0gdGhpcy5wYXJlbnQuc3ViKSB7XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSByZXR1cm47XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLmNoVG9DbWQoY2gpO1xuICAgICAgICBpZiAoY21kIGluc3RhbmNlb2YgU3ltYm9sKSBjdXJzb3IuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIGVsc2UgY3Vyc29yLmNsZWFyU2VsZWN0aW9uKCkuaW5zUmlnaHRPZih0aGlzLnBhcmVudCk7XG4gICAgICAgIHJldHVybiBjbWQuY3JlYXRlTGVmdE9mKGN1cnNvci5zaG93KCkpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnNvcltMXSAmJiAhY3Vyc29yW1JdICYmICFjdXJzb3Iuc2VsZWN0aW9uXG4gICAgICAgICAgJiYgY3Vyc29yLm9wdGlvbnMuY2hhcnNUaGF0QnJlYWtPdXRPZlN1cFN1Yi5pbmRleE9mKGNoKSA+IC0xKSB7XG4gICAgICAgIGN1cnNvci5pbnNSaWdodE9mKHRoaXMucGFyZW50KTtcbiAgICAgIH1cbiAgICAgIE1hdGhCbG9jay5wLndyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcbiAgXy5tb3ZlVG93YXJkcyA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yLCB1cGRvd24pIHtcbiAgICBpZiAoY3Vyc29yLm9wdGlvbnMuYXV0b1N1YnNjcmlwdE51bWVyYWxzICYmICF0aGlzLnN1cCkge1xuICAgICAgY3Vyc29yLmluc0Rpck9mKGRpciwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2Ugc3VwZXJfLm1vdmVUb3dhcmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIF8uZGVsZXRlVG93YXJkcyA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgaWYgKGN1cnNvci5vcHRpb25zLmF1dG9TdWJzY3JpcHROdW1lcmFscyAmJiB0aGlzLnN1Yikge1xuICAgICAgdmFyIGNtZCA9IHRoaXMuc3ViLmVuZHNbLWRpcl07XG4gICAgICBpZiAoY21kIGluc3RhbmNlb2YgU3ltYm9sKSBjbWQucmVtb3ZlKCk7XG4gICAgICBlbHNlIGlmIChjbWQpIGNtZC5kZWxldGVUb3dhcmRzKGRpciwgY3Vyc29yLmluc0F0RGlyRW5kKC1kaXIsIHRoaXMuc3ViKSk7XG5cbiAgICAgIC8vIFRPRE86IGZhY3RvciBvdXQgYSAucmVtb3ZlQmxvY2soKSBvciBzb21ldGhpbmdcbiAgICAgIGlmICh0aGlzLnN1Yi5pc0VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5zdWIuZGVsZXRlT3V0T2YoTCwgY3Vyc29yLmluc0F0TGVmdEVuZCh0aGlzLnN1YikpO1xuICAgICAgICBpZiAodGhpcy5zdXApIGN1cnNvci5pbnNEaXJPZigtZGlyLCB0aGlzKTtcbiAgICAgICAgLy8gTm90ZSBgLWRpcmAgYmVjYXVzZSBpbiBlLmcuIHhfMV4yfCB3YW50IGJhY2tzcGFjaW5nIChsZWZ0d2FyZClcbiAgICAgICAgLy8gdG8gZGVsZXRlIHRoZSAxIGJ1dCB0byBlbmQgdXAgcmlnaHR3YXJkIG9mIHheMjsgd2l0aCBub24tbmVnYXRlZFxuICAgICAgICAvLyBgZGlyYCAodHJ5IGl0KSwgdGhlIGN1cnNvciBhcHBlYXJzIHRvIGhhdmUgZ29uZSBcInRocm91Z2hcIiB0aGUgXjIuXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Ugc3VwZXJfLmRlbGV0ZVRvd2FyZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgXy5sYXRleCA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGxhdGV4KHByZWZpeCwgYmxvY2spIHtcbiAgICAgIHZhciBsID0gYmxvY2sgJiYgYmxvY2subGF0ZXgoKTtcbiAgICAgIHJldHVybiBibG9jayA/IHByZWZpeCArIChsLmxlbmd0aCA9PT0gMSA/IGwgOiAneycgKyAobCB8fCAnICcpICsgJ30nKSA6ICcnO1xuICAgIH1cbiAgICByZXR1cm4gbGF0ZXgoJ18nLCB0aGlzLnN1YikgKyBsYXRleCgnXicsIHRoaXMuc3VwKTtcbiAgfTtcbiAgXy5yZXNwYWNlID0gXy5zaWJsaW5nQ3JlYXRlZCA9IF8uc2libGluZ0RlbGV0ZWQgPSBmdW5jdGlvbihvcHRzLCBkaXIpIHtcbiAgICBpZiAoZGlyID09PSBSKSByZXR1cm47IC8vIGlnbm9yZSBpZiBzaWJsaW5nIG9ubHkgY2hhbmdlZCBvbiB0aGUgcmlnaHRcbiAgICB0aGlzLmpRLnRvZ2dsZUNsYXNzKCdtcS1saW1pdCcsIHRoaXNbTF0uY3RybFNlcSA9PT0gJ1xcXFxpbnQgJyk7XG4gIH07XG4gIF8uYWRkQmxvY2sgPSBmdW5jdGlvbihibG9jaykge1xuICAgIGlmICh0aGlzLnN1cHN1YiA9PT0gJ3N1YicpIHtcbiAgICAgIHRoaXMuc3VwID0gdGhpcy51cEludG8gPSB0aGlzLnN1Yi51cE91dE9mID0gYmxvY2s7XG4gICAgICBibG9jay5hZG9wdCh0aGlzLCB0aGlzLnN1YiwgMCkuZG93bk91dE9mID0gdGhpcy5zdWI7XG4gICAgICBibG9jay5qUSA9ICQoJzxzcGFuIGNsYXNzPVwibXEtc3VwXCIvPicpLmFwcGVuZChibG9jay5qUS5jaGlsZHJlbigpKVxuICAgICAgICAuYXR0cihtcUJsb2NrSWQsIGJsb2NrLmlkKS5wcmVwZW5kVG8odGhpcy5qUSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zdWIgPSB0aGlzLmRvd25JbnRvID0gdGhpcy5zdXAuZG93bk91dE9mID0gYmxvY2s7XG4gICAgICBibG9jay5hZG9wdCh0aGlzLCAwLCB0aGlzLnN1cCkudXBPdXRPZiA9IHRoaXMuc3VwO1xuICAgICAgYmxvY2sualEgPSAkKCc8c3BhbiBjbGFzcz1cIm1xLXN1YlwiPjwvc3Bhbj4nKS5hcHBlbmQoYmxvY2sualEuY2hpbGRyZW4oKSlcbiAgICAgICAgLmF0dHIobXFCbG9ja0lkLCBibG9jay5pZCkuYXBwZW5kVG8odGhpcy5qUS5yZW1vdmVDbGFzcygnbXEtc3VwLW9ubHknKSk7XG4gICAgICB0aGlzLmpRLmFwcGVuZCgnPHNwYW4gc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDowXCI+JiM4MjAzOzwvc3Bhbj4nKTtcbiAgICB9XG4gICAgLy8gbGlrZSAnc3ViIHN1cCcuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKHN1cHN1YikgeyAuLi4gfSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpICs9IDEpIChmdW5jdGlvbihjbWQsIHN1cHN1Yiwgb3Bwb3NpdGVTdXBzdWIsIHVwZG93bikge1xuICAgICAgY21kW3N1cHN1Yl0uZGVsZXRlT3V0T2YgPSBmdW5jdGlvbihkaXIsIGN1cnNvcikge1xuICAgICAgICBjdXJzb3IuaW5zRGlyT2YoKHRoaXNbZGlyXSA/IC1kaXIgOiBkaXIpLCB0aGlzLnBhcmVudCk7XG4gICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmRzW2Rpcl07XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbigpLmRpc293bigpXG4gICAgICAgICAgICAud2l0aERpckFkb3B0KGRpciwgY3Vyc29yLnBhcmVudCwgY3Vyc29yW2Rpcl0sIGN1cnNvclstZGlyXSlcbiAgICAgICAgICAgIC5qUS5pbnNEaXJPZigtZGlyLCBjdXJzb3IualEpO1xuICAgICAgICAgIGN1cnNvclstZGlyXSA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjbWQuc3Vwc3ViID0gb3Bwb3NpdGVTdXBzdWI7XG4gICAgICAgIGRlbGV0ZSBjbWRbc3Vwc3ViXTtcbiAgICAgICAgZGVsZXRlIGNtZFt1cGRvd24rJ0ludG8nXTtcbiAgICAgICAgY21kW29wcG9zaXRlU3Vwc3ViXVt1cGRvd24rJ091dE9mJ10gPSBpbnNMZWZ0T2ZNZVVubGVzc0F0RW5kO1xuICAgICAgICBkZWxldGUgY21kW29wcG9zaXRlU3Vwc3ViXS5kZWxldGVPdXRPZjtcbiAgICAgICAgaWYgKHN1cHN1YiA9PT0gJ3N1YicpICQoY21kLmpRLmFkZENsYXNzKCdtcS1zdXAtb25seScpWzBdLmxhc3RDaGlsZCkucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9O1xuICAgIH0odGhpcywgJ3N1YiBzdXAnLnNwbGl0KCcgJylbaV0sICdzdXAgc3ViJy5zcGxpdCgnICcpW2ldLCAnZG93biB1cCcuc3BsaXQoJyAnKVtpXSkpO1xuICB9O1xufSk7XG5cbmZ1bmN0aW9uIGluc0xlZnRPZk1lVW5sZXNzQXRFbmQoY3Vyc29yKSB7XG4gIC8vIGN1cnNvci5pbnNMZWZ0T2YoY21kKSwgdW5sZXNzIGN1cnNvciBhdCB0aGUgZW5kIG9mIGJsb2NrLCBhbmQgZXZlcnlcbiAgLy8gYW5jZXN0b3IgY21kIGlzIGF0IHRoZSBlbmQgb2YgZXZlcnkgYW5jZXN0b3IgYmxvY2tcbiAgdmFyIGNtZCA9IHRoaXMucGFyZW50LCBhbmNlc3RvckNtZCA9IGN1cnNvcjtcbiAgZG8ge1xuICAgIGlmIChhbmNlc3RvckNtZFtSXSkgcmV0dXJuIGN1cnNvci5pbnNMZWZ0T2YoY21kKTtcbiAgICBhbmNlc3RvckNtZCA9IGFuY2VzdG9yQ21kLnBhcmVudC5wYXJlbnQ7XG4gIH0gd2hpbGUgKGFuY2VzdG9yQ21kICE9PSBjbWQpO1xuICBjdXJzb3IuaW5zUmlnaHRPZihjbWQpO1xufVxuXG5MYXRleENtZHMuc3Vic2NyaXB0ID1cbkxhdGV4Q21kcy5fID0gUChTdXBTdWIsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLnN1cHN1YiA9ICdzdWInO1xuICBfLmh0bWxUZW1wbGF0ZSA9XG4gICAgICAnPHNwYW4gY2xhc3M9XCJtcS1zdXBzdWIgbXEtbm9uLWxlYWZcIj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLXN1YlwiPiYwPC9zcGFuPidcbiAgICArICAgJzxzcGFuIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MFwiPiYjODIwMzs8L3NwYW4+J1xuICAgICsgJzwvc3Bhbj4nXG4gIDtcbiAgXy50ZXh0VGVtcGxhdGUgPSBbICdfJyBdO1xuICBfLmZpbmFsaXplVHJlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZG93bkludG8gPSB0aGlzLnN1YiA9IHRoaXMuZW5kc1tMXTtcbiAgICB0aGlzLnN1Yi51cE91dE9mID0gaW5zTGVmdE9mTWVVbmxlc3NBdEVuZDtcbiAgICBzdXBlcl8uZmluYWxpemVUcmVlLmNhbGwodGhpcyk7XG4gIH07XG59KTtcblxuTGF0ZXhDbWRzLnN1cGVyc2NyaXB0ID1cbkxhdGV4Q21kcy5zdXBzY3JpcHQgPVxuTGF0ZXhDbWRzWydeJ10gPSBQKFN1cFN1YiwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uc3Vwc3ViID0gJ3N1cCc7XG4gIF8uaHRtbFRlbXBsYXRlID1cbiAgICAgICc8c3BhbiBjbGFzcz1cIm1xLXN1cHN1YiBtcS1ub24tbGVhZiBtcS1zdXAtb25seVwiPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtc3VwXCI+JjA8L3NwYW4+J1xuICAgICsgJzwvc3Bhbj4nXG4gIDtcbiAgXy50ZXh0VGVtcGxhdGUgPSBbICdeJyBdO1xuICBfLmZpbmFsaXplVHJlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudXBJbnRvID0gdGhpcy5zdXAgPSB0aGlzLmVuZHNbUl07XG4gICAgdGhpcy5zdXAuZG93bk91dE9mID0gaW5zTGVmdE9mTWVVbmxlc3NBdEVuZDtcbiAgICBzdXBlcl8uZmluYWxpemVUcmVlLmNhbGwodGhpcyk7XG4gIH07XG59KTtcblxudmFyIFN1bW1hdGlvbk5vdGF0aW9uID0gUChNYXRoQ29tbWFuZCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGNoLCBodG1sKSB7XG4gICAgdmFyIGh0bWxUZW1wbGF0ZSA9XG4gICAgICAnPHNwYW4gY2xhc3M9XCJtcS1sYXJnZS1vcGVyYXRvciBtcS1ub24tbGVhZlwiPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtdG9cIj48c3Bhbj4mMTwvc3Bhbj48L3NwYW4+J1xuICAgICsgICAnPGJpZz4nK2h0bWwrJzwvYmlnPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtZnJvbVwiPjxzcGFuPiYwPC9zcGFuPjwvc3Bhbj4nXG4gICAgKyAnPC9zcGFuPidcbiAgICA7XG4gICAgU3ltYm9sLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgY2gsIGh0bWxUZW1wbGF0ZSk7XG4gIH07XG4gIF8uY3JlYXRlTGVmdE9mID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgc3VwZXJfLmNyZWF0ZUxlZnRPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChjdXJzb3Iub3B0aW9ucy5zdW1TdGFydHNXaXRoTkVxdWFscykge1xuICAgICAgTGV0dGVyKCduJykuY3JlYXRlTGVmdE9mKGN1cnNvcik7XG4gICAgICBFcXVhbGl0eSgpLmNyZWF0ZUxlZnRPZihjdXJzb3IpO1xuICAgIH1cbiAgfTtcbiAgXy5sYXRleCA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHNpbXBsaWZ5KGxhdGV4KSB7XG4gICAgICByZXR1cm4gbGF0ZXgubGVuZ3RoID09PSAxID8gbGF0ZXggOiAneycgKyAobGF0ZXggfHwgJyAnKSArICd9JztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3RybFNlcSArICdfJyArIHNpbXBsaWZ5KHRoaXMuZW5kc1tMXS5sYXRleCgpKSArXG4gICAgICAnXicgKyBzaW1wbGlmeSh0aGlzLmVuZHNbUl0ubGF0ZXgoKSk7XG4gIH07XG4gIF8ucGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZyA9IFBhcnNlci5zdHJpbmc7XG4gICAgdmFyIG9wdFdoaXRlc3BhY2UgPSBQYXJzZXIub3B0V2hpdGVzcGFjZTtcbiAgICB2YXIgc3VjY2VlZCA9IFBhcnNlci5zdWNjZWVkO1xuICAgIHZhciBibG9jayA9IGxhdGV4TWF0aFBhcnNlci5ibG9jaztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYmxvY2tzID0gc2VsZi5ibG9ja3MgPSBbIE1hdGhCbG9jaygpLCBNYXRoQmxvY2soKSBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBibG9ja3NbaV0uYWRvcHQoc2VsZiwgc2VsZi5lbmRzW1JdLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0V2hpdGVzcGFjZS50aGVuKHN0cmluZygnXycpLm9yKHN0cmluZygnXicpKSkudGhlbihmdW5jdGlvbihzdXBPclN1Yikge1xuICAgICAgdmFyIGNoaWxkID0gYmxvY2tzW3N1cE9yU3ViID09PSAnXycgPyAwIDogMV07XG4gICAgICByZXR1cm4gYmxvY2sudGhlbihmdW5jdGlvbihibG9jaykge1xuICAgICAgICBibG9jay5jaGlsZHJlbigpLmFkb3B0KGNoaWxkLCBjaGlsZC5lbmRzW1JdLCAwKTtcbiAgICAgICAgcmV0dXJuIHN1Y2NlZWQoc2VsZik7XG4gICAgICB9KTtcbiAgICB9KS5tYW55KCkucmVzdWx0KHNlbGYpO1xuICB9O1xuICBfLmZpbmFsaXplVHJlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZG93bkludG8gPSB0aGlzLmVuZHNbTF07XG4gICAgdGhpcy51cEludG8gPSB0aGlzLmVuZHNbUl07XG4gICAgdGhpcy5lbmRzW0xdLnVwT3V0T2YgPSB0aGlzLmVuZHNbUl07XG4gICAgdGhpcy5lbmRzW1JdLmRvd25PdXRPZiA9IHRoaXMuZW5kc1tMXTtcbiAgfTtcbn0pO1xuXG5MYXRleENtZHNbJ1xcdTIyMTEnXSA9XG5MYXRleENtZHMuc3VtID1cbkxhdGV4Q21kcy5zdW1tYXRpb24gPSBiaW5kKFN1bW1hdGlvbk5vdGF0aW9uLCdcXFxcc3VtICcsJyZzdW07Jyk7XG5cbkxhdGV4Q21kc1snXFx1MjIwZiddID1cbkxhdGV4Q21kcy5wcm9kID1cbkxhdGV4Q21kcy5wcm9kdWN0ID0gYmluZChTdW1tYXRpb25Ob3RhdGlvbiwnXFxcXHByb2QgJywnJnByb2Q7Jyk7XG5cbkxhdGV4Q21kcy5jb3Byb2QgPVxuTGF0ZXhDbWRzLmNvcHJvZHVjdCA9IGJpbmQoU3VtbWF0aW9uTm90YXRpb24sJ1xcXFxjb3Byb2QgJywnJiM4NzIwOycpO1xuXG52YXIgRnJhY3Rpb24gPVxuTGF0ZXhDbWRzLmZyYWMgPVxuTGF0ZXhDbWRzLmRmcmFjID1cbkxhdGV4Q21kcy5jZnJhYyA9XG5MYXRleENtZHMuZnJhY3Rpb24gPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5jdHJsU2VxID0gJ1xcXFxmcmFjJztcbiAgXy5odG1sVGVtcGxhdGUgPVxuICAgICAgJzxzcGFuIGNsYXNzPVwibXEtZnJhY3Rpb24gbXEtbm9uLWxlYWZcIj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLW51bWVyYXRvclwiPiYwPC9zcGFuPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtZGVub21pbmF0b3JcIj4mMTwvc3Bhbj4nXG4gICAgKyAgICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjBcIj4mIzgyMDM7PC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8udGV4dFRlbXBsYXRlID0gWycoJywgJykvKCcsICcpJ107XG4gIF8uZmluYWxpemVUcmVlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51cEludG8gPSB0aGlzLmVuZHNbUl0udXBPdXRPZiA9IHRoaXMuZW5kc1tMXTtcbiAgICB0aGlzLmRvd25JbnRvID0gdGhpcy5lbmRzW0xdLmRvd25PdXRPZiA9IHRoaXMuZW5kc1tSXTtcbiAgfTtcbn0pO1xuXG52YXIgTGl2ZUZyYWN0aW9uID1cbkxhdGV4Q21kcy5vdmVyID1cbkNoYXJDbWRzWycvJ10gPSBQKEZyYWN0aW9uLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5jcmVhdGVMZWZ0T2YgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICBpZiAoIXRoaXMucmVwbGFjZWRGcmFnbWVudCkge1xuICAgICAgdmFyIGxlZnR3YXJkID0gY3Vyc29yW0xdO1xuICAgICAgd2hpbGUgKGxlZnR3YXJkICYmXG4gICAgICAgICEoXG4gICAgICAgICAgbGVmdHdhcmQgaW5zdGFuY2VvZiBCaW5hcnlPcGVyYXRvciB8fFxuICAgICAgICAgIGxlZnR3YXJkIGluc3RhbmNlb2YgKExhdGV4Q21kcy50ZXh0IHx8IG5vb3ApIHx8XG4gICAgICAgICAgbGVmdHdhcmQgaW5zdGFuY2VvZiBTdW1tYXRpb25Ob3RhdGlvbiB8fFxuICAgICAgICAgIGxlZnR3YXJkLmN0cmxTZXEgPT09ICdcXFxcICcgfHxcbiAgICAgICAgICAvXlssOzpdJC8udGVzdChsZWZ0d2FyZC5jdHJsU2VxKVxuICAgICAgICApIC8vbG9va2JlaGluZCBmb3Igb3BlcmF0b3JcbiAgICAgICkgbGVmdHdhcmQgPSBsZWZ0d2FyZFtMXTtcblxuICAgICAgaWYgKGxlZnR3YXJkIGluc3RhbmNlb2YgU3VtbWF0aW9uTm90YXRpb24gJiYgbGVmdHdhcmRbUl0gaW5zdGFuY2VvZiBTdXBTdWIpIHtcbiAgICAgICAgbGVmdHdhcmQgPSBsZWZ0d2FyZFtSXTtcbiAgICAgICAgaWYgKGxlZnR3YXJkW1JdIGluc3RhbmNlb2YgU3VwU3ViICYmIGxlZnR3YXJkW1JdLmN0cmxTZXEgIT0gbGVmdHdhcmQuY3RybFNlcSlcbiAgICAgICAgICBsZWZ0d2FyZCA9IGxlZnR3YXJkW1JdO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVmdHdhcmQgIT09IGN1cnNvcltMXSkge1xuICAgICAgICB0aGlzLnJlcGxhY2VzKEZyYWdtZW50KGxlZnR3YXJkW1JdIHx8IGN1cnNvci5wYXJlbnQuZW5kc1tMXSwgY3Vyc29yW0xdKSk7XG4gICAgICAgIGN1cnNvcltMXSA9IGxlZnR3YXJkO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlcl8uY3JlYXRlTGVmdE9mLmNhbGwodGhpcywgY3Vyc29yKTtcbiAgfTtcbn0pO1xuXG52YXIgU3F1YXJlUm9vdCA9XG5MYXRleENtZHMuc3FydCA9XG5MYXRleENtZHNbJ1xcdTIyMWEnXSA9IFAoTWF0aENvbW1hbmQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmN0cmxTZXEgPSAnXFxcXHNxcnQnO1xuICBfLmh0bWxUZW1wbGF0ZSA9XG4gICAgICAnPHNwYW4gY2xhc3M9XCJtcS1ub24tbGVhZlwiPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtc2NhbGVkIG1xLXNxcnQtcHJlZml4XCI+JnJhZGljOzwvc3Bhbj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLW5vbi1sZWFmIG1xLXNxcnQtc3RlbVwiPiYwPC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8udGV4dFRlbXBsYXRlID0gWydzcXJ0KCcsICcpJ107XG4gIF8ucGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxhdGV4TWF0aFBhcnNlci5vcHRCbG9jay50aGVuKGZ1bmN0aW9uKG9wdEJsb2NrKSB7XG4gICAgICByZXR1cm4gbGF0ZXhNYXRoUGFyc2VyLmJsb2NrLm1hcChmdW5jdGlvbihibG9jaykge1xuICAgICAgICB2YXIgbnRocm9vdCA9IE50aFJvb3QoKTtcbiAgICAgICAgbnRocm9vdC5ibG9ja3MgPSBbIG9wdEJsb2NrLCBibG9jayBdO1xuICAgICAgICBvcHRCbG9jay5hZG9wdChudGhyb290LCAwLCAwKTtcbiAgICAgICAgYmxvY2suYWRvcHQobnRocm9vdCwgb3B0QmxvY2ssIDApO1xuICAgICAgICByZXR1cm4gbnRocm9vdDtcbiAgICAgIH0pO1xuICAgIH0pLm9yKHN1cGVyXy5wYXJzZXIuY2FsbCh0aGlzKSk7XG4gIH07XG4gIF8ucmVmbG93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJsb2NrID0gdGhpcy5lbmRzW1JdLmpRO1xuICAgIHNjYWxlKGJsb2NrLnByZXYoKSwgMSwgYmxvY2suaW5uZXJIZWlnaHQoKS8rYmxvY2suY3NzKCdmb250U2l6ZScpLnNsaWNlKDAsLTIpIC0gLjEpO1xuICB9O1xufSk7XG5cbnZhciBWZWMgPSBMYXRleENtZHMudmVjID0gUChNYXRoQ29tbWFuZCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uY3RybFNlcSA9ICdcXFxcdmVjJztcbiAgXy5odG1sVGVtcGxhdGUgPVxuICAgICAgJzxzcGFuIGNsYXNzPVwibXEtbm9uLWxlYWZcIj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLXZlY3Rvci1wcmVmaXhcIj4mcmFycjs8L3NwYW4+J1xuICAgICsgICAnPHNwYW4gY2xhc3M9XCJtcS12ZWN0b3Itc3RlbVwiPiYwPC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8udGV4dFRlbXBsYXRlID0gWyd2ZWMoJywgJyknXTtcbn0pO1xuXG52YXIgTnRoUm9vdCA9XG5MYXRleENtZHMubnRocm9vdCA9IFAoU3F1YXJlUm9vdCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaHRtbFRlbXBsYXRlID1cbiAgICAgICc8c3VwIGNsYXNzPVwibXEtbnRocm9vdCBtcS1ub24tbGVhZlwiPiYwPC9zdXA+J1xuICAgICsgJzxzcGFuIGNsYXNzPVwibXEtc2NhbGVkXCI+J1xuICAgICsgICAnPHNwYW4gY2xhc3M9XCJtcS1zcXJ0LXByZWZpeCBtcS1zY2FsZWRcIj4mcmFkaWM7PC9zcGFuPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtc3FydC1zdGVtIG1xLW5vbi1sZWFmXCI+JjE8L3NwYW4+J1xuICAgICsgJzwvc3Bhbj4nXG4gIDtcbiAgXy50ZXh0VGVtcGxhdGUgPSBbJ3NxcnRbJywgJ10oJywgJyknXTtcbiAgXy5sYXRleCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnXFxcXHNxcnRbJyt0aGlzLmVuZHNbTF0ubGF0ZXgoKSsnXXsnK3RoaXMuZW5kc1tSXS5sYXRleCgpKyd9JztcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBEZWxpbXNNaXhpbihfLCBzdXBlcl8pIHtcbiAgXy5qUWFkZCA9IGZ1bmN0aW9uKCkge1xuICAgIHN1cGVyXy5qUWFkZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuZGVsaW1qUXMgPSB0aGlzLmpRLmNoaWxkcmVuKCc6Zmlyc3QnKS5hZGQodGhpcy5qUS5jaGlsZHJlbignOmxhc3QnKSk7XG4gICAgdGhpcy5jb250ZW50alEgPSB0aGlzLmpRLmNoaWxkcmVuKCc6ZXEoMSknKTtcbiAgfTtcbiAgXy5yZWZsb3cgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5jb250ZW50alEub3V0ZXJIZWlnaHQoKVxuICAgICAgICAgICAgICAgICAvIHBhcnNlRmxvYXQodGhpcy5jb250ZW50alEuY3NzKCdmb250U2l6ZScpKTtcbiAgICBzY2FsZSh0aGlzLmRlbGltalFzLCBtaW4oMSArIC4yKihoZWlnaHQgLSAxKSwgMS4yKSwgMS4yKmhlaWdodCk7XG4gIH07XG59XG5cbi8vIFJvdW5kL1NxdWFyZS9DdXJseS9BbmdsZSBCcmFja2V0cyAoYWthIFBhcmVucy9CcmFja2V0cy9CcmFjZXMpXG4vLyAgIGZpcnN0IHR5cGVkIGFzIG9uZS1zaWRlZCBicmFja2V0IHdpdGggbWF0Y2hpbmcgXCJnaG9zdFwiIGJyYWNrZXQgYXRcbi8vICAgZmFyIGVuZCBvZiBjdXJyZW50IGJsb2NrLCB1bnRpbCB5b3UgdHlwZSBhbiBvcHBvc2luZyBvbmVcbnZhciBCcmFja2V0ID0gUChQKE1hdGhDb21tYW5kLCBEZWxpbXNNaXhpbiksIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihzaWRlLCBvcGVuLCBjbG9zZSwgY3RybFNlcSwgZW5kKSB7XG4gICAgc3VwZXJfLmluaXQuY2FsbCh0aGlzLCAnXFxcXGxlZnQnK2N0cmxTZXEsIHVuZGVmaW5lZCwgW29wZW4sIGNsb3NlXSk7XG4gICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB0aGlzLnNpZGVzID0ge307XG4gICAgdGhpcy5zaWRlc1tMXSA9IHsgY2g6IG9wZW4sIGN0cmxTZXE6IGN0cmxTZXEgfTtcbiAgICB0aGlzLnNpZGVzW1JdID0geyBjaDogY2xvc2UsIGN0cmxTZXE6IGVuZCB9O1xuICB9O1xuICBfLm51bUJsb2NrcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMTsgfTtcbiAgXy5odG1sID0gZnVuY3Rpb24oKSB7IC8vIHdhaXQgdW50aWwgbm93IHNvIHRoYXQgLnNpZGUgbWF5XG4gICAgdGhpcy5odG1sVGVtcGxhdGUgPSAvLyBiZSBzZXQgYnkgY3JlYXRlTGVmdE9mIG9yIHBhcnNlclxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJtcS1ub24tbGVhZlwiPidcbiAgICAgICsgICAnPHNwYW4gY2xhc3M9XCJtcS1zY2FsZWQgbXEtcGFyZW4nKyh0aGlzLnNpZGUgPT09IFIgPyAnIG1xLWdob3N0JyA6ICcnKSsnXCI+J1xuICAgICAgKyAgICAgdGhpcy5zaWRlc1tMXS5jaFxuICAgICAgKyAgICc8L3NwYW4+J1xuICAgICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLW5vbi1sZWFmXCI+JjA8L3NwYW4+J1xuICAgICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLXNjYWxlZCBtcS1wYXJlbicrKHRoaXMuc2lkZSA9PT0gTCA/ICcgbXEtZ2hvc3QnIDogJycpKydcIj4nXG4gICAgICArICAgICB0aGlzLnNpZGVzW1JdLmNoXG4gICAgICArICAgJzwvc3Bhbj4nXG4gICAgICArICc8L3NwYW4+J1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXJfLmh0bWwuY2FsbCh0aGlzKTtcbiAgfTtcbiAgXy5sYXRleCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnXFxcXGxlZnQnK3RoaXMuc2lkZXNbTF0uY3RybFNlcSt0aGlzLmVuZHNbTF0ubGF0ZXgoKSsnXFxcXHJpZ2h0Jyt0aGlzLnNpZGVzW1JdLmN0cmxTZXE7XG4gIH07XG4gIF8ub3BwQnJhY2sgPSBmdW5jdGlvbihvcHRzLCBub2RlLCBleHBlY3RlZFNpZGUpIHtcbiAgICAvLyByZXR1cm4gbm9kZSBpZmYgaXQncyBhIDEtc2lkZWQgYnJhY2tldCBvZiBleHBlY3RlZCBzaWRlIChpZiBhbnksIG1heSBiZVxuICAgIC8vIHVuZGVmaW5lZCksIGFuZCBvZiBvcHBvc2l0ZSBzaWRlIGZyb20gbWUgaWYgSSdtIG5vdCBhIHBpcGVcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJyYWNrZXQgJiYgbm9kZS5zaWRlICYmIG5vZGUuc2lkZSAhPT0gLWV4cGVjdGVkU2lkZVxuICAgICAgJiYgKHRoaXMuc2lkZXNbdGhpcy5zaWRlXS5jaCA9PT0gJ3wnIHx8IG5vZGUuc2lkZSA9PT0gLXRoaXMuc2lkZSlcbiAgICAgICYmICghb3B0cy5yZXN0cmljdE1pc21hdGNoZWRCcmFja2V0c1xuICAgICAgICB8fCBPUFBfQlJBQ0tTW3RoaXMuc2lkZXNbdGhpcy5zaWRlXS5jaF0gPT09IG5vZGUuc2lkZXNbbm9kZS5zaWRlXS5jaFxuICAgICAgICB8fCB7ICcoJzogJ10nLCAnWyc6ICcpJyB9W3RoaXMuc2lkZXNbTF0uY2hdID09PSBub2RlLnNpZGVzW1JdLmNoKSAmJiBub2RlO1xuICB9O1xuICBfLmNsb3NlT3Bwb3NpbmcgPSBmdW5jdGlvbihicmFjaykge1xuICAgIGJyYWNrLnNpZGUgPSAwO1xuICAgIGJyYWNrLnNpZGVzW3RoaXMuc2lkZV0gPSB0aGlzLnNpZGVzW3RoaXMuc2lkZV07IC8vIGNvcHkgb3ZlciBteSBpbmZvIChtYXkgYmVcbiAgICBicmFjay5kZWxpbWpRcy5lcSh0aGlzLnNpZGUgPT09IEwgPyAwIDogMSkgLy8gbWlzbWF0Y2hlZCwgbGlrZSBbYSwgYikpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ21xLWdob3N0JykuaHRtbCh0aGlzLnNpZGVzW3RoaXMuc2lkZV0uY2gpO1xuICB9O1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIGlmICghdGhpcy5yZXBsYWNlZEZyYWdtZW50KSB7IC8vIHVubGVzcyB3cmFwcGluZyBzZWxuIGluIGJyYWNrZXRzLFxuICAgICAgICAvLyBjaGVjayBpZiBuZXh0IHRvIG9yIGluc2lkZSBhbiBvcHBvc2luZyBvbmUtc2lkZWQgYnJhY2tldFxuICAgICAgICAvLyAobXVzdCBjaGVjayBib3RoIHNpZGVzICdjb3MgSSBtaWdodCBiZSBhIHBpcGUpXG4gICAgICB2YXIgb3B0cyA9IGN1cnNvci5vcHRpb25zO1xuICAgICAgdmFyIGJyYWNrID0gdGhpcy5vcHBCcmFjayhvcHRzLCBjdXJzb3JbTF0sIEwpXG4gICAgICAgICAgICAgICAgICB8fCB0aGlzLm9wcEJyYWNrKG9wdHMsIGN1cnNvcltSXSwgUilcbiAgICAgICAgICAgICAgICAgIHx8IHRoaXMub3BwQnJhY2sob3B0cywgY3Vyc29yLnBhcmVudC5wYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoYnJhY2spIHtcbiAgICAgIHZhciBzaWRlID0gdGhpcy5zaWRlID0gLWJyYWNrLnNpZGU7IC8vIG1heSBiZSBwaXBlIHdpdGggLnNpZGUgbm90IHlldCBzZXRcbiAgICAgIHRoaXMuY2xvc2VPcHBvc2luZyhicmFjayk7XG4gICAgICBpZiAoYnJhY2sgPT09IGN1cnNvci5wYXJlbnQucGFyZW50ICYmIGN1cnNvcltzaWRlXSkgeyAvLyBtb3ZlIHRoZSBzdHVmZiBiZXR3ZWVuXG4gICAgICAgIEZyYWdtZW50KGN1cnNvcltzaWRlXSwgY3Vyc29yLnBhcmVudC5lbmRzW3NpZGVdLCAtc2lkZSkgLy8gbWUgYW5kIGdob3N0IG91dHNpZGVcbiAgICAgICAgICAuZGlzb3duKCkud2l0aERpckFkb3B0KC1zaWRlLCBicmFjay5wYXJlbnQsIGJyYWNrLCBicmFja1tzaWRlXSlcbiAgICAgICAgICAualEuaW5zRGlyT2Yoc2lkZSwgYnJhY2sualEpO1xuICAgICAgICBicmFjay5idWJibGUoJ3JlZmxvdycpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGJyYWNrID0gdGhpcywgc2lkZSA9IGJyYWNrLnNpZGU7XG4gICAgICBpZiAoYnJhY2sucmVwbGFjZWRGcmFnbWVudCkgYnJhY2suc2lkZSA9IDA7IC8vIHdyYXBwaW5nIHNlbG4sIGRvbid0IGJlIG9uZS1zaWRlZFxuICAgICAgZWxzZSBpZiAoY3Vyc29yWy1zaWRlXSkgeyAvLyBlbHNld2lzZSwgYXV0by1leHBhbmQgc28gZ2hvc3QgaXMgYXQgZmFyIGVuZFxuICAgICAgICBicmFjay5yZXBsYWNlcyhGcmFnbWVudChjdXJzb3JbLXNpZGVdLCBjdXJzb3IucGFyZW50LmVuZHNbLXNpZGVdLCBzaWRlKSk7XG4gICAgICAgIGN1cnNvclstc2lkZV0gPSAwO1xuICAgICAgfVxuICAgICAgc3VwZXJfLmNyZWF0ZUxlZnRPZi5jYWxsKGJyYWNrLCBjdXJzb3IpO1xuICAgIH1cbiAgICBpZiAoc2lkZSA9PT0gTCkgY3Vyc29yLmluc0F0TGVmdEVuZChicmFjay5lbmRzW0xdKTtcbiAgICBlbHNlIGN1cnNvci5pbnNSaWdodE9mKGJyYWNrKTtcbiAgfTtcbiAgXy5wbGFjZUN1cnNvciA9IG5vb3A7XG4gIF8udW53cmFwID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbmRzW0xdLmNoaWxkcmVuKCkuZGlzb3duKCkuYWRvcHQodGhpcy5wYXJlbnQsIHRoaXMsIHRoaXNbUl0pXG4gICAgICAualEuaW5zZXJ0QWZ0ZXIodGhpcy5qUSk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfTtcbiAgXy5kZWxldGVTaWRlID0gZnVuY3Rpb24oc2lkZSwgb3V0d2FyZCwgY3Vyc29yKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LCBzaWIgPSB0aGlzW3NpZGVdLCBmYXJFbmQgPSBwYXJlbnQuZW5kc1tzaWRlXTtcblxuICAgIGlmIChzaWRlID09PSB0aGlzLnNpZGUpIHsgLy8gZGVsZXRpbmcgbm9uLWdob3N0IG9mIG9uZS1zaWRlZCBicmFja2V0LCB1bndyYXBcbiAgICAgIHRoaXMudW53cmFwKCk7XG4gICAgICBzaWIgPyBjdXJzb3IuaW5zRGlyT2YoLXNpZGUsIHNpYikgOiBjdXJzb3IuaW5zQXREaXJFbmQoc2lkZSwgcGFyZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3B0cyA9IGN1cnNvci5vcHRpb25zLCB3YXNTb2xpZCA9ICF0aGlzLnNpZGU7XG4gICAgdGhpcy5zaWRlID0gLXNpZGU7XG4gICAgLy8gaWYgZGVsZXRpbmcgbGlrZSwgb3V0ZXIgY2xvc2UtYnJhY2Ugb2YgWygxKzIpKzN9IHdoZXJlIGlubmVyIG9wZW4tcGFyZW5cbiAgICBpZiAodGhpcy5vcHBCcmFjayhvcHRzLCB0aGlzLmVuZHNbTF0uZW5kc1t0aGlzLnNpZGVdLCBzaWRlKSkgeyAvLyBpcyBnaG9zdCxcbiAgICAgIHRoaXMuY2xvc2VPcHBvc2luZyh0aGlzLmVuZHNbTF0uZW5kc1t0aGlzLnNpZGVdKTsgLy8gdGhlbiBiZWNvbWUgWzErMikrM1xuICAgICAgdmFyIG9yaWdFbmQgPSB0aGlzLmVuZHNbTF0uZW5kc1tzaWRlXTtcbiAgICAgIHRoaXMudW53cmFwKCk7XG4gICAgICBpZiAob3JpZ0VuZC5zaWJsaW5nQ3JlYXRlZCkgb3JpZ0VuZC5zaWJsaW5nQ3JlYXRlZChjdXJzb3Iub3B0aW9ucywgc2lkZSk7XG4gICAgICBzaWIgPyBjdXJzb3IuaW5zRGlyT2YoLXNpZGUsIHNpYikgOiBjdXJzb3IuaW5zQXREaXJFbmQoc2lkZSwgcGFyZW50KTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIGlmIGRlbGV0aW5nIGxpa2UsIGlubmVyIGNsb3NlLWJyYWNlIG9mIChbMSsyfSszKSB3aGVyZSBvdXRlclxuICAgICAgaWYgKHRoaXMub3BwQnJhY2sob3B0cywgdGhpcy5wYXJlbnQucGFyZW50LCBzaWRlKSkgeyAvLyBvcGVuLXBhcmVuIGlzXG4gICAgICAgIHRoaXMucGFyZW50LnBhcmVudC5jbG9zZU9wcG9zaW5nKHRoaXMpOyAvLyBnaG9zdCwgdGhlbiBiZWNvbWUgWzErMiszKVxuICAgICAgICB0aGlzLnBhcmVudC5wYXJlbnQudW53cmFwKCk7XG4gICAgICB9IC8vIGVsc2UgaWYgZGVsZXRpbmcgb3V0d2FyZCBmcm9tIGEgc29saWQgcGFpciwgdW53cmFwXG4gICAgICBlbHNlIGlmIChvdXR3YXJkICYmIHdhc1NvbGlkKSB7XG4gICAgICAgIHRoaXMudW53cmFwKCk7XG4gICAgICAgIHNpYiA/IGN1cnNvci5pbnNEaXJPZigtc2lkZSwgc2liKSA6IGN1cnNvci5pbnNBdERpckVuZChzaWRlLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gZWxzZSBkZWxldGluZyBqdXN0IG9uZSBvZiBhIHBhaXIgb2YgYnJhY2tldHMsIGJlY29tZSBvbmUtc2lkZWRcbiAgICAgICAgdGhpcy5zaWRlc1tzaWRlXSA9IHsgY2g6IE9QUF9CUkFDS1NbdGhpcy5zaWRlc1t0aGlzLnNpZGVdLmNoXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybFNlcTogT1BQX0JSQUNLU1t0aGlzLnNpZGVzW3RoaXMuc2lkZV0uY3RybFNlcV0gfTtcbiAgICAgICAgdGhpcy5kZWxpbWpRcy5yZW1vdmVDbGFzcygnbXEtZ2hvc3QnKVxuICAgICAgICAgIC5lcShzaWRlID09PSBMID8gMCA6IDEpLmFkZENsYXNzKCdtcS1naG9zdCcpLmh0bWwodGhpcy5zaWRlc1tzaWRlXS5jaCk7XG4gICAgICB9XG4gICAgICBpZiAoc2liKSB7IC8vIGF1dG8tZXhwYW5kIHNvIGdob3N0IGlzIGF0IGZhciBlbmRcbiAgICAgICAgdmFyIG9yaWdFbmQgPSB0aGlzLmVuZHNbTF0uZW5kc1tzaWRlXTtcbiAgICAgICAgRnJhZ21lbnQoc2liLCBmYXJFbmQsIC1zaWRlKS5kaXNvd24oKVxuICAgICAgICAgIC53aXRoRGlyQWRvcHQoLXNpZGUsIHRoaXMuZW5kc1tMXSwgb3JpZ0VuZCwgMClcbiAgICAgICAgICAualEuaW5zQXREaXJFbmQoc2lkZSwgdGhpcy5lbmRzW0xdLmpRLnJlbW92ZUNsYXNzKCdtcS1lbXB0eScpKTtcbiAgICAgICAgaWYgKG9yaWdFbmQuc2libGluZ0NyZWF0ZWQpIG9yaWdFbmQuc2libGluZ0NyZWF0ZWQoY3Vyc29yLm9wdGlvbnMsIHNpZGUpO1xuICAgICAgICBjdXJzb3IuaW5zRGlyT2YoLXNpZGUsIHNpYik7XG4gICAgICB9IC8vIGRpZG4ndCBhdXRvLWV4cGFuZCwgY3Vyc29yIGdvZXMganVzdCBvdXRzaWRlIG9yIGp1c3QgaW5zaWRlIHBhcmVuc1xuICAgICAgZWxzZSAob3V0d2FyZCA/IGN1cnNvci5pbnNEaXJPZihzaWRlLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICA6IGN1cnNvci5pbnNBdERpckVuZChzaWRlLCB0aGlzLmVuZHNbTF0pKTtcbiAgICB9XG4gIH07XG4gIF8uZGVsZXRlVG93YXJkcyA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgdGhpcy5kZWxldGVTaWRlKC1kaXIsIGZhbHNlLCBjdXJzb3IpO1xuICB9O1xuICBfLmZpbmFsaXplVHJlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZW5kc1tMXS5kZWxldGVPdXRPZiA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgICB0aGlzLnBhcmVudC5kZWxldGVTaWRlKGRpciwgdHJ1ZSwgY3Vyc29yKTtcbiAgICB9O1xuICAgIC8vIEZJWE1FIEhBQ0s6IGFmdGVyIGluaXRpYWwgY3JlYXRpb24vaW5zZXJ0aW9uLCBmaW5hbGl6ZVRyZWUgd291bGQgb25seSBiZVxuICAgIC8vIGNhbGxlZCBpZiB0aGUgcGFyZW4gaXMgc2VsZWN0ZWQgYW5kIHJlcGxhY2VkLCBlLmcuIGJ5IExpdmVGcmFjdGlvblxuICAgIHRoaXMuZmluYWxpemVUcmVlID0gdGhpcy5pbnRlbnRpb25hbEJsdXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGVsaW1qUXMuZXEodGhpcy5zaWRlID09PSBMID8gMSA6IDApLnJlbW92ZUNsYXNzKCdtcS1naG9zdCcpO1xuICAgICAgdGhpcy5zaWRlID0gMDtcbiAgICB9O1xuICB9O1xuICBfLnNpYmxpbmdDcmVhdGVkID0gZnVuY3Rpb24ob3B0cywgZGlyKSB7IC8vIGlmIHNvbWV0aGluZyB0eXBlZCBiZXR3ZWVuIGdob3N0IGFuZCBmYXJcbiAgICBpZiAoZGlyID09PSAtdGhpcy5zaWRlKSB0aGlzLmZpbmFsaXplVHJlZSgpOyAvLyBlbmQgb2YgaXRzIGJsb2NrLCBzb2xpZGlmeVxuICB9O1xufSk7XG5cbnZhciBPUFBfQlJBQ0tTID0ge1xuICAnKCc6ICcpJyxcbiAgJyknOiAnKCcsXG4gICdbJzogJ10nLFxuICAnXSc6ICdbJyxcbiAgJ3snOiAnfScsXG4gICd9JzogJ3snLFxuICAnXFxcXHsnOiAnXFxcXH0nLFxuICAnXFxcXH0nOiAnXFxcXHsnLFxuICAnJmxhbmc7JzogJyZyYW5nOycsXG4gICcmcmFuZzsnOiAnJmxhbmc7JyxcbiAgJ1xcXFxsYW5nbGUgJzogJ1xcXFxyYW5nbGUgJyxcbiAgJ1xcXFxyYW5nbGUgJzogJ1xcXFxsYW5nbGUgJyxcbiAgJ3wnOiAnfCdcbn07XG5cbmZ1bmN0aW9uIGJpbmRDaGFyQnJhY2tldFBhaXIob3BlbiwgY3RybFNlcSkge1xuICB2YXIgY3RybFNlcSA9IGN0cmxTZXEgfHwgb3BlbiwgY2xvc2UgPSBPUFBfQlJBQ0tTW29wZW5dLCBlbmQgPSBPUFBfQlJBQ0tTW2N0cmxTZXFdO1xuICBDaGFyQ21kc1tvcGVuXSA9IGJpbmQoQnJhY2tldCwgTCwgb3BlbiwgY2xvc2UsIGN0cmxTZXEsIGVuZCk7XG4gIENoYXJDbWRzW2Nsb3NlXSA9IGJpbmQoQnJhY2tldCwgUiwgb3BlbiwgY2xvc2UsIGN0cmxTZXEsIGVuZCk7XG59XG5iaW5kQ2hhckJyYWNrZXRQYWlyKCcoJyk7XG5iaW5kQ2hhckJyYWNrZXRQYWlyKCdbJyk7XG5iaW5kQ2hhckJyYWNrZXRQYWlyKCd7JywgJ1xcXFx7Jyk7XG5MYXRleENtZHMubGFuZ2xlID0gYmluZChCcmFja2V0LCBMLCAnJmxhbmc7JywgJyZyYW5nOycsICdcXFxcbGFuZ2xlICcsICdcXFxccmFuZ2xlICcpO1xuTGF0ZXhDbWRzLnJhbmdsZSA9IGJpbmQoQnJhY2tldCwgUiwgJyZsYW5nOycsICcmcmFuZzsnLCAnXFxcXGxhbmdsZSAnLCAnXFxcXHJhbmdsZSAnKTtcbkNoYXJDbWRzWyd8J10gPSBiaW5kKEJyYWNrZXQsIEwsICd8JywgJ3wnLCAnfCcsICd8Jyk7XG5cbkxhdGV4Q21kcy5sZWZ0ID0gUChNYXRoQ29tbWFuZCwgZnVuY3Rpb24oXykge1xuICBfLnBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWdleCA9IFBhcnNlci5yZWdleDtcbiAgICB2YXIgc3RyaW5nID0gUGFyc2VyLnN0cmluZztcbiAgICB2YXIgc3VjY2VlZCA9IFBhcnNlci5zdWNjZWVkO1xuICAgIHZhciBvcHRXaGl0ZXNwYWNlID0gUGFyc2VyLm9wdFdoaXRlc3BhY2U7XG5cbiAgICByZXR1cm4gb3B0V2hpdGVzcGFjZS50aGVuKHJlZ2V4KC9eKD86WyhbfF18XFxcXFxceykvKSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKGN0cmxTZXEpIHsgLy8gVE9ETzogXFxsYW5nbGUsIFxccmFuZ2xlXG4gICAgICAgIHZhciBvcGVuID0gKGN0cmxTZXEuY2hhckF0KDApID09PSAnXFxcXCcgPyBjdHJsU2VxLnNsaWNlKDEpIDogY3RybFNlcSk7XG4gICAgICAgIHJldHVybiBsYXRleE1hdGhQYXJzZXIudGhlbihmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nKCdcXFxccmlnaHQnKS5za2lwKG9wdFdoaXRlc3BhY2UpXG4gICAgICAgICAgICAudGhlbihyZWdleCgvXig/OltcXF0pfF18XFxcXFxcfSkvKSkubWFwKGZ1bmN0aW9uKGVuZCkge1xuICAgICAgICAgICAgICB2YXIgY2xvc2UgPSAoZW5kLmNoYXJBdCgwKSA9PT0gJ1xcXFwnID8gZW5kLnNsaWNlKDEpIDogZW5kKTtcbiAgICAgICAgICAgICAgdmFyIGNtZCA9IEJyYWNrZXQoMCwgb3BlbiwgY2xvc2UsIGN0cmxTZXEsIGVuZCk7XG4gICAgICAgICAgICAgIGNtZC5ibG9ja3MgPSBbIGJsb2NrIF07XG4gICAgICAgICAgICAgIGJsb2NrLmFkb3B0KGNtZCwgMCwgMCk7XG4gICAgICAgICAgICAgIHJldHVybiBjbWQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgIDtcbiAgfTtcbn0pO1xuXG5MYXRleENtZHMucmlnaHQgPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfKSB7XG4gIF8ucGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBhcnNlci5mYWlsKCd1bm1hdGNoZWQgXFxcXHJpZ2h0Jyk7XG4gIH07XG59KTtcblxudmFyIEJpbm9taWFsID1cbkxhdGV4Q21kcy5iaW5vbSA9XG5MYXRleENtZHMuYmlub21pYWwgPSBQKFAoTWF0aENvbW1hbmQsIERlbGltc01peGluKSwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uY3RybFNlcSA9ICdcXFxcYmlub20nO1xuICBfLmh0bWxUZW1wbGF0ZSA9XG4gICAgICAnPHNwYW4gY2xhc3M9XCJtcS1ub24tbGVhZlwiPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtcGFyZW4gbXEtc2NhbGVkXCI+KDwvc3Bhbj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLW5vbi1sZWFmXCI+J1xuICAgICsgICAgICc8c3BhbiBjbGFzcz1cIm1xLWFycmF5IG1xLW5vbi1sZWFmXCI+J1xuICAgICsgICAgICAgJzxzcGFuPiYwPC9zcGFuPidcbiAgICArICAgICAgICc8c3Bhbj4mMTwvc3Bhbj4nXG4gICAgKyAgICAgJzwvc3Bhbj4nXG4gICAgKyAgICc8L3NwYW4+J1xuICAgICsgICAnPHNwYW4gY2xhc3M9XCJtcS1wYXJlbiBtcS1zY2FsZWRcIj4pPC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8udGV4dFRlbXBsYXRlID0gWydjaG9vc2UoJywnLCcsJyknXTtcbn0pO1xuXG52YXIgQ2hvb3NlID1cbkxhdGV4Q21kcy5jaG9vc2UgPSBQKEJpbm9taWFsLCBmdW5jdGlvbihfKSB7XG4gIF8uY3JlYXRlTGVmdE9mID0gTGl2ZUZyYWN0aW9uLnByb3RvdHlwZS5jcmVhdGVMZWZ0T2Y7XG59KTtcblxuTGF0ZXhDbWRzLmVkaXRhYmxlID0gLy8gYmFja2NvbXBhdCB3aXRoIGJlZm9yZSBjZmQzNjIwIG9uICMyMzNcbkxhdGV4Q21kcy5NYXRoUXVpbGxNYXRoRmllbGQgPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5jdHJsU2VxID0gJ1xcXFxNYXRoUXVpbGxNYXRoRmllbGQnO1xuICBfLmh0bWxUZW1wbGF0ZSA9XG4gICAgICAnPHNwYW4gY2xhc3M9XCJtcS1lZGl0YWJsZS1maWVsZFwiPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtcm9vdC1ibG9ja1wiPiYwPC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8ucGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgc3RyaW5nID0gUGFyc2VyLnN0cmluZywgcmVnZXggPSBQYXJzZXIucmVnZXgsIHN1Y2NlZWQgPSBQYXJzZXIuc3VjY2VlZDtcbiAgICByZXR1cm4gc3RyaW5nKCdbJykudGhlbihyZWdleCgvXlthLXpdW2EtejAtOV0qL2kpKS5za2lwKHN0cmluZygnXScpKVxuICAgICAgLm1hcChmdW5jdGlvbihuYW1lKSB7IHNlbGYubmFtZSA9IG5hbWU7IH0pLm9yKHN1Y2NlZWQoKSlcbiAgICAgIC50aGVuKHN1cGVyXy5wYXJzZXIuY2FsbChzZWxmKSk7XG4gIH07XG4gIF8uZmluYWxpemVUcmVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0cmxyID0gQ29udHJvbGxlcih0aGlzLmVuZHNbTF0sIHRoaXMualEsIE9wdGlvbnMoKSk7XG4gICAgY3RybHIuS0lORF9PRl9NUSA9ICdNYXRoRmllbGQnO1xuICAgIGN0cmxyLmVkaXRhYmxlID0gdHJ1ZTtcbiAgICBjdHJsci5jcmVhdGVUZXh0YXJlYSgpO1xuICAgIGN0cmxyLmVkaXRhYmxlc1RleHRhcmVhRXZlbnRzKCk7XG4gICAgY3RybHIuY3Vyc29yLmluc0F0UmlnaHRFbmQoY3RybHIucm9vdCk7XG4gICAgUm9vdEJsb2NrTWl4aW4oY3RybHIucm9vdCk7XG4gIH07XG4gIF8ucmVnaXN0ZXJJbm5lckZpZWxkID0gZnVuY3Rpb24oaW5uZXJGaWVsZHMsIE1hdGhGaWVsZCkge1xuICAgIGlubmVyRmllbGRzLnB1c2goaW5uZXJGaWVsZHNbdGhpcy5uYW1lXSA9IE1hdGhGaWVsZCh0aGlzLmVuZHNbTF0uY29udHJvbGxlcikpO1xuICB9O1xuICBfLmxhdGV4ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZW5kc1tMXS5sYXRleCgpOyB9O1xuICBfLnRleHQgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5lbmRzW0xdLnRleHQoKTsgfTtcbn0pO1xuXG4vLyBFbWJlZCBhcmJpdHJhcnkgdGhpbmdzXG4vLyBQcm9iYWJseSB0aGUgY2xvc2VzdCBET00gYW5hbG9ndWUgd291bGQgYmUgYW4gaWZyYW1lP1xuLy8gRnJvbSBNYXRoUXVpbGwncyBwZXJzcGVjdGl2ZSwgaXQncyBhIFN5bWJvbCwgaXQgY2FuIGJlXG4vLyBhbnl3aGVyZSBhbmQgdGhlIGN1cnNvciBjYW4gZ28gYXJvdW5kIGl0IGJ1dCBuZXZlciBpbiBpdC5cbi8vIENyZWF0ZSBieSBjYWxsaW5nIHB1YmxpYyBBUEkgbWV0aG9kIC5kcm9wRW1iZWRkZWQoKSxcbi8vIG9yIGJ5IGNhbGxpbmcgdGhlIGdsb2JhbCBwdWJsaWMgQVBJIG1ldGhvZCAucmVnaXN0ZXJFbWJlZCgpXG4vLyBhbmQgcmVuZGVyaW5nIExhVGVYIGxpa2UgXFxlbWJlZHtyZWdpc3RlcmVkTmFtZX0gKHNlZSB0ZXN0KS5cbnZhciBFbWJlZCA9IExhdGV4Q21kcy5lbWJlZCA9IFAoU3ltYm9sLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIG5vb3AgKCkgeyByZXR1cm4gXCJcIjsgfVxuICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dCB8fCBub29wO1xuICAgIHRoaXMuaHRtbFRlbXBsYXRlID0gb3B0aW9ucy5odG1sU3RyaW5nIHx8IFwiXCI7XG4gICAgdGhpcy5sYXRleCA9IG9wdGlvbnMubGF0ZXggfHwgbm9vcDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgXy5wYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBzdHJpbmcgPSBQYXJzZXIuc3RyaW5nLCByZWdleCA9IFBhcnNlci5yZWdleCwgc3VjY2VlZCA9IFBhcnNlci5zdWNjZWVkO1xuICAgIHJldHVybiBzdHJpbmcoJ3snKS50aGVuKHJlZ2V4KC9eW2Etel1bYS16MC05XSovaSkpLnNraXAoc3RyaW5nKCd9JykpXG4gICAgICAudGhlbihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIC8vIHRoZSBjaGFycyBhbGxvd2VkIGluIHRoZSBvcHRpb25hbCBkYXRhIGJsb2NrIGFyZSBhcmJpdHJhcnkgb3RoZXIgdGhhblxuICAgICAgICAvLyBleGNsdWRpbmcgY3VybHkgYnJhY2VzIGFuZCBzcXVhcmUgYnJhY2tldHMgKHdoaWNoJ2QgYmUgdG9vIGNvbmZ1c2luZylcbiAgICAgICAgcmV0dXJuIHN0cmluZygnWycpLnRoZW4ocmVnZXgoL15bLVxcd1xcc10qLykpLnNraXAoc3RyaW5nKCddJykpXG4gICAgICAgICAgLm9yKHN1Y2NlZWQoKSkubWFwKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNldE9wdGlvbnMoRU1CRURTW25hbWVdKGRhdGEpKTtcbiAgICAgICAgICB9KVxuICAgICAgICA7XG4gICAgICB9KVxuICAgIDtcbiAgfTtcbn0pO1xudmFyIE1RMSA9IGdldEludGVyZmFjZSgxKTtcbmZvciAodmFyIGtleSBpbiBNUTEpIChmdW5jdGlvbihrZXksIHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIE1hdGhRdWlsbFtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICBpbnNpc3RPbkludGVyVmVyKCk7XG4gICAgICByZXR1cm4gdmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBNYXRoUXVpbGxba2V5XS5wcm90b3R5cGUgPSB2YWwucHJvdG90eXBlO1xuICB9XG4gIGVsc2UgTWF0aFF1aWxsW2tleV0gPSB2YWw7XG59KGtleSwgTVExW2tleV0pKTtcblxufSgpKTtcblxuXG4vKioqIEVYUE9SVFMgRlJPTSBleHBvcnRzLWxvYWRlciAqKiovXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5NYXRoUXVpbGw7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL21hdGhxdWlsbC9tYXRocXVpbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 215:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar store = __webpack_require__(216);\n\nmodule.exports = {\n    // naming convetion: verb + noun\n    // the noun should be one of the other properties in the object that's\n    // being dispatched\n\n    pressKey: function pressKey(key) {\n        var cmd = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n        store.dispatch({\n            type: 'PressKey',\n            key: key,\n            cmd: cmd\n        });\n    },\n\n    registerKeyHandler: function registerKeyHandler(keyHandler) {\n        store.dispatch({\n            type: 'RegisterKeyHandler',\n            keyHandler: keyHandler\n        });\n    }\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYWN0aW9ucy5qcz8wZTY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBTSxRQUFRLG9CQUFRLEdBQVIsQ0FBUjs7QUFFTixPQUFPLE9BQVAsR0FBaUI7Ozs7O0FBS2IsY0FBVSxrQkFBUyxHQUFULEVBQTJCO1lBQWIsNERBQU0scUJBQU87O0FBQ2pDLGNBQU0sUUFBTixDQUFlO0FBQ1gsa0JBQU0sVUFBTjtBQUNBLG9CQUZXO0FBR1gsb0JBSFc7U0FBZixFQURpQztLQUEzQjs7QUFRVix3QkFBb0IsNEJBQVMsVUFBVCxFQUFxQjtBQUNyQyxjQUFNLFFBQU4sQ0FBZTtBQUNYLGtCQUFNLG9CQUFOO0FBQ0Esa0NBRlc7U0FBZixFQURxQztLQUFyQjtDQWJ4QiIsImZpbGUiOiIyMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBzdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gbmFtaW5nIGNvbnZldGlvbjogdmVyYiArIG5vdW5cbiAgICAvLyB0aGUgbm91biBzaG91bGQgYmUgb25lIG9mIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGluIHRoZSBvYmplY3QgdGhhdCdzXG4gICAgLy8gYmVpbmcgZGlzcGF0Y2hlZFxuXG4gICAgcHJlc3NLZXk6IGZ1bmN0aW9uKGtleSwgY21kID0gZmFsc2UpIHtcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1ByZXNzS2V5JyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGNtZCxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyS2V5SGFuZGxlcjogZnVuY3Rpb24oa2V5SGFuZGxlcikge1xuICAgICAgICBzdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUmVnaXN0ZXJLZXlIYW5kbGVyJyxcbiAgICAgICAgICAgIGtleUhhbmRsZXIsXG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYWN0aW9ucy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 216:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Redux = __webpack_require__(174);\n\nvar initialState = {\n    currentValue: '',\n    keyHandlers: [] };\n\n// TODO(kevinb) keep track of the current handle\nvar reducer = function reducer() {\n    var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];\n    var action = arguments[1];\n\n\n    switch (action.type) {\n        case 'RegisterKeyHandler':\n            return _extends({}, state, {\n                keyHandlers: [].concat(_toConsumableArray(state.keyHandlers), [action.keyHandler])\n            });\n\n        case 'PressKey':\n            // This is probably an anti-pattern but it works for the case where\n            // we don't actually control the state but we still want to\n            // communicate with the other object\n            state.keyHandlers.forEach(function (handler) {\n                handler(action.key, action.cmd);\n            });\n\n            // TODO(kevinb) have the handler return state from MathQuill and store it\n            return state;\n\n        case 'PressBackspace':\n            state.keyHandlers.forEach(function (handler) {\n                handler('backspace');\n            });\n\n        default:\n            return state;\n    }\n};\n\nvar store = Redux.createStore(reducer);\n\nmodule.exports = store;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3RvcmUuanM/YTI1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxJQUFNLFFBQVEsb0JBQVEsR0FBUixDQUFSOztBQUVOLElBQU0sZUFBZTtBQUNqQixrQkFBYyxFQUFkO0FBQ0EsaUJBQWEsRUFBYixFQUZFOzs7QUFLTixJQUFNLFVBQVUsU0FBVixPQUFVLEdBQXVDO1FBQTlCLDhEQUFRLDRCQUFzQjtRQUFSLHNCQUFROzs7QUFFbkQsWUFBTyxPQUFPLElBQVA7QUFDSCxhQUFLLG9CQUFMO0FBQ0ksZ0NBQ087QUFDSCwwREFBaUIsTUFBTSxXQUFOLElBQW1CLE9BQU8sVUFBUCxFQUFwQztjQUZKLENBREo7O0FBREosYUFPUyxVQUFMOzs7O0FBSUksa0JBQU0sV0FBTixDQUFrQixPQUFsQixDQUEwQixtQkFBVztBQUNqQyx3QkFBUSxPQUFPLEdBQVAsRUFBWSxPQUFPLEdBQVAsQ0FBcEIsQ0FEaUM7YUFBWCxDQUExQjs7O0FBSkosbUJBU1csS0FBUCxDQVRKOztBQVBKLGFBa0JTLGdCQUFMO0FBQ0ksa0JBQU0sV0FBTixDQUFrQixPQUFsQixDQUEwQixtQkFBVztBQUNqQyx3QkFBUSxXQUFSLEVBRGlDO2FBQVgsQ0FBMUIsQ0FESjs7QUFsQko7QUF3QlEsbUJBQU8sS0FBUCxDQURKO0FBdkJKLEtBRm1EO0NBQXZDOztBQStCaEIsSUFBTSxRQUFRLE1BQU0sV0FBTixDQUFrQixPQUFsQixDQUFSOztBQUVOLE9BQU8sT0FBUCxHQUFpQixLQUFqQiIsImZpbGUiOiIyMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSZWR1eCA9IHJlcXVpcmUoJ3JlZHV4Jyk7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICBjdXJyZW50VmFsdWU6ICcnLFxuICAgIGtleUhhbmRsZXJzOiBbXSwgICAgLy8gVE9ETyhrZXZpbmIpIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgaGFuZGxlXG59O1xuXG5jb25zdCByZWR1Y2VyID0gZnVuY3Rpb24oc3RhdGUgPSBpbml0aWFsU3RhdGUsIGFjdGlvbikge1xuXG4gICAgc3dpdGNoKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1JlZ2lzdGVyS2V5SGFuZGxlcic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIGtleUhhbmRsZXJzOiBbLi4uc3RhdGUua2V5SGFuZGxlcnMsIGFjdGlvbi5rZXlIYW5kbGVyXSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSAnUHJlc3NLZXknOlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhbiBhbnRpLXBhdHRlcm4gYnV0IGl0IHdvcmtzIGZvciB0aGUgY2FzZSB3aGVyZVxuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgYWN0dWFsbHkgY29udHJvbCB0aGUgc3RhdGUgYnV0IHdlIHN0aWxsIHdhbnQgdG9cbiAgICAgICAgICAgIC8vIGNvbW11bmljYXRlIHdpdGggdGhlIG90aGVyIG9iamVjdFxuICAgICAgICAgICAgc3RhdGUua2V5SGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGFjdGlvbi5rZXksIGFjdGlvbi5jbWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8oa2V2aW5iKSBoYXZlIHRoZSBoYW5kbGVyIHJldHVybiBzdGF0ZSBmcm9tIE1hdGhRdWlsbCBhbmQgc3RvcmUgaXRcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcblxuICAgICAgICBjYXNlICdQcmVzc0JhY2tzcGFjZSc6XG4gICAgICAgICAgICBzdGF0ZS5rZXlIYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoJ2JhY2tzcGFjZScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuXG5cbmNvbnN0IHN0b3JlID0gUmVkdXguY3JlYXRlU3RvcmUocmVkdWNlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9zdG9yZS5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 217:
/***/ function(module, exports) {

	eval("'use strict';\n\nvar Keys = {\n    BACKSPACE: 'Backspace',\n    LEFT: 'Left',\n    RIGHT: 'Right',\n    TAB: 'Tab',\n    ENTER: 'Enter'\n};\n\nmodule.exports = Keys;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMva2V5cy5qcz83MGVhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBTSxPQUFPO0FBQ1QsZUFBVyxXQUFYO0FBQ0EsVUFBTSxNQUFOO0FBQ0EsV0FBTyxPQUFQO0FBQ0EsU0FBSyxLQUFMO0FBQ0EsV0FBTyxPQUFQO0NBTEU7O0FBUU4sT0FBTyxPQUFQLEdBQWlCLElBQWpCIiwiZmlsZSI6IjIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEtleXMgPSB7XG4gICAgQkFDS1NQQUNFOiAnQmFja3NwYWNlJyxcbiAgICBMRUZUOiAnTGVmdCcsXG4gICAgUklHSFQ6ICdSaWdodCcsXG4gICAgVEFCOiAnVGFiJyxcbiAgICBFTlRFUjogJ0VudGVyJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5cztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2tleXMuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 218:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar React = __webpack_require__(1);\n\nvar _require = __webpack_require__(190);\n\nvar StyleSheet = _require.StyleSheet;\n\nvar _require2 = __webpack_require__(211);\n\nvar View = _require2.View;\n\nvar KeypadButton = __webpack_require__(219);\nvar actions = __webpack_require__(215);\nvar Symbols = __webpack_require__(220);\nvar Keys = __webpack_require__(217);\n\nvar CMD = true;\n\nvar MathKeypad = React.createClass({\n    displayName: 'MathKeypad',\n    render: function render() {\n        return React.createElement(\n            View,\n            { style: styles.keypad },\n            React.createElement(\n                View,\n                { style: styles.row },\n                React.createElement(KeypadButton, { label: '7', onClick: function onClick() {\n                        return actions.pressKey(\"7\");\n                    }, style: styles.firstKey }),\n                React.createElement(KeypadButton, { label: '8', onClick: function onClick() {\n                        return actions.pressKey(\"8\");\n                    } }),\n                React.createElement(KeypadButton, { label: '9', onClick: function onClick() {\n                        return actions.pressKey(\"9\");\n                    } }),\n                React.createElement(KeypadButton, { label: '+', onClick: function onClick() {\n                        return actions.pressKey(\"+\");\n                    } }),\n                React.createElement(KeypadButton, { label: '^', onClick: function onClick() {\n                        return actions.pressKey(\"^\", CMD);\n                    } }),\n                React.createElement(KeypadButton, { label: Symbols.LEFT_ARROW, onClick: function onClick() {\n                        return actions.pressKey(Keys.LEFT);\n                    }, style: styles.lastKey })\n            ),\n            React.createElement(\n                View,\n                { style: styles.row },\n                React.createElement(KeypadButton, { label: '4', onClick: function onClick() {\n                        return actions.pressKey(\"4\");\n                    }, style: styles.firstKey }),\n                React.createElement(KeypadButton, { label: '5', onClick: function onClick() {\n                        return actions.pressKey(\"5\");\n                    } }),\n                React.createElement(KeypadButton, { label: '6', onClick: function onClick() {\n                        return actions.pressKey(\"6\");\n                    } }),\n                React.createElement(KeypadButton, { label: Symbols.MINUS, onClick: function onClick() {\n                        return actions.pressKey(\"-\");\n                    } }),\n                React.createElement(KeypadButton, { label: Symbols.SQRT, onClick: function onClick() {\n                        return actions.pressKey(\"sqrt\", CMD);\n                    } }),\n                React.createElement(KeypadButton, { label: Symbols.RIGHT_ARROW, onClick: function onClick() {\n                        return actions.pressKey(Keys.RIGHT);\n                    }, style: styles.lastKey })\n            ),\n            React.createElement(\n                View,\n                { style: styles.row },\n                React.createElement(KeypadButton, { label: '1', onClick: function onClick() {\n                        return actions.pressKey(\"1\");\n                    }, style: styles.firstKey }),\n                React.createElement(KeypadButton, { label: '2', onClick: function onClick() {\n                        return actions.pressKey(\"2\");\n                    } }),\n                React.createElement(KeypadButton, { label: '3', onClick: function onClick() {\n                        return actions.pressKey(\"3\");\n                    } }),\n                React.createElement(KeypadButton, { label: Symbols.TIMES, onClick: function onClick() {\n                        return actions.pressKey(\"\\\\times\");\n                    } }),\n                React.createElement(KeypadButton, { label: Symbols.CDOT, onClick: function onClick() {\n                        return actions.pressKey(\"\\\\cdot\");\n                    } }),\n                React.createElement(KeypadButton, { label: '=', onClick: function onClick() {\n                        return actions.pressKey(\"=\");\n                    }, style: styles.lastKey })\n            ),\n            React.createElement(\n                View,\n                { style: styles.row },\n                React.createElement(KeypadButton, { label: 'x', onClick: function onClick() {\n                        return actions.pressKey(\"x\");\n                    }, style: [styles.firstKey, styles.bottomKey] }),\n                React.createElement(KeypadButton, { label: '0', onClick: function onClick() {\n                        return actions.pressKey(\"0\");\n                    }, style: styles.bottomKey }),\n                React.createElement(KeypadButton, { label: '.', onClick: function onClick() {\n                        return actions.pressKey(\".\");\n                    }, style: styles.bottomKey }),\n                React.createElement(KeypadButton, { label: Symbols.DIVISION, onClick: function onClick() {\n                        return actions.pressKey(\"\\\\div\");\n                    }, style: styles.bottomKey }),\n                React.createElement(KeypadButton, { label: '/', onClick: function onClick() {\n                        return actions.pressKey(\"/\", CMD);\n                    }, style: styles.bottomKey }),\n                React.createElement(KeypadButton, { label: Symbols.BACKSPACE, onClick: function onClick() {\n                        return actions.pressKey(Keys.BACKSPACE);\n                    }, style: [styles.lastKey, styles.bottomKey] })\n            )\n        );\n    }\n});\n\nvar styles = StyleSheet.create({\n    row: {\n        flexDirection: 'row'\n    },\n    // TODO(kevinb): ask Emily about :last-child selector\n    firstKey: {\n        borderLeftWidth: 1\n    },\n    lastKey: {\n        borderRightWidth: 1\n    },\n    bottomKey: {\n        borderBottomWidth: 1\n    },\n    keypad: {\n        position: 'fixed',\n        bottom: 0,\n        width: '100%'\n    }\n});\n\nmodule.exports = MathKeypad;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC1rZXlwYWQuanM/ODdkMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQU0sUUFBUSxvQkFBUSxDQUFSLENBQVI7O2VBQ2lCLG9CQUFRLEdBQVI7O0lBQWY7O2dCQUVTLG9CQUFRLEdBQVI7O0lBQVQ7O0FBQ1IsSUFBTSxlQUFlLG9CQUFRLEdBQVIsQ0FBZjtBQUNOLElBQU0sVUFBVSxvQkFBUSxHQUFSLENBQVY7QUFDTixJQUFNLFVBQVUsb0JBQVEsR0FBUixDQUFWO0FBQ04sSUFBTSxPQUFPLG9CQUFRLEdBQVIsQ0FBUDs7QUFFTixJQUFNLE1BQU0sSUFBTjs7QUFFTixJQUFNLGFBQWEsTUFBTSxXQUFOLENBQWtCOztBQUNqQyw4QkFBUztBQUNMLGVBQU87QUFBQyxnQkFBRDtjQUFNLE9BQU8sT0FBTyxNQUFQLEVBQWI7WUFDSDtBQUFDLG9CQUFEO2tCQUFNLE9BQU8sT0FBTyxHQUFQLEVBQWI7Z0JBQ0ksb0JBQUMsWUFBRCxJQUFjLE9BQU0sR0FBTixFQUFVLFNBQVM7K0JBQU0sUUFBUSxRQUFSLENBQWlCLEdBQWpCO3FCQUFOLEVBQTZCLE9BQU8sT0FBTyxRQUFQLEVBQXJFLENBREo7Z0JBRUksb0JBQUMsWUFBRCxJQUFjLE9BQU0sR0FBTixFQUFVLFNBQVM7K0JBQU0sUUFBUSxRQUFSLENBQWlCLEdBQWpCO3FCQUFOLEVBQWpDLENBRko7Z0JBR0ksb0JBQUMsWUFBRCxJQUFjLE9BQU0sR0FBTixFQUFVLFNBQVM7K0JBQU0sUUFBUSxRQUFSLENBQWlCLEdBQWpCO3FCQUFOLEVBQWpDLENBSEo7Z0JBSUksb0JBQUMsWUFBRCxJQUFjLE9BQU0sR0FBTixFQUFVLFNBQVM7K0JBQU0sUUFBUSxRQUFSLENBQWlCLEdBQWpCO3FCQUFOLEVBQWpDLENBSko7Z0JBS0ksb0JBQUMsWUFBRCxJQUFjLE9BQU0sR0FBTixFQUFVLFNBQVM7K0JBQU0sUUFBUSxRQUFSLENBQWlCLEdBQWpCLEVBQXNCLEdBQXRCO3FC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Z0JBSUksb0JBQUMsWUFBRCxJQUFjLE9BQU8sUUFBUSxRQUFSLEVBQWtCLFNBQVM7K0JBQU0sUUFBUSxRQUFSLENBQWlCLE9BQWpCO3FCQUFOLEVBQWlDLE9BQU8sT0FBTyxTQUFQLEVBQXhGLENBSko7Z0JBS0ksb0JBQUMsWUFBRCxJQUFjLE9BQU0sR0FBTixFQUFVLFNBQVM7K0JBQU0sUUFBUSxRQUFSLENBQWlCLEdBQWpCLEVBQXNCLEdBQXRCO3FCQUFOLEVBQWtDLE9BQU8sT0FBTyxTQUFQLEVBQTFFLENBTEo7Z0JBTUksb0JBQUMsWUFBRCxJQUFjLE9BQU8sUUFBUSxTQUFSLEVBQW1CLFNBQVM7K0JBQU0sUUFBUSxRQUFSLENBQWlCLEtBQUssU0FBTDtxQkFBdkIsRUFBd0MsT0FBTyxDQUFDLE9BQU8sT0FBUCxFQUFnQixPQUFPLFNBQVAsQ0FBeEIsRUFBekYsQ0FOSjthQXpCRztTQUFQLENBREs7S0FEd0I7Q0FBbEIsQ0FBYjs7QUF1Q04sSUFBTSxTQUFTLFdBQVcsTUFBWCxDQUFrQjtBQUM3QixTQUFLO0FBQ0QsdUJBQWUsS0FBZjtLQURKOztBQUlBLGNBQVU7QUFDTix5QkFBaUIsQ0FBakI7S0FESjtBQUdBLGFBQVM7QUFDTCwwQkFBa0IsQ0FBbEI7S0FESjtBQUdBLGVBQVc7QUFDUCwyQkFBbUIsQ0FBbkI7S0FESjtBQUdBLFlBQVE7QUFDSixrQkFBVSxPQUFWO0FBQ0EsZ0JBQVEsQ0FBUjtBQUNBLGVBQU8sTUFBUDtLQUhKO0NBZFcsQ0FBVDs7QUFxQk4sT0FBTyxPQUFQLEdBQWlCLFVBQWpCIiwiZmlsZSI6IjIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IHsgU3R5bGVTaGVldCB9ID0gcmVxdWlyZSgnYXBocm9kaXRlJyk7XG5cbmNvbnN0IHsgVmlldyB9ID0gcmVxdWlyZSgnLi9yZWFjdC1uYXRpdmUnKTtcbmNvbnN0IEtleXBhZEJ1dHRvbiA9IHJlcXVpcmUoJy4va2V5cGFkLWJ1dHRvbicpO1xuY29uc3QgYWN0aW9ucyA9IHJlcXVpcmUoJy4vYWN0aW9ucycpO1xuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4vc3ltYm9scycpO1xuY29uc3QgS2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5jb25zdCBDTUQgPSB0cnVlO1xuXG5jb25zdCBNYXRoS2V5cGFkID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIDxWaWV3IHN0eWxlPXtzdHlsZXMua2V5cGFkfT5cbiAgICAgICAgICAgIDxWaWV3IHN0eWxlPXtzdHlsZXMucm93fT5cbiAgICAgICAgICAgICAgICA8S2V5cGFkQnV0dG9uIGxhYmVsPVwiN1wiIG9uQ2xpY2s9eygpID0+IGFjdGlvbnMucHJlc3NLZXkoXCI3XCIpfSBzdHlsZT17c3R5bGVzLmZpcnN0S2V5fS8+XG4gICAgICAgICAgICAgICAgPEtleXBhZEJ1dHRvbiBsYWJlbD1cIjhcIiBvbkNsaWNrPXsoKSA9PiBhY3Rpb25zLnByZXNzS2V5KFwiOFwiKX0gLz5cbiAgICAgICAgICAgICAgICA8S2V5cGFkQnV0dG9uIGxhYmVsPVwiOVwiIG9uQ2xpY2s9eygpID0+IGFjdGlvbnMucHJlc3NLZXkoXCI5XCIpfSAvPlxuICAgICAgICAgICAgICAgIDxLZXlwYWRCdXR0b24gbGFiZWw9XCIrXCIgb25DbGljaz17KCkgPT4gYWN0aW9ucy5wcmVzc0tleShcIitcIil9IC8+XG4gICAgICAgICAgICAgICAgPEtleXBhZEJ1dHRvbiBsYWJlbD1cIl5cIiBvbkNsaWNrPXsoKSA9PiBhY3Rpb25zLnByZXNzS2V5KFwiXlwiLCBDTUQpfSAvPlxuICAgICAgICAgICAgICAgIDxLZXlwYWRCdXR0b24gbGFiZWw9e1N5bWJvbHMuTEVGVF9BUlJPV30gb25DbGljaz17KCkgPT4gYWN0aW9ucy5wcmVzc0tleShLZXlzLkxFRlQpfSBzdHlsZT17c3R5bGVzLmxhc3RLZXl9Lz5cbiAgICAgICAgICAgIDwvVmlldz5cbiAgICAgICAgICAgIDxWaWV3IHN0eWxlPXtzdHlsZXMucm93fT5cbiAgICAgICAgICAgICAgICA8S2V5cGFkQnV0dG9uIGxhYmVsPVwiNFwiIG9uQ2xpY2s9eygpID0+IGFjdGlvbnMucHJlc3NLZXkoXCI0XCIpfSBzdHlsZT17c3R5bGVzLmZpcnN0S2V5fSAvPlxuICAgICAgICAgICAgICAgIDxLZXlwYWRCdXR0b24gbGFiZWw9XCI1XCIgb25DbGljaz17KCkgPT4gYWN0aW9ucy5wcmVzc0tleShcIjVcIil9IC8+XG4gICAgICAgICAgICAgICAgPEtleXBhZEJ1dHRvbiBsYWJlbD1cIjZcIiBvbkNsaWNrPXsoKSA9PiBhY3Rpb25zLnByZXNzS2V5KFwiNlwiKX0gLz5cbiAgICAgICAgICAgICAgICA8S2V5cGFkQnV0dG9uIGxhYmVsPXtTeW1ib2xzLk1JTlVTfSBvbkNsaWNrPXsoKSA9PiBhY3Rpb25zLnByZXNzS2V5KFwiLVwiKX0gLz5cbiAgICAgICAgICAgICAgICA8S2V5cGFkQnV0dG9uIGxhYmVsPXtTeW1ib2xzLlNRUlR9IG9uQ2xpY2s9eygpID0+IGFjdGlvbnMucHJlc3NLZXkoXCJzcXJ0XCIsIENNRCl9IC8+XG4gICAgICAgICAgICAgICAgPEtleXBhZEJ1dHRvbiBsYWJlbD17U3ltYm9scy5SSUdIVF9BUlJPV30gb25DbGljaz17KCkgPT4gYWN0aW9ucy5wcmVzc0tleShLZXlzLlJJR0hUKX0gc3R5bGU9e3N0eWxlcy5sYXN0S2V5fSAvPlxuICAgICAgICAgICAgPC9WaWV3PlxuICAgICAgICAgICAgPFZpZXcgc3R5bGU9e3N0eWxlcy5yb3d9PlxuICAgICAgICAgICAgICAgIDxLZXlwYWRCdXR0b24gbGFiZWw9XCIxXCIgb25DbGljaz17KCkgPT4gYWN0aW9ucy5wcmVzc0tleShcIjFcIil9IHN0eWxlPXtzdHlsZXMuZmlyc3RLZXl9IC8+XG4gICAgICAgICAgICAgICAgPEtleXBhZEJ1dHRvbiBsYWJlbD1cIjJcIiBvbkNsaWNrPXsoKSA9PiBhY3Rpb25zLnByZXNzS2V5KFwiMlwiKX0gLz5cbiAgICAgICAgICAgICAgICA8S2V5cGFkQnV0dG9uIGxhYmVsPVwiM1wiIG9uQ2xpY2s9eygpID0+IGFjdGlvbnMucHJlc3NLZXkoXCIzXCIpfSAvPlxuICAgICAgICAgICAgICAgIDxLZXlwYWRCdXR0b24gbGFiZWw9e1N5bWJvbHMuVElNRVN9IG9uQ2xpY2s9eygpID0+IGFjdGlvbnMucHJlc3NLZXkoXCJcXFxcdGltZXNcIil9IC8+XG4gICAgICAgICAgICAgICAgPEtleXBhZEJ1dHRvbiBsYWJlbD17U3ltYm9scy5DRE9UfSBvbkNsaWNrPXsoKSA9PiBhY3Rpb25zLnByZXNzS2V5KFwiXFxcXGNkb3RcIil9Lz5cbiAgICAgICAgICAgICAgICA8S2V5cGFkQnV0dG9uIGxhYmVsPVwiPVwiIG9uQ2xpY2s9eygpID0+IGFjdGlvbnMucHJlc3NLZXkoXCI9XCIpfSAgc3R5bGU9e3N0eWxlcy5sYXN0S2V5fSAvPlxuICAgICAgICAgICAgPC9WaWV3PlxuICAgICAgICAgICAgPFZpZXcgc3R5bGU9e3N0eWxlcy5yb3d9PlxuICAgICAgICAgICAgICAgIDxLZXlwYWRCdXR0b24gbGFiZWw9XCJ4XCIgb25DbGljaz17KCkgPT4gYWN0aW9ucy5wcmVzc0tleShcInhcIil9IHN0eWxlPXtbc3R5bGVzLmZpcnN0S2V5LCBzdHlsZXMuYm90dG9tS2V5XX0gLz5cbiAgICAgICAgICAgICAgICA8S2V5cGFkQnV0dG9uIGxhYmVsPVwiMFwiIG9uQ2xpY2s9eygpID0+IGFjdGlvbnMucHJlc3NLZXkoXCIwXCIpfSBzdHlsZT17c3R5bGVzLmJvdHRvbUtleX0gLz5cbiAgICAgICAgICAgICAgICA8S2V5cGFkQnV0dG9uIGxhYmVsPVwiLlwiIG9uQ2xpY2s9eygpID0+IGFjdGlvbnMucHJlc3NLZXkoXCIuXCIpfSBzdHlsZT17c3R5bGVzLmJvdHRvbUtleX0gLz5cbiAgICAgICAgICAgICAgICA8S2V5cGFkQnV0dG9uIGxhYmVsPXtTeW1ib2xzLkRJVklTSU9OfSBvbkNsaWNrPXsoKSA9PiBhY3Rpb25zLnByZXNzS2V5KFwiXFxcXGRpdlwiKX0gc3R5bGU9e3N0eWxlcy5ib3R0b21LZXl9ICAvPlxuICAgICAgICAgICAgICAgIDxLZXlwYWRCdXR0b24gbGFiZWw9XCIvXCIgb25DbGljaz17KCkgPT4gYWN0aW9ucy5wcmVzc0tleShcIi9cIiwgQ01EKX0gc3R5bGU9e3N0eWxlcy5ib3R0b21LZXl9ICAvPlxuICAgICAgICAgICAgICAgIDxLZXlwYWRCdXR0b24gbGFiZWw9e1N5bWJvbHMuQkFDS1NQQUNFfSBvbkNsaWNrPXsoKSA9PiBhY3Rpb25zLnByZXNzS2V5KEtleXMuQkFDS1NQQUNFKX0gc3R5bGU9e1tzdHlsZXMubGFzdEtleSwgc3R5bGVzLmJvdHRvbUtleV19IC8+XG4gICAgICAgICAgICA8L1ZpZXc+XG4gICAgICAgIDwvVmlldz47XG4gICAgfVxufSk7XG5cbmNvbnN0IHN0eWxlcyA9IFN0eWxlU2hlZXQuY3JlYXRlKHtcbiAgICByb3c6IHtcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gICAgfSxcbiAgICAvLyBUT0RPKGtldmluYik6IGFzayBFbWlseSBhYm91dCA6bGFzdC1jaGlsZCBzZWxlY3RvclxuICAgIGZpcnN0S2V5OiB7XG4gICAgICAgIGJvcmRlckxlZnRXaWR0aDogMSxcbiAgICB9LFxuICAgIGxhc3RLZXk6IHtcbiAgICAgICAgYm9yZGVyUmlnaHRXaWR0aDogMSxcbiAgICB9LFxuICAgIGJvdHRvbUtleToge1xuICAgICAgICBib3JkZXJCb3R0b21XaWR0aDogMSxcbiAgICB9LFxuICAgIGtleXBhZDoge1xuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGhLZXlwYWQ7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tYXRoLWtleXBhZC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 219:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar React = __webpack_require__(1);\n\nvar _require = __webpack_require__(190);\n\nvar StyleSheet = _require.StyleSheet;\n\nvar _require2 = __webpack_require__(211);\n\nvar Text = _require2.Text;\nvar View = _require2.View;\n\n\nvar KeypadButton = function KeypadButton(props) {\n    var style = [styles.button].concat(_toConsumableArray(Array.isArray(props.style) ? props.style : [props.style]));\n\n    return React.createElement(\n        View,\n        { style: style, onClick: props.onClick },\n        React.createElement(\n            Text,\n            { style: styles.text },\n            props.label\n        )\n    );\n};\n\nKeypadButton.propTypes = {\n    label: React.PropTypes.string.isRequired,\n    onClick: React.PropTypes.func.isRequired\n};\n\nvar styles = StyleSheet.create({\n    button: {\n        width: '100%',\n        height: 60,\n        borderColor: '#BBB',\n        borderStyle: 'solid',\n        borderTopWidth: 1,\n        borderRightWidth: 1,\n        lineHeight: '60px',\n        textAlign: 'center',\n        backgroundColor: '#EEE'\n    },\n    text: {\n        fontFamily: 'sans-serif',\n        fontSize: 32\n    }\n});\n\nmodule.exports = KeypadButton;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMva2V5cGFkLWJ1dHRvbi5qcz84NTEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFNLFFBQVEsb0JBQVEsQ0FBUixDQUFSOztlQUNpQixvQkFBUSxHQUFSOztJQUFmOztnQkFDZSxvQkFBUSxHQUFSOztJQUFmO0lBQU07OztBQUdkLElBQU0sZUFBZSxTQUFmLFlBQWUsQ0FBQyxLQUFELEVBQVc7QUFDNUIsUUFBTSxTQUNGLE9BQU8sTUFBUCw0QkFHSSxNQUFNLE9BQU4sQ0FBYyxNQUFNLEtBQU4sQ0FBZCxHQUE2QixNQUFNLEtBQU4sR0FBYyxDQUFDLE1BQU0sS0FBTixDQUE1QyxFQUpGLENBRHNCOztBQVE1QixXQUFPO0FBQUMsWUFBRDtVQUFNLE9BQU8sS0FBUCxFQUFjLFNBQVMsTUFBTSxPQUFOLEVBQTdCO1FBQ0g7QUFBQyxnQkFBRDtjQUFNLE9BQU8sT0FBTyxJQUFQLEVBQWI7WUFDSyxNQUFNLEtBQU47U0FGRjtLQUFQLENBUjRCO0NBQVg7O0FBZXJCLGFBQWEsU0FBYixHQUF5QjtBQUNyQixXQUFPLE1BQU0sU0FBTixDQUFnQixNQUFoQixDQUF1QixVQUF2QjtBQUNQLGFBQVMsTUFBTSxTQUFOLENBQWdCLElBQWhCLENBQXFCLFVBQXJCO0NBRmI7O0FBS0EsSUFBTSxTQUFTLFdBQVcsTUFBWCxDQUFrQjtBQUM3QixZQUFRO0FBQ0osZUFBTyxNQUFQO0FBQ0EsZ0JBQVEsRUFBUjtBQUNBLHFCQUFhLE1BQWI7QUFDQSxxQkFBYSxPQUFiO0FBQ0Esd0JBQWdCLENBQWhCO0FBQ0EsMEJBQWtCLENBQWxCO0FBQ0Esb0JBQVksTUFBWjtBQUNBLG1CQUFXLFFBQVg7QUFDQSx5QkFBaUIsTUFBakI7S0FUSjtBQVdBLFVBQU07QUFDRixvQkFBWSxZQUFaO0FBQ0Esa0JBQVUsRUFBVjtLQUZKO0NBWlcsQ0FBVDs7QUFrQk4sT0FBTyxPQUFQLEdBQWlCLFlBQWpCIiwiZmlsZSI6IjIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IHsgU3R5bGVTaGVldCB9ID0gcmVxdWlyZSgnYXBocm9kaXRlJyk7XG5jb25zdCB7IFRleHQsIFZpZXcgfSA9IHJlcXVpcmUoJy4vcmVhY3QtbmF0aXZlJyk7XG5cblxuY29uc3QgS2V5cGFkQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSBbXG4gICAgICAgIHN0eWxlcy5idXR0b24sXG4gICAgICAgIC8vIFJlYWN0IE5hdGl2ZSBhbGxvd3MgeW91IHRvIHNldCB0aGUgJ3N0eWxlJyBwcm9wcyBvbiB1c2VyIGRlZmluZWRcbiAgICAgICAgLy8gY29tcG9uZW50cywgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QtbmF0aXZlL2RvY3Mvc3R5bGUuaHRtbFxuICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShwcm9wcy5zdHlsZSkgPyBwcm9wcy5zdHlsZSA6IFtwcm9wcy5zdHlsZV0pXG4gICAgXTtcblxuICAgIHJldHVybiA8VmlldyBzdHlsZT17c3R5bGV9IG9uQ2xpY2s9e3Byb3BzLm9uQ2xpY2t9PlxuICAgICAgICA8VGV4dCBzdHlsZT17c3R5bGVzLnRleHR9PlxuICAgICAgICAgICAge3Byb3BzLmxhYmVsfVxuICAgICAgICA8L1RleHQ+XG4gICAgPC9WaWV3Pjtcbn07XG5cbktleXBhZEJ1dHRvbi5wcm9wVHlwZXMgPSB7XG4gICAgbGFiZWw6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBvbkNsaWNrOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxufTtcblxuY29uc3Qgc3R5bGVzID0gU3R5bGVTaGVldC5jcmVhdGUoe1xuICAgIGJ1dHRvbjoge1xuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6IDYwLFxuICAgICAgICBib3JkZXJDb2xvcjogJyNCQkInLFxuICAgICAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgYm9yZGVyVG9wV2lkdGg6IDEsXG4gICAgICAgIGJvcmRlclJpZ2h0V2lkdGg6IDEsXG4gICAgICAgIGxpbmVIZWlnaHQ6ICc2MHB4JyxcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI0VFRScsXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICAgIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgZm9udFNpemU6IDMyLFxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleXBhZEJ1dHRvbjtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2tleXBhZC1idXR0b24uanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 220:
/***/ function(module, exports) {

	eval("\"use strict\";\n\nvar Symbols = {\n    MINUS: \"\",\n    SQRT: \"\",\n    TIMES: \"\",\n    DIVISION: \"\",\n    CDOT: \"\",\n    BACKSPACE: \"\",\n\n    // Arrows\n    LEFT_ARROW: \"\",\n    RIGHT_ARROW: \"\"\n};\n\nmodule.exports = Symbols;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3ltYm9scy5qcz80MGIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBTSxVQUFVO0FBQ1osV0FBTyxHQUFQO0FBQ0EsVUFBTSxHQUFOO0FBQ0EsV0FBTyxHQUFQO0FBQ0EsY0FBVSxHQUFWO0FBQ0EsVUFBTSxHQUFOO0FBQ0EsZUFBVyxHQUFYOzs7QUFHQSxnQkFBWSxHQUFaO0FBQ0EsaUJBQWEsR0FBYjtDQVZFOztBQWFOLE9BQU8sT0FBUCxHQUFpQixPQUFqQiIsImZpbGUiOiIyMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTeW1ib2xzID0ge1xuICAgIE1JTlVTOiBcIlxcdTIyMTJcIixcbiAgICBTUVJUOiBcIlxcdTIyMUFcIixcbiAgICBUSU1FUzogXCJcXHUwMEQ3XCIsXG4gICAgRElWSVNJT046IFwiXFx1MDBGN1wiLFxuICAgIENET1Q6IFwiXFx1MDBCN1wiLFxuICAgIEJBQ0tTUEFDRTogXCJcXHUyMzJCXCIsXG5cbiAgICAvLyBBcnJvd3NcbiAgICBMRUZUX0FSUk9XOiBcIlxcdTIxOTBcIixcbiAgICBSSUdIVF9BUlJPVzogXCJcXHUyMTkyXCIsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbHM7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9zeW1ib2xzLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }

});